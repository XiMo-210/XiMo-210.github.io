<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惜寞的无人小间</title>
  
  
  <link href="https://lonesome.cn/atom.xml" rel="self"/>
  
  <link href="https://lonesome.cn/"/>
  <updated>2024-12-13T15:04:50.976Z</updated>
  <id>https://lonesome.cn/</id>
  
  <author>
    <name>惜寞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次投票系统异常</title>
    <link href="https://lonesome.cn/posts/vote-system-exception/"/>
    <id>https://lonesome.cn/posts/vote-system-exception/</id>
    <published>2024-12-11T11:30:47.000Z</published>
    <updated>2024-12-13T15:04:50.976Z</updated>
    
    <content type="html"><![CDATA[<p>肇事人的事故记录在这 &#x3D;&gt; <a href="https://blog.phlin.top/2024/12/11/mysql-cpu-trouble/">一次 MySQL 差点爆了的事故</a>，本文为事后复盘。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周接到通知，要进行 2024 年度“十佳大学生”和“示范班级”线上投票，投票程序要求如下：</p><ul><li>投票时间：12 月 11 日 00:00-12 月 13 日 23:59</li><li>可投票人员：校内师生</li><li>投票规则：每人每天有一次投票机会，每一票需投满 10 个候选人</li></ul><p>上届使用的是问卷网，但无法满足对投票人员（校内师生）的限制，正好今年精弘内部的<strong>问卷系统</strong>已经投入使用，于是决定基于此进行投票业务的拓展，同时接入学校<strong>统一身份认证</strong>系统，以满足需求。</p><p><strong>12.10 23:06</strong> 更新完的系统经过内部测试后上线生产环境。</p><p><strong>12.11 00:00</strong> 开始有零星人员投票，系统无异常，各岗位下班。</p><h2 id="异常发现"><a href="#异常发现" class="headerlink" title="异常发现"></a>异常发现</h2><p><strong>12:01</strong> 前端负责同学发现<strong>获取投票数据</strong>接口出现<strong>超时</strong>问题，错误反馈如下图（timeout of 10000ms exceeded），即对后端的<strong>请求+响应</strong>时间超过了 request.js 设置的 10s 超时时间。<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/1.webp"><br>具体影响为票数结果和排名无显示或延迟显示，可见下图对比：</p><ul><li>正常情况<ul><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/2.webp"></li></ul></li><li>超时情况<ul><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/3.webp"></li></ul></li></ul><p><strong>12:17</strong> 接到熟人反馈。<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/4.webp"></p><p><strong>12:30</strong> 后端负责同学经过日志和初步测试，发现该接口<strong>平均响应时间</strong>达到了 <strong>7s</strong> 以上。<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/5.webp"></p><p><strong>12:42</strong> 部门老员工发现服务器中 <strong>MySQL</strong> 的<strong>CPU 使用率变化幅度极大</strong>，<strong>峰值 CPU</strong> 打满了 2 个核达到了 <strong>200%</strong> ，可见下图：</p><ul><li>低谷<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/6.webp"></li><li>峰值<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/7.webp"></li></ul><p>由于担心 MySQL 的 CPU 占用长时间过高被系统 kill，带着微精弘的服务一起挂掉，开始紧急排查。</p><h2 id="根因定位"><a href="#根因定位" class="headerlink" title="根因定位"></a>根因定位</h2><p>根据日志和后台首先可以排除 QPS 的并发问题，毕竟这是投票业务而非抢票业务，实际上精弘毅行的抢票也没有达到如此高的 CPU 占用，于是怀疑是接口中的 <strong>SQL 调用</strong>问题。结合之前的超时情况，基本可以直接定位到<strong>获取投票数据</strong>接口。</p><p>对该接口的业务代码进行分析后，果然找到了导致 <strong>MySQL 高占用的根因</strong>。下图是相关的代码，这边先抛开业务逻辑，可以看到框出的两行代码嵌入在一个<strong>大循环</strong>里面。<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/8.webp"><br>而这两行代码都各自对应着一条查询的 SQL，如下图所示，SQL 很简单，但是叠加上 <strong>O(N^3)</strong> 的循环，直接导致在<strong>短时间</strong>内有<strong>大量 SQL</strong> 打入数据库，引起 <strong>CPU 的激增</strong>。<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/9.webp"></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>重新梳理一下业务处理逻辑，该接口用于<strong>投票数据统计</strong>，采取的方案是简单粗暴的<strong>循环遍历</strong>，其整体流程如下（已简化）：</p><ul><li>第一层循环<code>for _, sheet := range answerSheets</code><ul><li><code>answerSheets</code>代表的是所有的<strong>投票答卷</strong>信息，每份<code>sheet</code>中包含的信息可参考下图，该循环所代表的是<strong>遍历每个人的 AnswerSheet（投票答卷）</strong>，有几份答卷此处就循环几次</li><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/10.webp"></li></ul></li><li>第二层循环<code>for _, answer := range sheet.Answers</code><ul><li><code>sheet.Answers</code>中包含的信息同样可参考上图，该循环代表<strong>遍历投票答卷中的所有 Question（问题）</strong>，有几个问题此处就循环几次</li><li>从 MySQL 中查询问题（都是选择题型）的所有 <strong>Option（选项）</strong></li><li><code>if question.QuestionType == 1 || question.QuestionType == 2</code>，这里 <code>type</code> 的 1 和 2 分别代表单选题和多选题</li><li><code>answerOptions := strings.Split(answer.Content, &quot;┋&quot;)</code>，多选题的<strong>Answer（回答）</strong> 记录方式是<code>option1┋option2┋option3</code>，因此使用 <strong>Split</strong> 分割 ┋ 获取答卷选择的选项</li></ul></li><li>第三层循环<code>for _, answerOption := range answerOptions</code><ul><li>即<strong>遍历答卷问题所选择的所有选项</strong>，选几个选项此处就循环几次</li><li>从 MySQL 中查询<code>answerOption</code>对应的选项，包含信息如下图所示：</li><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/11.webp"></li><li>在<code>optionCounts</code>的 map 中根据选项中的<code>QuestionID</code>和<code>SerialNum</code>开始计数，以实现统计各个问题中各个选项的票数</li></ul></li></ul><p>上面进行的分析，是为了方便理解下面的计算。十佳投票截止 <strong>12:00</strong> 共收集到 <strong>715</strong> 份答卷，仅计算循环内，从每一个<strong>获取投票数据</strong>接口的请求进来开始，会查询 MySQL 共 <strong>715*1*(1+10)&#x3D;7865</strong> 次。</p><ul><li>715 是第一个循环的投票答卷数</li><li>第一个 1 是第二个循环的问题个数，此处十佳投票仅 1 个问题</li><li>第二个 1 是第二个循环下<code>GetOptionsByQuestionID</code>的 SQL 查询执行次数</li><li>10 是第三个循环的答卷选项个数，此处十佳投票限制每次需投 10 票，也代表<code>GetOptionByQIDAndAnswer</code>的 SQL 查询执行次数</li></ul><p>同时该数据会随投票人数的增多而不断增长，保守预计最后的答卷至少会破 <strong>2000</strong> 份，也就是说最后 MySQL 会迎来 <strong>2w 级的 TPS</strong>。</p><h2 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h2><p>为了防止 MySQL 真的被 kill 掉或者服务器崩盘，临时准备将<strong>获取投票数据</strong>的接口<strong>降级</strong>（即 ban 掉该接口），因为投票的核心业务在投票，是否能查看到该投票数据本身的影响并不大。</p><p>不过该业务的负责人亡羊补牢，给出了临时优化方案：将<strong>高频读取</strong>的数据存储到 <strong>Redis（高性能的内存数据库）</strong> 中进行缓存。</p><p>在查询 MySQL 前先查询 Redis 缓存中是否存在，若存在（即命中）则直接从 Redis 返回数据，若不存在则查询 MySQL 后先将数据更新至 Redis 缓存中再返回，流程图可参考如下：<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/2-1.webp"></p><p>等价于将循环内的请求都从 <strong>MySQL 转到了 Redis</strong>，对于 Redis 而言哪怕是 <strong>2w 级 TPS</strong> 也在承受范围之内。</p><p><strong>14:28</strong> 后端负责人给出了初步优化代码，代码如下：<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/2-2.webp"></p><p><strong>14:38</strong> 测试无误后上线生产环境，优化后情况如下：</p><ul><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/12.webp"></li><li><strong>峰值 CPU 使用率大幅度降低</strong></li><li>MySQL CPU 使用率回到<strong>正常水平</strong></li><li><strong>接口响应时间</strong>降低至 <strong>800ms</strong> 内</li><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/13.webp"></li></ul><p>不过代价是 Redis 的 CPU 使用率开始增加，不过在可控范围之内。</p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>燃眉之急已经解决，但是依然有较高的 <strong>CPU 波动</strong>存在，以及依旧会随着投票人数的增多进行上涨。</p><p>进一步优化的方法其实也很简单，因为实际上查询的数据都是<strong>重复</strong>的，完全可以在进入循环之前通过<strong>内存数据结构</strong>（如 <strong>map</strong>），将原先循环中 <code>GetOptionsByQuestionID</code> 和 <code>GetOptionByQIDAndAnswer</code> 的结果一次性加载到内存中，避免对 Redis 或 MySQL 的<strong>大量请求</strong>以及造成的<strong>不必要开销</strong>。</p><p>优化后的代码如下（部分）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSurveyStatistics</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    questionMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]models.Question)</span><br><span class="line">    optionsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]![]models.Option)</span><br><span class="line">    optionAnswerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">string</span>]models.Option)</span><br><span class="line">    optionSerialNumMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]models.Option)</span><br><span class="line">    <span class="keyword">for</span> _, question := <span class="keyword">range</span> questions &#123;</span><br><span class="line">        questionMap[question.ID] = question</span><br><span class="line">        optionAnswerMap[question.ID] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]models.Option)</span><br><span class="line">        optionSerialNumMap[question.ID] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]models.Option)</span><br><span class="line">        options, err := service.GetOptionsByQuestionID(question.ID)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.Error(&amp;gin.Error&#123;Err: errors.New(<span class="string">&quot;获取选项信息失败原因: &quot;</span> + err.Error()), Type: gin.ErrorTypeAny&#125;)</span><br><span class="line">            utils.JsonErrorResponse(c, code.ServerError)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        optionsMap[question.ID] = options</span><br><span class="line">        <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">            optionAnswerMap[question.ID][option.Content] = option</span><br><span class="line">            optionSerialNumMap[question.ID][option.SerialNum] = option</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    optionCounts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, sheet := <span class="keyword">range</span> answersheets &#123;</span><br><span class="line">        <span class="keyword">for</span> _, answer := <span class="keyword">range</span> sheet.Answers &#123;</span><br><span class="line">            options := optionsMap[answer.QuestionID]</span><br><span class="line">            question := questionMap[answer.QuestionID]</span><br><span class="line">            <span class="comment">// 初始化选项统计（确保每个选项的计数存在且为 0）</span></span><br><span class="line">            <span class="keyword">if</span> _, initialized := optionCounts[question.ID]; !initialized &#123;</span><br><span class="line">                counts := ensureMap(optionCounts, question.ID)</span><br><span class="line">                <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">                    counts[option.SerialNum] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> question.QuestionType == <span class="number">1</span> || question.QuestionType == <span class="number">2</span> &#123;</span><br><span class="line">                answerOptions := strings.Split(answer.Content, <span class="string">&quot;┋&quot;</span>)</span><br><span class="line">                questionOptions := optionAnswerMap[answer.QuestionID]</span><br><span class="line">                <span class="keyword">for</span> _, answerOption := <span class="keyword">range</span> answerOptions &#123;</span><br><span class="line">                    <span class="comment">// 查找选项</span></span><br><span class="line">                    <span class="keyword">if</span> questionOptions != <span class="literal">nil</span> &#123;</span><br><span class="line">                        option, exists := questionOptions[answerOption]</span><br><span class="line">                        <span class="keyword">if</span> exists &#123;</span><br><span class="line">                            <span class="comment">// 如果找到选项，处理逻辑</span></span><br><span class="line">                            ensureMap(optionCounts, answer.QuestionID)[option.SerialNum]++</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果选项不存在，处理为 &quot;其他&quot; 选项</span></span><br><span class="line">                    ensureMap(optionCounts, answer.QuestionID)[<span class="number">0</span>]++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, key <span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> m[key] == <span class="literal">nil</span> &#123;</span><br><span class="line">        m[key] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合初步优化，原先循环中<strong>对 MySQL 的大量查询 SQL</strong>已经优化为 <strong>1 次对 Redis 的查询</strong>（即问题选项的查询，此处十佳的问题只有一个），且不随投票人数增长。</p><p><strong>12.12 00:00</strong> 更新生产环境，此次优化后的情况如下：</p><ul><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/14.webp"></li><li>CPU 回归<strong>正常水平</strong>，无较大波动</li><li><strong>接口响应时间</strong>降低至 <strong>20ms</strong> 左右</li><li><img src="https://img.lonesome.cn/blog/record/vote-system-exception/15.webp"></li></ul><h3 id="后续优化方案"><a href="#后续优化方案" class="headerlink" title="后续优化方案"></a>后续优化方案</h3><p>虽然问题目前已经解决，但是在事后的<strong>复盘</strong>和讨论当中，认为原处理方案依旧有些<strong>繁琐和暴力</strong>，也不够优雅，不过在某种意义上也秉持了<strong>先上线后优化</strong>的原则。</p><ul><li>后续优化方案<ul><li>在用户投票完将答卷记录在 <strong>MongoDB</strong> 上后（由于问卷题目和题型的自定义特性，采用<strong>文档数据库</strong>存储答卷信息），<strong>在 Redis 中同步记录各个选项的票数</strong>，但需要保证操作的<strong>原子性</strong></li></ul></li><li>如何获取投票数据<ul><li>直接从 <strong>Redis</strong> 中读取，无须再次统计</li></ul></li><li>优点<ul><li>可以避免从 MongoDB 中<strong>获取所有投票答卷的开销</strong></li><li>可以直接优化掉原方案中统计所需要的 <strong>O(N^3) 循环</strong></li><li>对于<strong>大量</strong>投票答卷数据依旧能做到<strong>快速响应</strong></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>补一张当天服务器 <strong>CPU 利用率</strong>的监控数据：<br><img src="https://img.lonesome.cn/blog/record/vote-system-exception/2-3.webp"></p><p>虽然没有出现系统崩溃的情况，但依然可以算是一次不小的<strong>生产事故</strong>，事后当晚专门拉了<del>批斗会</del>复盘会，这边就以<strong>后端负责同学</strong>的反思作为本次事故的总结：</p><ul><li>代码质量<ul><li>复用代码时缺乏充分的审查，直接上线导致了生产事故，需遵循 <strong>代码审查规范</strong>，即使是复用代码也要彻底理解逻辑</li></ul></li><li>测试预警<ul><li>在部署前应<strong>模拟场景测试</strong>接口性能，并通过大批量数据测试发现潜在瓶颈。</li></ul></li><li>团队协作<ul><li>提前与团队沟通，充分利用同学的建议和经验来改进代码（如这次的 map 优化建议）。</li></ul></li><li>生产环境监控<ul><li>做好对应系统的安全负责人，持续关注发布后的<strong>生产环境的日志和性能指标</strong>，及时发现潜在问题。</li></ul></li><li>服务降级机制<ul><li>对于不影响核心功能的模块（如此次的获取投票数据接口），可实现<strong>服务降级</strong>处理，以保证主要功能的正常运行。</li></ul></li><li>沟通与决策<ul><li>及时在工作群暴露问题，在处理问题时需与技术总监充分沟通，明确处理方案，并且须经<strong>充分测试</strong>，确保安全无误后才投入生产环境。</li></ul></li></ul><p>最后以后端同学请了一人一杯奶茶作结。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>如果对于<strong>精弘问卷系统</strong>有问题或者建议，欢迎来提 issue。</p><ul><li><a href="https://github.com/zjutjh/JingHong-Questionnaire">问卷前端仓库</a></li><li><a href="https://github.com/zjutjh/QA-System">问卷后端仓库</a></li></ul>]]></content>
    
    
    <summary type="html">一次投票系统异常的事后复盘</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Windows Server 部署 ASP 网站</title>
    <link href="https://lonesome.cn/posts/windows-server-deploy-asp-website/"/>
    <id>https://lonesome.cn/posts/windows-server-deploy-asp-website/</id>
    <published>2024-08-18T13:38:11.000Z</published>
    <updated>2024-10-05T08:58:17.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起始"><a href="#起始" class="headerlink" title="起始"></a>起始</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>刚接手某个<del>坑位</del>组织的技术总监位置，在短学期工训的时候被指导老师拉进了某个群聊，告知学校的旧心理测评平台需要重新启用，至于为什么和我有关，是因为这个旧服务借挂在组织的内网服务器上，作为当代的技术总监，自然就被捎带上了，不过具体情况我还不清楚，好在看了眼群里还有前两代技术总监在压阵。<br>这里简单提一下服务器的情况，组织在内网有 2 台 PVE 的服务器，一台近一年有使用过（代称 1 号机），另一台目前没怎么用过（代称 2 号机），旧心理测评的服务就在 2 号机上。</p><p>这里提一下 PVE，简单讲可以类比为 VMware，下面介绍摘自维基百科。</p><blockquote><p>Proxmox Virtual Environment（简称：Proxmox VE、PVE），是一个开源的服务器虚拟化环境 Linux 发行版。Proxmox VE 基于 Debian，使用基于 Ubuntu 的定制内核，包含安装程序、网页控制台和命令行工具，并且向第三方工具提供了 REST API，在 Affero 通用公共许可证第三版下发行。Proxmox VE 支持两类虚拟化技术：基于容器的 LXC 和硬件抽象层全虚拟化的 KVM。</p></blockquote><p>工训闲暇时翻了下服务器的祖传文档，发现心理测评这个服务开的是 Windows Server 2008R2 Enterprise 的<del>清朝遗物</del>虚拟机，还贴了个已废弃的 tag，估计是没想到还有要重启的一天，除此之外就没有用的信息了。和上代技术总监沟通了下，只要上 PVE 把心理测评的虚拟机启动就行。</p><h3 id="失联的-2-号机"><a href="#失联的-2-号机" class="headerlink" title="失联的 2 号机"></a>失联的 2 号机</h3><p>PVE 通常是通过 Web 管理界面去操作虚拟机，<del>有图形化谁用命令行</del>，但是前提是 8006 的端口（Web 管理界面的访问端口）开放。由于学校内网默认只开放 80 端口，其他端口开放需要和信息办申请，因此先找相关老师去走了波流程。<br>联系完的第二天，在得到端口已经开放的答复后，2 号机的管理界面却依旧访问不了，原以为是开放出了岔子，但是发现 1 号机的管理界面能正常访问。于是排查了一下得出结论，端口开放了，2 号机出问题了。<br>2 号机有问题其实早有预兆 ，实际上在我刚接手服务器的时候就没连上过 2 号机，根本 ping 不通，我以为是文档有问题或者是哪里加了限制，但是 1 号机的访问正常，且 2 号机并未在使用也就没有多深究。如今看来，是在接手前 2 号机就失联了。<br>不确定 2 号机是被关了还是没跑起来，于是又联系了上代总监。</p><div class="tag-plugin image"><div class="image-bg" style="padding:16px;"><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/1.webp" style="width:300px;"/></div></div><!-- ![](https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/1.webp) --><p>由于服务器在另一个校区，只能先联系信息办的老师去排查了。</p><h3 id="上不去的-1-号机"><a href="#上不去的-1-号机" class="headerlink" title="上不去的 1 号机"></a>上不去的 1 号机</h3><p>然而祸不单行，当我想上 1 号机的管理界面去看看时，根据文档里记录的账密却怎么也登不上去，<del>你这文档保熟吗</del>。于是又又联系了上代总监。</p><div class="tag-plugin image"><div class="image-bg" style="padding:16px;"><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/2.webp" style="width:300px;"/></div></div><!-- ![](https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/2.webp) --><p>得出的结果为 1 号机和 2 号机做了集群，于是 2 号机挂了顺带踢了一脚 1 号机，又导致 1 号机登不上了，于是现在都堵在 2 号机了，只能先等待信息办的回复了。</p><h3 id="失联的-1-号机"><a href="#失联的-1-号机" class="headerlink" title="失联的 1 号机"></a>失联的 1 号机</h3><p>信息办去完现场后给了一个返图。</p><div class="tag-plugin image"><div class="image-bg" style="padding:16px;"><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/3.webp" style="width:300px;"/></div></div><!-- ![](https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/3.webp) --><p>坏了两个硬盘，然后他们说把 2 号机强行启动了。<br>但是不出意外的话，又要出意外了，2 号机还是失联，而且这次 1 号机也一起失联了，两台一起寄了，具体故障原因未知。更寄的是组织的一部分服务还挂在 1 号机的虚拟机上，不出意外的，服务也歇菜了。<br>原本不急的，因为旧心理测评的服务和我们组织实质的关系不大，现在不得不急了。不过庆幸的是还值暑假，服务并没有多少流量，临时将服务切回公网的服务器也算没造成太大影响。那么接下来就是得想办法去抢救一下这两哥哥弟弟了。</p><h3 id="抢救服务器"><a href="#抢救服务器" class="headerlink" title="抢救服务器"></a>抢救服务器</h3><p>由于只玩过云服务器，对于线下的物理服务器一窍不通，只好联系前前前···总监出手了，约了时间一起去现场看服务器，中途顶着大太阳去找垃圾佬整了几块硬盘，然后开始抢救服务器。<br>初期判断 2 号机组的是 raid10，损坏的两个都是备份盘，理论上的数据没有丢失，可以尝试更换硬盘进行重建，于是乎半场准备开香槟了，一块换了后正常重建了，但是另一块换了好几块硬盘依旧是 Failed，继续排查了两三个小时，最后赶在机房工作人员下班前得出了结论，那块的硬盘盒读写有问题，导致了无法重建。<br>由于到了点且手头没有多的硬盘盒于是只能先行撤退，但并非无功而返，重启了几次后的 2 号机能够连上了，且 1 号机也恢复了正常，同时管理界面也都能正常访问且登录了，但可惜的是心理测评服务所在的虚拟器由于硬盘问题无法启动。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/4.webp"><br>走前给群里发了个反馈，这事就暂时停滞了，等着后面再来抢修。</p><div class="tag-plugin image"><div class="image-bg" style="padding:16px;"><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/5.webp" style="width:300px;"/></div></div><!-- ![](https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/5.webp) --><h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><p>其实在准备去抢救服务器的前两天，相关老师发过一个 21 年的网站备份数据。</p><div class="tag-plugin image"><div class="image-bg" style="padding:16px;"><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/6.webp" style="width:300px;"/></div></div><!-- ![](https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/6.webp) --><p>我姑且进去扫了一眼目录。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/7.webp"><br>但是没有什么印象，也不知道是什么网站数据的备份，问了上代总监也没什么头绪，于是也没有在意，等着后面先去抢救服务器。<br>但是服务器没有完全抢救成功，心理测评的服务还是没有恢复，于是心血来潮我又打算研究一下这个备份文件，然后被我在 wwwroot 下翻到了一个安装说明.txt。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/8.webp"><br>这下事件开始迎来了转机，补首诗在此。</p><div class="tag-plugin poetry"><div class="content"><div class="title">游山西村</div><div class="meta"><span>陆游</span></div><div class="body"><p>莫笑农家腊酒浑，丰年留客足鸡豚。<br><strong>山重水复疑无路，柳暗花明又一村。</strong><br>箫鼓追随春社近，衣冠简朴古风存。<br>从今若许闲乘月，拄杖无时夜叩门。</p></div><div class="footer">诗词节选</div></div></div><p>根据说明基本得知是 Windows Server 上部署的一个 ASP 项目，事后回来看，前面的目录就是 ISS 网站的目录，果然还是阅历尚浅了，平常 linux 服务器用的多，栽在 windows 服务器上了。<br>所以接下来的数据恢复实质上就是重新将服务在 Windows Server 上跑起来，但是能否恢复还是未知数，得看数据库的数据是否有备份，下面简单记录下折腾了半天的部署过程。</p><h2 id="ASP-网站部署"><a href="#ASP-网站部署" class="headerlink" title="ASP 网站部署"></a>ASP 网站部署</h2><p>由于打算先在本地尝试恢复，因此使用 VMware 演示，Windows Server 的版本没有选择 2008 的老古董，直接上了最新版的 2022，测试下来的流程基本相同。</p><h3 id="1-安装-IIS-服务"><a href="#1-安装-IIS-服务" class="headerlink" title="1.安装 IIS 服务"></a>1.安装 IIS 服务</h3><p>首先打开<strong>服务器管理器</strong>，一般启动时会自动打开。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/9.webp"><br>打开后的<strong>服务器管理器</strong>页面如下所示，点击<strong>添加角色和功能</strong>，之后一直点击下一步。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/10.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/11.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/12.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/13.webp"><br>选择<strong>服务器角色</strong>时添加**Web 服务器(IIS)**，添加完后继续下一步。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/14.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/15.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/16.webp"></p><p><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/17.webp"></p><p><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/18.webp"><br>选择<strong>角色服务</strong>时添加<strong>应用程序开发</strong>下的<strong>ASP</strong>，会同时添加<strong>ISAPI 扩展</strong>，添加完后继续下一步<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/19.webp"></p><p><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/20.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/21.webp"><br>确认选择无误后安装<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/22.webp"><br>等待进度条跑完后点击关闭即可，到此 ISS 服务就安装完成了。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/23.webp"><br>打开浏览器输入 127.0.0.1，出现下图就说明安装成功了。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/24.webp"><br>另外此时打开资源管理器，可以看到熟悉的 inethub 目录。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/25.webp"><br>这里的目录是安装完 ISS 服务默认创建的，对应<code>/inethub/wwwroot</code>存放的就是项目文件夹，后文的<strong>Default Web Site</strong>的内容就在此处，可以选择在该目录直接部署，备份文件中的部署方式应该就是直接覆盖了默认网站的内容，不过后续演示采用添加新网站的方式。</p><h3 id="2-添加网站"><a href="#2-添加网站" class="headerlink" title="2.添加网站"></a>2.添加网站</h3><p>回到<strong>服务器管理器</strong>页面，依次点击<strong>工具</strong>-&gt;<strong>Internet Information Services (IIS)管理器</strong>。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/26.webp"><br>展开左侧目录后可以看到网站下有一个<strong>Default Web Site</strong>，绑定监听的是<strong>*:80</strong>，即刚才访问<strong>127.0.0.1</strong>所看到的页面，然后右键<strong>网站</strong>-&gt;<strong>添加网站</strong>。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/27.webp"><br>填写<strong>网站名称</strong>，<strong>物理路径</strong>和<strong>IP 地址</strong>后点击确定。</p><ul><li>网站名称自取</li><li>物理路径即 ASP 项目的路径，即备份文件中<code>/inethup/wwwroot</code>文件夹的内容，这里我重命名为了 xlcp</li><li>IP 地址点击下拉框选择即可，默认是本机的 ip 地址<ul><li>注：<strong>全部未分配</strong>即*已经分配给了<strong>Default Web Site</strong></li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/28.webp"></p><h3 id="3-设置网站目录权限"><a href="#3-设置网站目录权限" class="headerlink" title="3.设置网站目录权限"></a>3.设置网站目录权限</h3><p>如果不编辑权限直接访问 192.168.108.136（上文的 IP 地址），会显示如下页面并提示权限不足，因此需要先设置权限。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/29.webp"><br>回到<strong>IIS 管理器</strong>，右键<strong>xlcp</strong>-&gt;<strong>编辑权限</strong><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/30.webp"><br>依次点击<strong>安全</strong>-&gt;<strong>编辑</strong>-&gt;<strong>添加</strong>-&gt;<strong>高级</strong><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/31.webp"><br>点击<strong>立即查找</strong>，在<strong>搜索结果</strong>中找到并选择<strong>Everyone</strong>后确定。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/32.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/33.webp"><br>给<strong>Everyone</strong>添加<strong>完全控制</strong>权限后一路确定回去。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/34.webp"></p><h3 id="4-配置-ASP-应用程序属性"><a href="#4-配置-ASP-应用程序属性" class="headerlink" title="4.配置 ASP 应用程序属性"></a>4.配置 ASP 应用程序属性</h3><p>点击<strong>xlcp</strong>-&gt;<strong>ASP</strong>，将<strong>启动父路径</strong>修改为<strong>True</strong>后应用。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/35.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/36.webp"></p><h3 id="5-设置默认文档"><a href="#5-设置默认文档" class="headerlink" title="5.设置默认文档"></a>5.设置默认文档</h3><p>点击<strong>xlcp</strong>-&gt;<strong>默认文档</strong>，将<strong>index.asp</strong>移动至最上方。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/37.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/38.webp"></p><h3 id="6-配置应用程序池"><a href="#6-配置应用程序池" class="headerlink" title="6.配置应用程序池"></a>6.配置应用程序池</h3><p>依次点击<strong>应用程序池</strong>-&gt;<strong>xlcp</strong>（添加网站时自动创建）-&gt;<strong>高级设置</strong>，将<strong>启用 32 位应用程序</strong>修改为<strong>True</strong>后确定。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/39.webp"><br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/40.webp"></p><h3 id="7-配置数据库"><a href="#7-配置数据库" class="headerlink" title="7.配置数据库"></a>7.配置数据库</h3><p>如果没有其他环境依赖的项目在上一步就可以正常运行了，但是心理测评还有一个数据库需要处理，不处理直接访问会出现下面的错误。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/41.webp"><br>原先我较为担心的是使用 MySQL 或者 SQL Server 数据库，没有带着数据库内容一起备份，导致即使服务重新跑起来也没用，因为实际上要的是旧心理测评平台里的老数据。<br>但是翻了下 db 目录后放心了，是 Access 数据库，数据都存在 mdb 文件里了，看时间基本是备份时的数据都在了。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/42.webp"><br>在项目文件夹里找到了 global.asa 的配置文件，看了眼只需要将 Data Source 的路径修改为当前 mdb 文件所在的路径即可。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/43.webp"><br>重新访问页面，可以看到已经正常运行了。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/44.webp"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在本地 VMware 上成功部署恢复后，后续就是在 PVE 2 号机上重新部署一遍了，于是又申请开放了几天的端口进行操作。<br>在本地部署踩了一遍坑后，PVE 上又踩了一波新的坑，因为坑太多所以懒得再一一记录了。中途还因为换服务器的问题导致在线注册时的系统检测没过（提示系统运行环境与上次注册时不同，不能注册！），拉了心海软件的客服进群处理，<del>所以你原来能联系到客服的吗</del>。<br>最后补一张心理测评平台进去的图，<del>好像网上搜心理测评都是这个平台</del>。<br><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/45.webp"><br>最后总算是结束了这个坑。</p><div class="tag-plugin image"><div class="image-bg" style="padding:16px;"><img src="https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/46.webp" style="width:300px;"/></div></div><!-- ![](https://img.lonesome.cn/blog/record/windows-server-deploy-asp-website/46.webp) --><p>然后补一个梳理时间线罢。</p><div class="tag-plugin timeline"><div class="timenode" index="0"><div class="header">day1</div><div class="body fs14"><p>被拉入群聊，告知需要重启旧心理测评平台</p></div></div><div class="timenode" index="1"><div class="header">day2</div><div class="body fs14"><p>联系信息办开放 PVE Web 管理界面的访问端口</p></div></div><div class="timenode" index="2"><div class="header">day3</div><div class="body fs14"><p>端口开放，发现 2 号机失联，1 号机管理界面无法登录，联系信息办先排查线下物理机</p></div></div><div class="timenode" index="3"><div class="header">day4</div><div class="body fs14"><p>信息办反馈 2 号机坏了 2 个硬盘，强制重启了 2 号机，结果带着 1 号机一起失联</p></div></div><div class="timenode" index="4"><div class="header">day5</div><div class="body fs14"><p>相关老师发送了原心理测评网站的备份文件</p></div></div><div class="timenode" index="5"><div class="header">day6</div><div class="body fs14"><p>和前辈去线下抢救服务器，1 号机和 2 号机恢复连接</p></div></div><div class="timenode" index="6"><div class="header">day12</div><div class="body fs14"><p>根据备份文件在本地 VMware 尝试恢复成功，联系信息办再次开放端口</p></div></div><div class="timenode" index="7"><div class="header">day13</div><div class="body fs14"><p>端口开放，开始在 1 号机上尝试恢复</p></div></div><div class="timenode" index="8"><div class="header">day14</div><div class="body fs14"><p>1 号机上恢复成功，联系心海客服处理注册问题</p></div></div><div class="timenode" index="9"><div class="header">day15</div><div class="body fs14"><p>和心海客服联系处理完毕，可以正常使用，下班</p></div></div></div>]]></content>
    
    
    <summary type="html">关于学校旧心理测评平台数据恢复历程的记录，本质上来说就是 Windows Server 部署 ASP 网站
</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Windows Server" scheme="https://lonesome.cn/tags/Windows-Server/"/>
    
    <category term="ASP" scheme="https://lonesome.cn/tags/ASP/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 Redis</title>
    <link href="https://lonesome.cn/posts/docker-install-redis/"/>
    <id>https://lonesome.cn/posts/docker-install-redis/</id>
    <published>2023-12-01T05:08:31.000Z</published>
    <updated>2024-10-04T19:08:04.788Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先需要安装好 Docker，可以参考<a href="/posts/ubuntu-install-docker/">Ubuntu 安装 Docker</a><ul><li>使用 Docker 需要 root 权限，推荐将用户加入 Docker 用户组（上文中有），这样使用就不需要加上<code>sudo</code>了（<del>但是我是 root，所以文中都没加</del>）</li></ul></li><li>Docker Hub 中的 Redis 官方镜像文档 <a href="https://hub.docker.com/_/redis">redis - Official Image | Docker Hub</a></li></ul><h2 id="1-寻找镜像"><a href="#1-寻找镜像" class="headerlink" title="1.寻找镜像"></a>1.寻找镜像</h2><p>在 Docker 仓库中查找 Redis 镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/0N1GWUN7S0A2FMOY.webp"><br>可以看到第一个就是我们需要的镜像</p><h2 id="2-拉取镜像"><a href="#2-拉取镜像" class="headerlink" title="2.拉取镜像"></a>2.拉取镜像</h2><p>在查找到 Redis 的镜像后，就可以进行拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/22D20QR093N6MFN.webp"><br>因为没有指定 Redis 的版本，所以默认拉取最新的版本（即 latest）<br>如果想要拉取指定的版本，可以在拉取时添加版本号（<code>redis:tag</code>），以 Redis 7.2.3 版本为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:7.2.3</span><br></pre></td></tr></table></figure><h2 id="3-查看镜像"><a href="#3-查看镜像" class="headerlink" title="3.查看镜像"></a>3.查看镜像</h2><p>拉取完毕后，检查镜像是否安装完成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看所有镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/3MUEAB1MG9ZX66B.webp"><br>可以看到已经有 Redis 的镜像了</p><h2 id="4-创建容器并启动"><a href="#4-创建容器并启动" class="headerlink" title="4.创建容器并启动"></a>4.创建容器并启动</h2><p>通过 Docker 安装 Redis 和直接安装 Redis 的一处不同在于通过 Docker 创建的 Redis 容器中是没有<code>redis.conf</code>配置文件的<br>Redis 可以在没有配置文件的情况下使用内置的默认配置启动，但是这种方法只建议在测试和开发的时候使用，当然 Redis 官方也给我们提供了使用配置文件启动 Redis 容器的方法，因此下面介绍两种方法</p><h3 id="一、无配置文件简易版"><a href="#一、无配置文件简易版" class="headerlink" title="一、无配置文件简易版"></a>一、无配置文件简易版</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器名称、端口、密码均可自行指定</span></span><br><span class="line">docker run \</span><br><span class="line">  --name redis \</span><br><span class="line">  -p 6379:6379 \</span><br><span class="line">  -- requirepass 123456 \</span><br><span class="line">  -d \</span><br><span class="line">  redis</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>--name redis</code>：指定容器的名称为 redis（可以自己指定）</li><li><code>-p 6379:6379</code>：将容器的 6379（右边的）端口映射到宿主机的 6379（左边的）端口（前提是不被占用）</li><li><code>-- requirepass 123456</code>：设置密码为 123456<ul><li>如果不想设置密码可以不使用该参数，但是需要注意为了便于容器外能够访问到该容器内的 Redis，其<code>protected mode</code>（保护模式）默认关闭，这意味着如果你将端口暴露在主机外部，它将在没有密码的情况下对所有人开放</li></ul></li><li><code>-d</code>：以后台的方式运行</li><li><code>redis:tag</code>：指定创建容器的镜像（<code>:tag</code>指定版本，不加默认最新版）<ul><li>建议创建容器时使用<code>:tag</code>指定版本，可以使用<code>docker images</code>查看镜像的版本，以免过段时间版本更新后导致现在拉取的镜像已经不是最新版本，又重新拉取一个最新版本的镜像进行容器创建</li></ul></li></ul><p>执行后返回的一长串是容器 id</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>该方式创建的容器适合在测试环境使用，简单方便，但是没法通过配置文件去自定义一些配置，而且数据容易丢失，一旦关机或者容器挂了数据就没了，因为是存在缓存里的</p><h3 id="二、-配置文件挂载版"><a href="#二、-配置文件挂载版" class="headerlink" title="二、 配置文件挂载版"></a>二、 配置文件挂载版</h3><h4 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h4><p>先准备一个目录用于存放配置文件（用于后面创建容器时挂载配置），目录可以自己选择，通常选择放在用户的主目录下的一个子目录中，好处是每个用户都有自己的挂载目录，可以隔离不同用户的数据<br>但是因为我的云服务器只有我一个人在玩，平常都是直接用的 root 用户，所以直接在根目录下创建了一个<code>/data</code>目录用来存放 Docker 容器的挂载配置和数据，因此我这边准备的目录在<code>/data/redis/</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用于 Redis 容器配置文件挂载的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /data/redis/conf</span><br></pre></td></tr></table></figure><p>然后提前在该目录下新建一个<code>redis.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建 redis.conf 文件</span></span><br><span class="line"><span class="built_in">touch</span> /data/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>创建完配置文件后，直接去 Redis 的官网找对应版本的配置文件 <a href="https://redis.io/docs/management/config/">Redis configuration | Redis</a><br><img src="https://img.lonesome.cn/blog/record/Z458FP7J73FSLAUMY6.webp"><br>往下滑可以找到各个不同版本的配置文件<br>因为我拉取的是最新版本的镜像，所以这边选择第一个 7.2 版本（最新版本），根据拉取 Redis 的实际版本选择即可<br>点进去后就可以看到配置文件的内容，本文就不具体介绍了，可以自行了解<br><img src="https://img.lonesome.cn/blog/record/X6OHG8ONB4D5.webp"><br>直接<code>ctrl+a</code> + <code>ctrl+c</code>复制，然后用 vim 打开我们之前准备好的<code>redis.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式，<code>ctrl+v</code>粘贴，然后别急着保存退出，还需要修改一些配置</p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>修改配置主要是为了能在宿主机访问容器中的 Redis，因为配置文件中的<code>protected-mode</code>（保护模式）设置是开启的</p><ul><li>保护模式：如果符合下面两个条件（不是之一）则无法被外部访问<ol><li>没有明确使用 bind 绑定某个 ip 地址</li><li>没有设置密码</li></ol></li></ul><h5 id="取消本地绑定-绑定某个-ip-地址"><a href="#取消本地绑定-绑定某个-ip-地址" class="headerlink" title="取消本地绑定&#x2F;绑定某个 ip 地址"></a>取消本地绑定&#x2F;绑定某个 ip 地址</h5><p>定位到<code>bind 127.0.0.1 -::1</code>，将其注释<br><img src="https://img.lonesome.cn/blog/record/LQB00UBHFTPPQT.webp"><br><code>bind 127.0.0.1 -::1</code>的意思是限制只能本地访问（即只有该容器内部才可以访问，容器外的宿主机也访问不了），注释掉表示允许所有 ip 访问<br>当然也可以选择绑定指定 ip 允许其访问</p><h5 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h5><p>定位到<code>## requirepass foobared</code>，取消其注释，并将<code>foobared</code>修改为你想设置的密码<br><img src="https://img.lonesome.cn/blog/record/2Y7GCDARZGA8Q.webp"><br>比如我这边就将密码设置为了<code>123456</code><br>如果不想设置密码还想被外部宿主机访问，那就需要另外定位到<code>protected-mode yes</code>，将参数修改为<code>no</code>（解除保护模式的限制）</p><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 默认 no，表示不以守护进程启动，Docker 部署不需要改为 yes，因为 docker run -d 本身就是后台启动</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line">## 开启持久化，根据需求选择是否开启，会将数据持久化到容器中的 /data 目录</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>更多其他配置根据自己需求修改，本文不多介绍</p><h4 id="以配置文件方式创建容器并启动"><a href="#以配置文件方式创建容器并启动" class="headerlink" title="以配置文件方式创建容器并启动"></a>以配置文件方式创建容器并启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器名称、端口、挂载目录均可自行指定</span></span><br><span class="line">docker run \</span><br><span class="line">  --name redis \</span><br><span class="line">  -p 6379:6379 \</span><br><span class="line">  -v /data/redis/conf:/usr/local/etc/redis \</span><br><span class="line">  <span class="comment"># 如果配置了 appendonly yes（持久化）可以选择挂载该目录</span></span><br><span class="line">  -v /data/redis/data:/data \</span><br><span class="line">  -d \</span><br><span class="line">  redis \</span><br><span class="line">  redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>简易版的参数就不再介绍了，说明一下新参数：</p><ul><li><code>-v</code>：数据卷挂载<ul><li><code>/data/redis/conf:/usr/local/etc/redis</code>：将容器中<code>/usr/local/etc/redis</code>目录挂载到宿主机的<code>/data/redis/conf</code>目录<ul><li><code>/data/redis/conf</code>目录即之前准备的存放<code>redis.conf</code>文件的目录，这里可以理解为 Docker 容器和宿主机共享该配置文件</li></ul></li><li><code>/data/redis/data:/data</code>：将容器中<code>/data</code>数据目录挂载到宿主机的<code>/data/redis/data</code>目录<ul><li>如果开启了持久化，进行挂载可以避免持久化的数据丢失，如果不挂载的话在删除容器后会丢失该容器中持久化的数据，即<strong>挂载后即使容器删除，只要宿主机目录中的数据还存在，使用该目录新创建的容器中依旧有原先容器中挂载的数据</strong></li><li>如果没有开启持久化也就不需要挂载<code>\data</code>数据目录了，因为 Redis 的数据都存在缓存里，不开启持久化也不会在该目录下存储数据</li><li>宿主机用于挂载的目录（比如我这边的<code>/data/redis/data</code>）可以自行选择，一般就放在配置目录旁边</li></ul></li></ul></li><li><code>redis-server /usr/local/etc/redis/redis.conf</code>：以配置文件启动容器，加载容器内的<code>redis.conf</code>文件，实际找到的是挂载在宿主机中配置目录下的<code>reids.conf</code></li></ul><p><img src="https://img.lonesome.cn/blog/record/6B2FV6HFAVVBI.webp"><br>返回的一长串是创建的容器 id</p><h2 id="6-查看容器"><a href="#6-查看容器" class="headerlink" title="6.查看容器"></a>6.查看容器</h2><p>检查容器是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/DBVQBAM5ZQCT1NSFFQ.webp"><br>可以看到创建的 Redis 容器已经在运行中了<br>我们可以通过 Docker 命令进入 Redis 容器内部</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 redis 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用容器 id（即上图中的 CONTANINER ID）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 7cd1552e2cf5 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/CML92T2X8JX0F.webp"><br>进入后就可以和在 linux 中一样使用 Redis 了<br>输入<code>redis-cli -a 123456</code>即可进入 Redis 命令行，<code>-a</code>后面的参数是你设置的密码<br><img src="https://img.lonesome.cn/blog/record/5ETPMRGIYCVMO1E.webp"><br>后续使用和正常 Redis 一样，想要退出 Redis 和容器使用<code>exit</code>命令即可</p><h2 id="7-删除容器"><a href="#7-删除容器" class="headerlink" title="7.删除容器"></a>7.删除容器</h2><p>不能直接删除运行中的容器，因此需要先停止容器再删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 redis 是创建容器时自行指定的容器名称</span></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop redis</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> redis</span><br></pre></td></tr></table></figure><p>但是可以加上<code>-f</code>参数来强制删除运行中的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 redis 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">rm</span> -f redis</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker 安装 Redis 记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Redis" scheme="https://lonesome.cn/tags/Redis/"/>
    
    <category term="Docker" scheme="https://lonesome.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 MySQL</title>
    <link href="https://lonesome.cn/posts/docker-install-mysql/"/>
    <id>https://lonesome.cn/posts/docker-install-mysql/</id>
    <published>2023-11-29T13:22:43.000Z</published>
    <updated>2024-10-04T19:08:02.502Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先需要安装好 Docker，可以参考<a href="/posts/ubuntu-install-docker/">Ubuntu 安装 Docker</a><ul><li>使用 Docker 需要 root 权限，推荐将用户加入 Docker 用户组（上文中有），这样使用就不需要加上<code>sudo</code>了（<del>但是我是 root，所以文中都没加</del>）</li></ul></li><li>Docker Hub 中的 MySQL 官方镜像文档 <a href="https://hub.docker.com/_/mysql">mysql - Official Image | Docker Hub</a></li></ul><h2 id="1-寻找镜像"><a href="#1-寻找镜像" class="headerlink" title="1.寻找镜像"></a>1.寻找镜像</h2><p>在 Docker 仓库中查找 MySQL 镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/NQFHOZC2A6I0WCPBT.webp"><br>可以看到第一个就是我们需要的镜像</p><h2 id="2-拉取镜像"><a href="#2-拉取镜像" class="headerlink" title="2.拉取镜像"></a>2.拉取镜像</h2><p>在查找到 MySQL 的镜像后，就可以进行拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/G4016RJ0I0C39T6SPHF.webp"><br>因为没有指定 MySQL 的版本，所以默认拉取最新的版本（即 latest）<br>如果想要拉取指定的版本，可以在拉取时添加版本号（<code>mysql:tag</code>），以 MySQL 5.7 版本为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="3-查看镜像"><a href="#3-查看镜像" class="headerlink" title="3.查看镜像"></a>3.查看镜像</h2><p>拉取完毕后，检查镜像是否安装完成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/4Z5AEPZEIYZHSED3Z4.webp"><br>可以看到已经有 MySQL 的镜像了（hello-world 是我在安装完 Docker 测试时拉取的镜像）</p><h2 id="4-创建容器并启动"><a href="#4-创建容器并启动" class="headerlink" title="4.创建容器并启动"></a>4.创建容器并启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器名称、端口、挂载目录、root 密码均可自行指定</span></span><br><span class="line">docker run \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -v /data/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /data/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /data/mysql/log:/var/log/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  -d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>--name mysql</code>：指定容器的名称为 mysql（可以自己指定）</li><li><code>-p 3306:3306</code>：将容器的 3306（右边的）端口挂载到宿主机的 3306（左边的）端口（前提是不被占用）</li><li><code>-v</code>：将相关目录挂载到宿主机防止数据丢失，如果不挂载的话在删除容器后会丢失存储的数据，即<strong>挂载后即使容器删除，只要宿主机目录中的数据还存在，使用该目录新创建的容器中依旧有原先容器中挂载的数据</strong><ul><li>注：<ul><li><strong>实际宿主机中用于挂载的目录根据自己需求设置，如果只是开发测试环境可以选择不挂载（<del>用完就删不留痕迹，正合我意</del>），但是配置目录还是推荐挂载，方便修改配置</strong></li><li>挂载目录通常选择放在用户的主目录下的一个子目录中，好处是每个用户都有自己的挂载目录，可以隔离不同用户的数据，但是因为我的云服务器只有我一个人在玩，平常都是直接用的 root 用户，所以直接在根目录下创建了一个<code>/data</code>目录用来存放 Docker 容器的挂载配置和数据，MySQL 容器的就都挂载在<code>/data/mysql</code>目录下了</li></ul></li><li><code>/data/mysql/conf:/etc/mysql/conf.d</code>：将容器中<code>/etc/mysql/conf.d</code>配置目录挂载到宿主机的<code>/data/mysql/conf</code>目录<ul><li><strong>想要修改 MySQL 配置可以直接在宿主机的配置目录下添加一份自定义的<code>my.cnf</code>配置文件，该文件中的配置优先级高于 MySQL 的默认配置（容器中 MySQL 的配置文件路径位于<code>/etc/my.cnf）</code></strong></li><li><strong>也可以提前编辑好<code>my.cnf</code>文件，创建的容器会按你挂载目录中的自定义配置启动</strong></li></ul></li><li><code>/data/mysql/data:/var/lib/mysql</code>：将容器中<code>/var/lib/mysql</code>数据目录挂载到宿主机的<code>/data/mysql/data</code>目录</li><li><code>/data/mysql/log:/var/log/mysql</code>：将容器中<code>/var/log/mysql</code>日志目录挂载到宿主机的<code>/data/mysql/log</code>目录</li></ul></li><li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：初始化 MySQL root 用户的密码为 123456</li><li><code>-d</code>：以后台的方式运行</li><li><code>mysql:tag</code>：指定创建容器的镜像（<code>:tag</code>指定版本，不加默认最新版）<ul><li>建议创建容器时使用<code>:tag</code>指定版本，可以使用<code>docker images</code>查看镜像的版本，以免过段时间版本更新后导致现在拉取的镜像已经不是最新版本，又重新拉取一个最新版本的镜像进行容器创建</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/record/SC3AVHM4I293CD3J3.webp"><br>返回的一长串是创建的容器 id</p><h2 id="5-查看容器"><a href="#5-查看容器" class="headerlink" title="5.查看容器"></a>5.查看容器</h2><p>检查容器是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看运行中的容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/7T8FG5HKRT1H67A5.webp"><br>可以看到创建的 MySQL 容器已经在运行中了<br>我们可以通过 Docker 命令进入 MySQL 容器内部</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用容器 id（即上图中的 CONTANINER ID）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 01c4a501d5c4 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/TEKF58YP3LHZNC.webp"><br>进入后就可以和在 linux 中一样使用 MySQL 了<br>查看 MySQL 版本号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/EELM6A6ZY1UK8C4KDZ7.webp"><br>注：写本文时的最新版本为 8.2.0<br>输入<code>mysql -u root -p</code>后再输入密码即可进入 MySQL 命令行<br><img src="https://img.lonesome.cn/blog/record/0GHC27658X48D5XLLG.webp"><br>后续使用和正常 MySQL 一样，想要退出 MySQL 和容器使用<code>exit</code>命令即可</p><h2 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6.删除容器"></a>6.删除容器</h2><p>不能直接删除运行中的容器，因此需要先停止容器再删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop mysql</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> mysql</span><br></pre></td></tr></table></figure><p>但是可以加上<code>-f</code>参数来强制删除运行中的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>进入 MySQL 命令行后使用下面命令查看当前时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select now();</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/43XOZIG33DMYUBUXV.webp"><br>会发现 MySQL 中时间比系统时间少了 8 个小时，因为 MySQL 的时区并不是我们所在的东八区（即北京时间）</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="一：命令行中修改"><a href="#一：命令行中修改" class="headerlink" title="一：命令行中修改"></a>一：命令行中修改</h5><p>MySQL 中的系统时区，分为全局时区和当前会话的时区，如果当前会话不指定时区，默认使用全局时区，可以使用下面的命令将全局时区修改为东八区（即北京时间）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global time_zone = &#x27;+8.00&#x27;;</span><br><span class="line"></span><br><span class="line"># 修改当前会话的时区（相当于临时修改）</span><br><span class="line"># set time_zone = &#x27;+8.00&#x27;;</span><br></pre></td></tr></table></figure><p>如果想要立即生效需要执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>再次<code>select now();</code>查看时间会发现已经是东八区的时间了</p><h5 id="二：修改-my-cnf-配置文件"><a href="#二：修改-my-cnf-配置文件" class="headerlink" title="二：修改 my.cnf 配置文件"></a>二：修改 my.cnf 配置文件</h5><h6 id="容器中修改"><a href="#容器中修改" class="headerlink" title="容器中修改"></a>容器中修改</h6><p>可以编辑容器中 MySQL 的<code>my.cnf</code>（位于<code>/etc/my.cnf</code>）配置文件<br>然后在 [mysqld] 区域加上<code>default-time_zone = &#39;+8:00&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">......</span><br><span class="line">default-time_zone = &#x27;+8:00&#x27;</span><br><span class="line">......</span><br><span class="line">[client]</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>然后重启 MySQL<br>注：MySQL 容器中没有 vim，如果想要编辑需要先安装 vim（<del>所以我没有演示</del>）</p><h6 id="通过挂载的配置文件修改"><a href="#通过挂载的配置文件修改" class="headerlink" title="通过挂载的配置文件修改"></a>通过挂载的配置文件修改</h6><p>如果在创建容器时<em>将容器中的配置目录挂载到了宿主机</em>，那就可以直接编辑宿主机中的配置文件进行修改了<br>首先在配置目录挂载的宿主机目录下新建一个<code>my.cnf</code>文件，然后使用 vim 编辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入你自己挂载的宿主机配置目录</span></span><br><span class="line"><span class="built_in">cd</span> /data/mysql/conf</span><br><span class="line"><span class="comment"># 新建一个 my.cnf 文件</span></span><br><span class="line"><span class="built_in">touch</span> my.cnf</span><br><span class="line"><span class="comment"># 使用 vim 编辑</span></span><br><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure><p>添加下面配置内容（<del>不会还有人不会 vim 吧</del>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default-time-zone = &#x27;+08:00&#x27;</span><br></pre></td></tr></table></figure><p>保存退出后重启容器即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line"><span class="comment"># 重启 MySQL</span></span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><p>之后再次进入容器中的 MySQL，通过<code>select now();</code>查看时间会发现已经是东八区的时间了</p><p><strong>注：想要修改其他配置也可以按照相同的方法在宿主机编辑配置文件，并且只要创建容器时挂载宿主机的配置目录不变，即使删除当前容器重开一个，修改的配置也依旧在</strong></p>]]></content>
    
    
    <summary type="html">Docker 安装 MySQL 记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
    <category term="Docker" scheme="https://lonesome.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Docker</title>
    <link href="https://lonesome.cn/posts/ubuntu-install-docker/"/>
    <id>https://lonesome.cn/posts/ubuntu-install-docker/</id>
    <published>2023-11-27T17:53:55.000Z</published>
    <updated>2024-10-04T19:08:13.289Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>云服务器：阿里云（不同厂商云服务器上的操作基本相同）</li><li>系统：Ubuntu 22.04</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><p>本文不具体介绍 Docker<br>下面步骤均根据写本文时最新的<a href="https://docs.docker.com/engine/install/ubuntu/">官方文档</a></p><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>首次在新的主机上安装 Docker Engine 之前，需要先设置 Docker 的软件源，之后就可以通过软件源安装和更新 Docker</p><h4 id="1-设置-Docker-的软件源"><a href="#1-设置-Docker-的软件源" class="headerlink" title="1.设置 Docker 的软件源"></a>1.设置 Docker 的软件源</h4><p>依次执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="comment"># 安装相关依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ca-certificates curl gnupg</span><br><span class="line"><span class="comment"># 创建目录用于存放软件源的 GPG 密钥文件</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，建议使用国内源，官方源请在注释中查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加软件源的 GPG 密钥（阿里镜像源）</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 docker.gpg 的文件权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 docker 软件源添加到 apt 源（阿里镜像源）</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \</span></span><br><span class="line"><span class="comment">#   sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure><h4 id="2-安装-Docker"><a href="#2-安装-Docker" class="headerlink" title="2.安装 Docker"></a>2.安装 Docker</h4><p>执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h3 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h3><p>Docker 在 <a href="https://get.docker.com/">https://get.docker.com/</a> 提供了一个方便的脚本，可以在开发环境中非交互式地安装 Docker，不推荐在生产环境使用，但对于创建适合自己需求的配置脚本非常有用，该脚本的源代码开源在 GitHub 上的 <a href="https://github.com/docker/docker-install">docker-install 仓库</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br></pre></td></tr></table></figure><p>这个示例会从 <a href="https://get.docker.com/">https://get.docker.com/</a> 下载脚本并运行，在 Linux 上安装最新稳定版本的 Docker</p><blockquote><p>可以使用<code>--dry-run</code>选项运行脚本，以了解脚本在调用时会运行哪些步骤</p><blockquote><p>curl -fsSL <a href="https://get.docker.com/">https://get.docker.com</a> -o get-docker.sh<br>sudo sh .&#x2F;get-docker.sh –dry-run</p></blockquote></blockquote><p>如果想安装最新的预发布版本，可以通过测试通道</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh test-docker.sh</span><br></pre></td></tr></table></figure><h2 id="查看-Docker-状态"><a href="#查看-Docker-状态" class="headerlink" title="查看 Docker 状态"></a>查看 Docker 状态</h2><p>安装完成后，Docker 服务将会自动启动，可以输入下面命令查看 Docker 服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/5VPK0YXI65RDE0UQ.webp"><br>输出显示 Docker 正常运行</p><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><p>若能正常输出以下信息，则说明安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">719385e32844: Pull complete</span><br><span class="line">Digest: sha256:c79d06dfdfd3d3eb04cafd0dc2bacab0992ebc243e083cabe208bac4dd7759e0</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><h2 id="停止-Docker-服务"><a href="#停止-Docker-服务" class="headerlink" title="停止 Docker 服务"></a>停止 Docker 服务</h2><p>希望通过执行以下命令停止 Docker 服务时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure><p>会提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Stopping docker.service, but it can still be activated by:</span><br><span class="line">  docker.socket</span><br></pre></td></tr></table></figure><p>此时再次查看 Docker 状态<br><img src="https://img.lonesome.cn/blog/record/MKINO4IMJ5NSICC.webp"><br>会发现有一个<code>TriggeredBy: docker.socket</code>依旧在运行<br>实际上是 Docker 在关闭状态下被访问的自动唤醒机制，即在执行任意 Docker 命令时会自动启动<br>如果不希望 Docker 被自动唤醒，在停止 Docker 服务时应该依次执行下面两条命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker.socket</span><br><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure><p>附上启动的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><p>注：<code>docker.socket</code>也会一起跟着重启</p><h2 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h2><ol><li>卸载 Docker Engine, CLI, containerd 和 Docker Compose 软件包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br></pre></td></tr></table></figure><ol start="2"><li>主机上的镜像、容器、卷或自定义配置文件不会自动删除，因此要手动删除所有的镜像、容器和卷</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><p>以及相关编辑过的配置文件</p><h2 id="非-root-用户管理-Docker"><a href="#非-root-用户管理-Docker" class="headerlink" title="非 root 用户管理 Docker"></a>非 root 用户管理 Docker</h2><p>Docker 守护进程绑定<code>Unix socket</code>而不是 TCP 端口，默认情况下，<code>Unix socket</code>的所有者是 root 用户，其他用户想要访问只能使用 sudo，Docker 守护进程始终以 root 用户身份运行<br>出于安全考虑，一般 Linux 系统上不会直接使用 root 用户，如果希望非 root 用户能够不通过 sudo 访问，可以创建一个名为<code>docker</code>的 Unix 组，并将需要使用 Docker 的用户添加进用户组</p><h3 id="创建docker组"><a href="#创建docker组" class="headerlink" title="创建docker组"></a>创建<code>docker</code>组</h3><p>注：Ubuntu 在使用 apt 安装 Docker 时会自动创建该组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br></pre></td></tr></table></figure><h3 id="将用户添加到docker组"><a href="#将用户添加到docker组" class="headerlink" title="将用户添加到docker组"></a>将用户添加到<code>docker</code>组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 $USER 修改为你要添加的用户名</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="刷新组成员权限"><a href="#刷新组成员权限" class="headerlink" title="刷新组成员权限"></a>刷新组成员权限</h3><p>重新登陆或运行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>不使用 sudo 运行以下命令（使用添加到<code>docker</code>用户组的用户）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>正常输出以下信息，则说明添加成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>注：如果没有在<strong>测试 Docker 是否安装正确</strong>时运行过该命令，则会多出拉取镜像的信息</p><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Error loading config file: /home/user/.docker/config.json -</span><br><span class="line">stat /home/user/.docker/config.json: permission denied</span><br></pre></td></tr></table></figure><p>原因：当前用户没有加入<code>docker</code>用户组<br>解决方法：按上述流程将该用户加入用户组，并依次执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 $USER 修改为当前用户的用户名</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> <span class="string">&quot;<span class="variable">$USER</span>&quot;</span>:<span class="string">&quot;<span class="variable">$USER</span>&quot;</span> /home/<span class="string">&quot;<span class="variable">$USER</span>&quot;</span>/.docker -R</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> g+rwx <span class="string">&quot;<span class="variable">$HOME</span>/.docker&quot;</span> -R</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Ubuntu 安装 Docker 记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Docker" scheme="https://lonesome.cn/tags/Docker/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 部署 Gin+Vue 前后端分离项目</title>
    <link href="https://lonesome.cn/posts/ubuntu-deploy-gin-and-vue-project/"/>
    <id>https://lonesome.cn/posts/ubuntu-deploy-gin-and-vue-project/</id>
    <published>2023-08-31T08:33:56.000Z</published>
    <updated>2024-10-04T19:08:14.794Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04 LTS</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>如果后端服务需要服务器上的数据库，需要提前准备好<br>附上 MySQL 和 Redis 的安装配置<br><a href="/posts/ubuntu-install-mysql/">Ubuntu 安装 MySQL 并配置远程连接</a><br><a href="/posts/ubuntu-install-redis">Ubuntu 安装 Redis 并配置远程连接</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="Go-项目打包"><a href="#Go-项目打包" class="headerlink" title="Go 项目打包"></a>Go 项目打包</h4><p>Go 支持跨平台编译，因此我们可以很轻松的将当前平台的 Go 项目打包成能够在 Linux 运行的文件<br>进入到 main.go 的文件目录下，执行以下命令（打包前记得将环境或者配置修改为服务器的）</p><h5 id="Windows-系统下"><a href="#Windows-系统下" class="headerlink" title="Windows 系统下"></a>Windows 系统下</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLE=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure><p>注：在 cmd 中执行，PowerShell 中不知道为什么不起作用（编译出来还是 Windows 下的 .exe 文件）</p><h5 id="Mac-系统下"><a href="#Mac-系统下" class="headerlink" title="Mac 系统下"></a>Mac 系统下</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><h5 id="Linux-系统下"><a href="#Linux-系统下" class="headerlink" title="Linux 系统下"></a>Linux 系统下</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLE 是否开启 CGO，默认为 1 开启 CGO（不支持交叉编译），0 表示关闭</span><br><span class="line">GOARCH 表示目标平台的体系架构</span><br><span class="line">GOOS 表示目标平台的操作系统 Linux、Windows、Darwin（Mac）</span><br></pre></td></tr></table></figure><p>等待编译完成后就可以得到一个<strong>不带后缀</strong>的二进制文件，默认名为<code>main</code><br>如果想要指定输出的文件名，可以在 go build 时加上 <code>-o</code> 参数，如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o cms main.go</span><br></pre></td></tr></table></figure><p><code>cms</code>就是我指定输出的文件名，也是我本次部署使用的打包文件</p><h4 id="将打包文件上传到服务器"><a href="#将打包文件上传到服务器" class="headerlink" title="将打包文件上传到服务器"></a>将打包文件上传到服务器</h4><p>可以使用 xftp 上传打包文件至服务器，也可以使用对应云服务器厂商自带的 WebShell（我使用的是腾讯云的 OrcaTerm）<br>这边将打包好的 cms 文件上传到<code>/opt/go/cms</code>文件夹下（文件路径可以自己选择）<br><strong>注：如果有配置文件也需要一起上传</strong><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829160053.webp"></p><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>橙色方框中可以看到当前的权限是 640<br><img src="https://img.lonesome.cn/blog/record/R0KEPUI6PCRJ4HV7BUXX.webp"><br>也可以<code>cd /opt/go/cms</code>通过<code>ls -l</code>命令查看<br><img src="https://img.lonesome.cn/blog/record/ZUZGSO3470CLH071FY.webp"><br>想要运行该文件，我们至少需要拥有执行该文件的权利，执行下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 cms</span><br></pre></td></tr></table></figure><p>将执行权限赋予 root 用户（实际根据自己需求赋予不同用户组权限）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829164029.webp"><br>这时候我们其实已经可以运行了，输入<code>./cms</code>去运行我们编译好的文件<br><img src="https://img.lonesome.cn/blog/record/PLH14SNT45FW174FEOH.webp"><br>没有报错说明已经启动成功了<br>没有别的信息显示是因为部署在正式环境中，设置了<code>gin.SetMode(gin.ReleaseMode)</code>（Gin 的生产环境模式）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829174041.webp"></p><h4 id="云服务器放行端口"><a href="#云服务器放行端口" class="headerlink" title="云服务器放行端口"></a>云服务器放行端口</h4><p>想要访问后端服务，需要将服务对应运行的端口（比如我这边就是默认跑在<code>8080</code>端口）放开，不然在外部是访问不到服务器上的后端服务的<br>在云服务器厂商找到对应云服务器的防火墙，并放行 8080 端口（对应你自己后端服务的运行端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/NRFVBX4UISVNODVWBKSF.webp"><br><img src="https://img.lonesome.cn/blog/record/Z9PFY5ZLSGX0TDV8A.webp"><br>有这样一条记录就说明 8080 端口已经放行了</p><h4 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h4><p>可以通过 Apifox 测试能否正常访问<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829180656.webp"><br>可以看到能够正常访问并响应<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829180912.webp"><br>也可以看到 Gin 自己 Logger 中间件的日志</p><h4 id="使用-Systemd-守护进程"><a href="#使用-Systemd-守护进程" class="headerlink" title="使用 Systemd 守护进程"></a>使用 Systemd 守护进程</h4><p>现在我们希望我们的后端服务能在后台运行，并且不会随着我们终端的关闭而退出，这里就需要用到守护进程，守护进程是一个在后台运行并且不受任何终端控制的进程，这里我们选择使用 systemd 守护进程<br><strong>注：本文不详细讲解 systemd，建议自行查阅相关知识</strong></p><h5 id="创建-service-文件"><a href="#创建-service-文件" class="headerlink" title="创建 service 文件"></a>创建 service 文件</h5><p>先<code>CTRL+C</code>结束启动的服务回到 linux 命令行<br>在<code>/etc/systemd/system</code>路径下新建一个<code>cms.service</code>文件，文件名可以自己取，<strong>文件后缀<code>.service</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/systemd/system/cms.service</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/NL0112OBHO5LAN1.webp"></p><h5 id="编辑-service-文件"><a href="#编辑-service-文件" class="headerlink" title="编辑 service 文件"></a>编辑 service 文件</h5><p>使用 vim 打开编辑该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/cms.service</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=cms（contact manager system）backend server daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/opt/go/cms/cms</span><br><span class="line">WorkingDirectory=/opt/go/cms</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>参数解释（想要了解更多参数和配置可以参考这篇 <a href="https://blog.cnpatrickstar.com/all/systemd/">利用 Systemd 守护进程 | 派大星的石头屋</a>）</p><ul><li>Unit<ul><li><code>Description</code>：简短描述</li></ul></li><li>Service<ul><li><code>Type</code>：启动类型，<code>simple</code>表示<code>ExecStart</code>字段启动的进程为主进程</li><li><code>ExecStart</code>：启动当前服务的命令，即打包文件的具体路径</li><li><code>WorkingDirectory</code>：指定服务运行目录，即打包文件所在的文件夹</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，<code>always</code>表示总是重启</li><li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li></ul></li><li>Install<ul><li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li></ul></li></ul><p>将<code>Description</code>、<code>ExecStart</code>和<code>WorkingDirectory</code>修改为自己的即可<br>然后将修改完的代码粘贴到我们正在编辑的文件中<br><img src="https://img.lonesome.cn/blog/record/G436JSFBJZEUK89SIT.webp"><br>按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h5 id="启动-service"><a href="#启动-service" class="headerlink" title="启动 service"></a>启动 service</h5><p>输入下面命令即可启动后端服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start cms <span class="comment"># cms 对应修改为你之前创建的 service 文件名</span></span><br></pre></td></tr></table></figure><p>然后可以通过下面命令查看服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status cms <span class="comment"># cms 对应修改为你之前创建的 service 文件名</span></span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/HQKISXD165OZKZL6FBE.webp"><br><code>active (running)</code>说明服务已经成功启动，即我们的后端服务已经在后台运行了<br>附上其他相关命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop cms <span class="comment"># cms 对应修改为你之前创建的 service 文件名</span></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart cms <span class="comment"># cms 对应修改为你之前创建的 service 文件名</span></span><br><span class="line"><span class="comment"># 设置开机自启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> cms <span class="comment"># cms 对应修改为你之前创建的 service 文件名</span></span><br><span class="line"><span class="comment"># 取消开机自启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> cms <span class="comment"># cms 对应修改为你之前创建的 service 文件名</span></span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理，将域名映射到-ip-port（可选）"><a href="#Nginx-反向代理，将域名映射到-ip-port（可选）" class="headerlink" title="Nginx 反向代理，将域名映射到 ip:port（可选）"></a>Nginx 反向代理，将域名映射到 ip:port（可选）</h3><p>完成部署后后端服务已经可以通过服务器的 ip 地址和端口进行访问<br>如果想实现将某个域名映射到 ip:port，即通过访问域名实现对后端服务的访问，我们需要用 Nginx 进行一个反代（因为域名只能绑定 ip）<br><strong>注：本文不详细讲解 Nginx，建议自行查阅相关知识</strong></p><h4 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h4><p>需要有一个解析到该服务器的域名，可以创建一个子域名</p><h4 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><p>Ubuntu 下输入下面命令即可安装 Nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure><p>中间会询问是否继续安装，输入<code>y</code>回车即可<br>等待安装完成，可以输入下面命令查看 Nginx 服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/EDV35FALEFZGZLWM.webp"><br>安装完成后，Nginx 服务会自己启动，可以看到 Nginx 服务已经正常运行</p><h4 id="配置文件部分说明"><a href="#配置文件部分说明" class="headerlink" title="配置文件部分说明"></a>配置文件部分说明</h4><p>Nginx 配置文件路径默认在<code>/etc/nginx</code><br>可以输入下面命令查看 Nginx 配置文件位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830191656.webp"><br>红框中即 Nginx 主要配置文件所在的位置<br><code>cd /etc/nginx</code>到 Nginx 目录下，<code>ls</code>查看结构<br><img src="https://img.lonesome.cn/blog/record/2Y439YQRU5BRIX1.webp"></p><ul><li>nginx.conf 即 Nginx 的主要配置文件，可以直接在该文件中进行修改（大多数教程也是这么做的），但是如果以后部署的服务多起来，都放在一个配置文件中会显得混乱和臃肿</li><li>新版本的 Nginx 允许我们在 nginx.conf 中导入其他文件夹中的 .conf 文件，因此我们可以针对不同的服务，建立不同的 conf 配置文件，方便管理</li><li>而 Nginx 已经为我们建好了一个文件夹，并且导入到了配置文件中，即 conf.d 文件夹，我们可以直接在该文件夹下新建和添加配置文件</li><li>注：nginx.conf 中有关于 Nginx 整体的相关配置，但这里不多介绍，我们也不去修改</li></ul><h4 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h4><p>在<code>/etc/nginx/conf.d</code>路径下新建一个<code>cms.conf</code>文件，文件名可以自己取，<strong>文件后缀<code>.conf</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/3B0GRKG2UGO5K0RW71FL.webp"></p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>使用 vim 打开编辑该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # 服务端绑定的域名</span><br><span class="line">    server_name cms-back.ximo210.top;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 需要映射到的端口</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>server_name</code>填入你要绑定的域名，比如我这边就是<code>cms-back.ximo210.top</code></li><li>在<code>proxy_pass</code>填入你需要映射到的端口，比如我需要的是 8080 端口</li><li><code>listen 80</code>表示的是监听的端口，因为 http 请求默认访问的是 80 端口，举例来说当我们在访问<code>www.baidu.com</code>的时候其实访问的是<code>www.baidu.com:80</code>，不过 80 可以省略</li></ul><p>将上面的代码理解一下就是当我直接访问<code>cms-back.ximo210.top</code>时，Nginx 会监听到 80 端口有请求，然后做一个反向代理将这个请求发送到 8080 端口，实现将对域名的请求映射到 ip:port<br>将修改完的代码粘贴进配置文件<br><img src="https://img.lonesome.cn/blog/record/1P96O59EALYVEC5.webp"><br>按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h4 id="重启-Nginx"><a href="#重启-Nginx" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h4><p>输入下面命令重启 Nginx 以应用修改后的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/SNNUYZC36G3SNMJXYKL.webp"></p><h4 id="测试访问-1"><a href="#测试访问-1" class="headerlink" title="测试访问"></a>测试访问</h4><p><strong>注：需要确保云服务器 80 端口放开</strong><br>依旧是利用 Apifox 进行测试<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830204519.webp"><br>可以看到能够直接用域名进行访问了</p><h4 id="配置-SSL-证书（可选）"><a href="#配置-SSL-证书（可选）" class="headerlink" title="配置 SSL 证书（可选）"></a>配置 SSL 证书（可选）</h4><p>前面只能用 http 进行访问，现在我想要用 https 进行访问，并且在使用 http 访问时强制跳转 https</p><h5 id="前提-2"><a href="#前提-2" class="headerlink" title="前提"></a>前提</h5><ul><li>有对应域名的 SSL 证书，可以去申请免费的 SSL 证书</li><li>转换 SSL 证书，主要需要<code>.crt</code>和<code>.key</code>文件，具体可以自行搜索</li></ul><h5 id="上传证书文件"><a href="#上传证书文件" class="headerlink" title="上传证书文件"></a>上传证书文件</h5><p>在<code>/etc/nginx</code>目录下新建一个 cert 文件夹存放证书</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 /etc/nginx 路径下执行</span></span><br><span class="line"><span class="built_in">mkdir</span> cert</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/D3SOC1P7WHA5EB6.webp"><br>将转换得到的<code>.crt</code>和<code>.key</code>文件上传到服务器的<code>/etc/nginx/cert</code>文件夹下<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831014907.webp"></p><h5 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>依旧是编辑<code>/etc/nginx/conf.d/cms.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # 服务端绑定的域名</span><br><span class="line">    server_name cms-back.ximo210.top;</span><br><span class="line">    # 强制跳转https</span><br><span class="line">    rewrite ^/(.*) https://$server_name$request_uri? permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # SSL 默认访问端口号为 443</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    # 请填写绑定证书的域名</span><br><span class="line">    server_name cms-back.ximo210.top;</span><br><span class="line">    # 请填写证书文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate /etc/nginx/cert/cms-back.crt;</span><br><span class="line">    # 请填写私钥文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate_key /etc/nginx/cert/cms-back.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    # 请按照以下协议配置</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    # 请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 请填写后端运行的端口</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用上述代码覆盖原先的配置<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830211400.webp"><br>并将红框部分修改为你自己的配置<br>然后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h5 id="重启-Nginx-1"><a href="#重启-Nginx-1" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h5><p>先检查配置有无问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/NGQMR0DB8C7C23IWP7.webp"><br>没有问题则<code>sudo nginx -s reload</code>重启 Nginx 以应用修改</p><h5 id="测试访问-2"><a href="#测试访问-2" class="headerlink" title="测试访问"></a>测试访问</h5><p><strong>注：需要确保云服务器 80 和 443 端口放开</strong><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830212807.webp"><br>实际在访问 http 时也会强制跳转到 https，这里就不做演示了</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="前提-3"><a href="#前提-3" class="headerlink" title="前提"></a>前提</h3><p>已经部署完后端并且能够正常访问</p><h3 id="Vue-项目打包"><a href="#Vue-项目打包" class="headerlink" title="Vue 项目打包"></a>Vue 项目打包</h3><p>在 Vue 项目的根目录执行下面的命令，打包成 dist 目录（打包前记得将环境或者配置修改为服务器的）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>将 dist 目录重命名为 cms（名字自取）</p><h3 id="将打包文件上传到服务器-1"><a href="#将打包文件上传到服务器-1" class="headerlink" title="将打包文件上传到服务器"></a>将打包文件上传到服务器</h3><p>可以使用 xftp 上传打包文件至服务器，也可以使用对应云服务器厂商自带的 WebShell（我使用的是腾讯云的 OrcaTerm）<br>这边将打包好的 cms 文件上传到<code>/var/www</code>文件夹下（文件路径可以自己选择）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830214131.webp"></p><h3 id="修改文件权限-1"><a href="#修改文件权限-1" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>将 cms 目录的权限修改为 755，确保 Nginx 对该文件有访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www</span><br><span class="line">chmod -R 755 cms</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/QMRBFNNL5RU2DR59D.webp"></p><h3 id="安装-Nginx-1"><a href="#安装-Nginx-1" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p><strong>注：如果是从后端 Nginx 部分看过来的，可以直接跳到编辑配置文件，将内容添加到原有配置的后面即可</strong><br>Ubuntu 下输入下面命令即可安装 Nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure><p>中间会询问是否继续安装，输入<code>y</code>回车即可<br>等待安装完成，可以输入下面命令查看 Nginx 服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/EDV35FALEFZGZLWM.webp"><br>安装完成后，Nginx 服务会自己启动，可以看到 Nginx 服务已经正常运行</p><h3 id="配置文件部分说明-1"><a href="#配置文件部分说明-1" class="headerlink" title="配置文件部分说明"></a>配置文件部分说明</h3><p>Nginx 配置文件路径默认在<code>/etc/nginx</code><br>可以输入下面命令查看 Nginx 配置文件位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830191656.webp"><br>红框中即 Nginx 主要配置文件所在的位置<br><code>cd /etc/nginx</code>到 Nginx 目录下，<code>ls</code>查看结构<br><img src="https://img.lonesome.cn/blog/record/2Y439YQRU5BRIX1.webp"></p><ul><li>nginx.conf 即 Nginx 的主要配置文件，可以直接在该文件中进行修改（大多数教程也是这么做的），但是如果以后部署的服务多起来，都放在一个配置文件中则会显得混乱和臃肿</li><li>新版本的 Nginx 允许我们在 nginx.conf 中导入其他文件夹中的 .conf 文件，因此我们可以针对不同的服务，建立不同的 conf 配置文件，方便管理</li><li>而 Nginx 已经为我们建好了一个文件夹，并且导入到了配置文件中，即 conf.d 文件夹，我们可以直接在该文件夹下新建和添加配置文件</li><li>注：nginx.conf 中有关于 Nginx 整体的相关配置，但这里不多介绍，我们也不去修改</li></ul><h3 id="新建配置文件-1"><a href="#新建配置文件-1" class="headerlink" title="新建配置文件"></a>新建配置文件</h3><p>在<code>/etc/nginx/conf.d</code>路径下新建一个<code>cms.conf</code>文件，文件名可以自己取，<strong>文件后缀<code>.conf</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/3B0GRKG2UGO5K0RW71FL.webp"></p><h3 id="编辑配置文件-2"><a href="#编辑配置文件-2" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>使用 vim 打开编辑该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # 监听的端口号（即想要访问的前端服务的端口）</span><br><span class="line">    listen 5173;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 打包文件的路径</span><br><span class="line">        root /var/www/cms;</span><br><span class="line">        index index.html;</span><br><span class="line">        # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">        rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将所有 ip:port/api 的请求转发到对应的后端地址（根据自己实际情况修改）</span><br><span class="line">    location /api &#123;</span><br><span class="line">    # 填写后端服务的端口（如果不是同一台服务器则填写对应服务器的地址）</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将红框部分的代码修改为你自己的配置后写进配置文件<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831001719.webp"><br>按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h3 id="重启-Nginx-2"><a href="#重启-Nginx-2" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h3><p>输入下面命令重启 Nginx 以应用修改后的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/SNNUYZC36G3SNMJXYKL.webp"></p><h3 id="云服务器放行端口-1"><a href="#云服务器放行端口-1" class="headerlink" title="云服务器放行端口"></a>云服务器放行端口</h3><p>想要访问前端页面，需要将服务对应运行的端口（比如我这边就是在<code>5173</code>端口）放开，不然直接访问是访问不到的<br>在云服务器厂商找到对应云服务器的防火墙，并放行 5173 端口（对应你自己前端的运行端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/MRGQM5CQONK6SS7OPMX.webp"><br><img src="https://img.lonesome.cn/blog/record/OS54NJCTVKLJ9Y8G8YY.webp"><br>有这样一条记录就说明 5173 端口已经放行了</p><h3 id="测试访问-3"><a href="#测试访问-3" class="headerlink" title="测试访问"></a>测试访问</h3><p>在浏览器输入<code>ip:5173</code>（对应你自己的<code>ip:port</code>）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831002111.webp"><br>可以看到能正常访问</p><h3 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h3><p>前面是直接使用 ip:port 去访问前端，现在我想要通过域名去访问</p><h4 id="前提-4"><a href="#前提-4" class="headerlink" title="前提"></a>前提</h4><p>需要有一个解析到该服务器的域名（可以创建一个子域名）</p><h4 id="编辑配置文件-3"><a href="#编辑配置文件-3" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>依旧是编辑<code>/etc/nginx/conf.d/cms.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # 前端绑定的域名</span><br><span class="line">    server_name cms.ximo210.top;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 打包文件的路径</span><br><span class="line">        root /var/www/cms;</span><br><span class="line">        index index.html;</span><br><span class="line">        # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">        rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将所有 ip:port/api 的请求转发到对应的后端地址（根据自己实际情况修改）</span><br><span class="line">    location /api &#123;</span><br><span class="line">    # 填写后端服务的端口（如果不是同一台服务器则填写对应服务器的地址）</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原先的基础上修改</p><ul><li><code>listen</code>修改为 80，表示的是监听的端口，因为 http 请求默认访问的是 80 端口，举例来说当我们在访问<code>www.baidu.com</code>的时候其实访问的是<code>www.baidu.com:80</code>，不过 80 可以省略</li><li>在<code>server_name</code>填入你要绑定的域名，比如我这边就是<code>cms.ximo210.top</code></li></ul><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831003615.webp"><br>修改完后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h4 id="测试访问-4"><a href="#测试访问-4" class="headerlink" title="测试访问"></a>测试访问</h4><p><code>sudo nginx -s reload</code>重启 Nginx 以应用修改<br><strong>注：需要确保云服务器 80 端口放开</strong><br>在浏览器输入<code>http://cms.ximo210.top</code>（对应你自己的域名）<br><img src="https://img.lonesome.cn/blog/record/NBLC7GWHT2GO7WJ0T9.webp"><br>可以看到能正常访问</p><h4 id="配置-SSL-证书（可选）-1"><a href="#配置-SSL-证书（可选）-1" class="headerlink" title="配置 SSL 证书（可选）"></a>配置 SSL 证书（可选）</h4><p>前面只能用 http 进行访问，现在我想要用 https 进行访问，并且在使用 http 访问时强制跳转 https</p><h5 id="前提-5"><a href="#前提-5" class="headerlink" title="前提"></a>前提</h5><ul><li>有对应域名的 SSL 证书，可以去申请免费的 SSL 证书</li><li>转换 SSL 证书，主要需要<code>.crt</code>和<code>.key</code>文件，具体可以自行搜索</li><li><strong>注：如果配置了后端域名的 SSL 证书，需要另外再申请一个给当前前端的域名</strong></li></ul><h5 id="上传证书文件-1"><a href="#上传证书文件-1" class="headerlink" title="上传证书文件"></a>上传证书文件</h5><p>在<code>/etc/nginx</code>目录下新建一个 cert 文件夹存放证书</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 /etc/nginx 路径下执行</span></span><br><span class="line"><span class="built_in">mkdir</span> cert</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/D3SOC1P7WHA5EB6.webp"><br>将转换得到的<code>.crt</code>和<code>.key</code>文件上传到服务器的<code>/etc/nginx/cert</code>文件下<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831014843.webp"></p><h5 id="编辑配置文件-4"><a href="#编辑配置文件-4" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>依旧是编辑<code>/etc/nginx/conf.d/cms.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # 前端绑定的域名</span><br><span class="line">    server_name cms.ximo210.top;</span><br><span class="line">    # 强制跳转https</span><br><span class="line">    rewrite ^/(.*) https://$server_name$request_uri? permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    # SSL 默认访问端口号为 443</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    # 请填写绑定证书的域名</span><br><span class="line">    server_name cms.ximo210.top;</span><br><span class="line">    # 请填写证书文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate /etc/nginx/cert/cms.crt;</span><br><span class="line">    # 请填写私钥文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate_key /etc/nginx/cert/cms.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    # 请按照以下协议配置</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    # 请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 打包文件的路径</span><br><span class="line">        root /var/www/cms;</span><br><span class="line">        index index.html;</span><br><span class="line">        # 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    # 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">        rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将所有 ip:port/api 的请求转发到对应的后端地址（根据自己实际情况修改）</span><br><span class="line">    location /api &#123;</span><br><span class="line">    # 填写后端服务的端口（如果不是同一台服务器则填写对应服务器的地址）</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用上述代码覆盖原先的配置<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831014400.webp"><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831021043.webp"><br>并将红框部分修改为你自己的配置<br>然后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h5 id="测试访问-5"><a href="#测试访问-5" class="headerlink" title="测试访问"></a>测试访问</h5><p><code>sudo nginx -s reload</code>重启 Nginx 以应用修改<br><strong>注：需要确保云服务器 80 和 443 端口放开</strong><br>在浏览器输入<code>https://cms.ximo210.top</code>（对应你自己的域名）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831021358.webp"><br>可以看到能正常访问<br>实际在访问 http 时也会强制跳转到 https，这里就不做演示了</p>]]></content>
    
    
    <summary type="html">Ubuntu 部署 Gin+Vue 前后端分离项目记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Gin" scheme="https://lonesome.cn/tags/Gin/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
    <category term="Vue" scheme="https://lonesome.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Redis 并配置远程连接</title>
    <link href="https://lonesome.cn/posts/ubuntu-install-redis/"/>
    <id>https://lonesome.cn/posts/ubuntu-install-redis/</id>
    <published>2023-08-28T10:03:00.000Z</published>
    <updated>2024-10-04T19:08:11.904Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04 LTS</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><h2 id="一、安装-Redis"><a href="#一、安装-Redis" class="headerlink" title="一、安装 Redis"></a>一、安装 Redis</h2><h3 id="1-更新软件包列表"><a href="#1-更新软件包列表" class="headerlink" title="1.更新软件包列表"></a>1.更新软件包列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%7D$R%5D2DXU1%29SN_%28AG%5D5B90W7.webp"></p><h3 id="2-查看是否安装-Redis"><a href="#2-查看是否安装-Redis" class="headerlink" title="2.查看是否安装 Redis"></a>2.查看是否安装 Redis</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/C$1LTE%7DH8RVR%7DZZG9H%60G8%7D6.webp"><br>如果输入上述命令后没有任何的输出（如上图），则说明没有安装 Redis</p><h3 id="3-安装-Redis"><a href="#3-安装-Redis" class="headerlink" title="3.安装 Redis"></a>3.安装 Redis</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install redis-server</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827165945.webp"><br>这里列出了软件包的相关信息并询问你是否继续安装<br>输入<code>y</code>后回车确定继续安装<br>等待安装完后再输入第 2 步的命令查看 Redis 是否已经安装<br><img src="https://img.lonesome.cn/blog/record/LuSOlUCZ.webp"><br>输出如上图，说明 Redis 已经安装成功  <br>安装的 Redis 版本默认为当前 apt 源中最新的稳定版本，可以输入下面的命令查看 Redis 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -v</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%5B@R%5D%60D4U%7DC%7BIIVA%7D_5@1EHX.webp"><br>注：写本文时的版本为 6.0.16</p><h3 id="4-查看-Redis-状态"><a href="#4-查看-Redis-状态" class="headerlink" title="4.查看 Redis 状态"></a>4.查看 Redis 状态</h3><p>一旦安装完成，Redis 服务将会自动启动，想要查看 Redis 服务运行状态可以输入下面命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827172654.webp"><br>输出显示 Redis 服务已经被启动，并且正在运行</p><h3 id="5-启动、重启、停止-Redis-服务的命令"><a href="#5-启动、重启、停止-Redis-服务的命令" class="headerlink" title="5.启动、重启、停止 Redis 服务的命令"></a>5.启动、重启、停止 Redis 服务的命令</h3><p>上一步的命令可以用来查看 Redis 服务的运行状态，下面是启动、重启、停止命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure><p>停止和启动命令的演示<br><img src="https://img.lonesome.cn/blog/record/AzWn6nmz.webp"><br><img src="https://img.lonesome.cn/blog/record/ExoxlCnJ.webp"></p><h3 id="6-测试-Redis"><a href="#6-测试-Redis" class="headerlink" title="6.测试 Redis"></a>6.测试 Redis</h3><p>输入下面命令连接到 Redis 服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/OZ166RP970H7XNCEK.webp"><br>使用<code>乒乓</code>来测试连通性，输入<code>ping</code><br><img src="https://img.lonesome.cn/blog/record/NA4P5OMQ6T7TQ7ZUO.webp"><br>返回<code>pong</code>说明成功！<br>退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="二、配置-Redis-远程连接"><a href="#二、配置-Redis-远程连接" class="headerlink" title="二、配置 Redis 远程连接"></a>二、配置 Redis 远程连接</h2><p>配置 Redis 主要是对配置文件 redis.conf 进行修改，默认位置在 &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><h3 id="1-查找-Redis-配置文件"><a href="#1-查找-Redis-配置文件" class="headerlink" title="1.查找 Redis 配置文件"></a>1.查找 Redis 配置文件</h3><p>使用之前的<code>sudo systemctl status redis</code>命令查看 Redis 服务的状态<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827210532.webp"><br>可以找到这样一个文件<br>然后使用下面的命令查看该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /lib/systemd/system/redis-server.service</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827224128.webp"><br>就可以找到我们 redis.conf 文件所在的位置</p><h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="2.编辑配置文件"></a>2.编辑配置文件</h3><p>使用 vim 编辑 redis.conf 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/FVFBYWHUN8A0GGTN52.webp"></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Redis 默认开启保护模式，并且绑定了本地，也就是只有云服务器本地才能连接并操作 Redis</p><ul><li>保护模式：如果符合下面两个条件（不是之一）则无法被远程连接<ol><li>没有明确使用 bind 绑定某个 ip 地址</li><li>没有设置密码</li></ol></li><li>想要实现远程连接主要有三种方案<ol><li>取消本地绑定（可以被任何 ip 访问），设置密码</li><li>明确绑定某个 ip 地址，设置密码（可选）</li><li>取消本地绑定（可以被任何 ip 访问），关闭保护模式</li></ol></li></ul><h4 id="取消本地绑定-绑定某个-ip-地址"><a href="#取消本地绑定-绑定某个-ip-地址" class="headerlink" title="取消本地绑定&#x2F;绑定某个 ip 地址"></a>取消本地绑定&#x2F;绑定某个 ip 地址</h4><p>移动光标定位到<code>bind 127.0.0.1 ::1</code><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020231014230542.webp"><br>输入<code>i</code>进入编辑模式（在英文输入法下）<br><code>bind 127.0.0.1 ::1</code>的意思是只接受本机的访问请求</p><ul><li>如果想取消本地绑定（可以被任何 ip 访问）<ul><li>将该行注释掉（在前面加<code>#</code>，即<code>## bind 127.0.0.1 ::1</code>），表示接受任何 ip 地址的访问</li></ul></li><li>如果想明确绑定某个 ip 地址<ul><li>将<code>127.0.0.1</code>替换为指定的 ip 地址即可</li></ul></li></ul><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>移动光标定位到<code>## requirepass foobared</code><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828000035.webp"><br>取消该行注释（删除<code>#</code>），并将<code>foobared</code>修改为你想要设置的密码<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828000310.webp"><br>如 123456 就是我设置的密码<br>配置修改生效后再进入 Redis 命令行时需要输入密码登录<br>即使用<code>redis-cli -a your_password</code>命令登录，<code>your_password</code>是你自己设置的密码<br>示例：<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828113506.webp"><br>如果不输入密码进入则会报错未授权<br><img src="https://img.lonesome.cn/blog/record/B6YLQTNK3SY033I8RQ.webp"></p><h4 id="关闭保护模式"><a href="#关闭保护模式" class="headerlink" title="关闭保护模式"></a>关闭保护模式</h4><p>移动光标定位到<code>protected-mode yes</code><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020231014210256.webp"><br>将<code>yes</code>修改为<code>no</code>即表示关闭保护模式</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>一般在上线部署时（只在云服务器本地运行），不需要修改配置文件</li><li>线下调试时，希望开发环境也可以连接到 Redis（方案一）<ul><li><code>## bind 127.0.0.1 ::1</code>，取消本地绑定（可以被任何 ip 访问）</li><li><code>protected-mode yes</code>，保护模式默认开启即可</li><li><code>requirepass your_password</code>，设置密码</li></ul></li></ul><p>以上仅作为参考，具体可以自行选择</p><h3 id="3-重启-Redis-服务"><a href="#3-重启-Redis-服务" class="headerlink" title="3.重启 Redis 服务"></a>3.重启 Redis 服务</h3><p>按<code>Esc</code>退出编辑模式，然后输入<code>:wq</code>后回车保存文件并退出（在英文输入法下）<br>输入下面命令重启 Redis 服务以应用修改后的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure><p>输入以下命令查看 Redis 服务所监听的 ip 和端口（以方案一设置为例）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlpn | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/ECFUWVWTNV92UG54.webp"><br>可以看到 Redis 绑定的 ip 已经变成了 0.0.0.0，即接受任何 ip 地址的访问</p><h3 id="4-云服务器放行-6379-端口"><a href="#4-云服务器放行-6379-端口" class="headerlink" title="4.云服务器放行 6379 端口"></a>4.云服务器放行 6379 端口</h3><p>在云服务器厂商找到对应云服务器的防火墙，并放行 6379 端口（Redis 的默认端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/I5OJRTPQ8PURYVHS.webp"><br><img src="https://img.lonesome.cn/blog/record/TXMS8UF3QGJLKNKM4VBD.webp"><br>有这样一条记录就说明 6379 端口已经放行了</p><h3 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5.测试连接"></a>5.测试连接</h3><p>本文使用 Another Redis Desktop Manager 测试连接云服务器上的 Redis<br><img src="https://img.lonesome.cn/blog/record/20230828005651.webp"><br>地址填你云服务器的 ip 地址<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828005841.webp"><br>连接成功！</p>]]></content>
    
    
    <summary type="html">Ubuntu 安装 Redis 并配置远程连接记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Redis" scheme="https://lonesome.cn/tags/Redis/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 MySQL 并配置远程连接</title>
    <link href="https://lonesome.cn/posts/ubuntu-install-mysql/"/>
    <id>https://lonesome.cn/posts/ubuntu-install-mysql/</id>
    <published>2023-08-25T20:56:07.000Z</published>
    <updated>2024-10-04T19:08:10.741Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>云服务器：腾讯云（不同厂商云服务器上的操作基本相同）</li><li>系统：Ubuntu 22.04 LTS</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><h2 id="一、安装-MySQL"><a href="#一、安装-MySQL" class="headerlink" title="一、安装 MySQL"></a>一、安装 MySQL</h2><h3 id="1-更新软件包列表"><a href="#1-更新软件包列表" class="headerlink" title="1.更新软件包列表"></a>1.更新软件包列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%7D$R%5D2DXU1%29SN_%28AG%5D5B90W7.webp"></p><h3 id="2-查看是否安装-MySQL"><a href="#2-查看是否安装-MySQL" class="headerlink" title="2.查看是否安装 MySQL"></a>2.查看是否安装 MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/url-SIeWkuuv8c6ERv3r.webp"><br>如果输入上述命令后没有任何的输出（如上图），则说明没有安装 MySQL</p><h3 id="3-安装-MySQL"><a href="#3-安装-MySQL" class="headerlink" title="3.安装 MySQL"></a>3.安装 MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mysql-server</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825152339.webp"><br>这里列出了软件包的相关信息并询问你是否继续安装<br>输入<code>y</code>后回车确定继续安装<br>等待安装完后再输入第 2 步的命令查看 MySQL 是否已经安装<br><img src="https://img.lonesome.cn/blog/record/H9nCE8Yq.webp"><br>输出如上图，说明 MySQL 已经安装成功<br>安装的 MySQL 版本默认为当前 apt 源中最新的稳定版本，可以输入下面的命令查看 MySQL 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/url-IDI7IQUlrPQnNw09.webp"><br>注：写本文时的版本为 8.0.34</p><h3 id="4-查看-MySQL-状态"><a href="#4-查看-MySQL-状态" class="headerlink" title="4.查看 MySQL 状态"></a>4.查看 MySQL 状态</h3><p>一旦安装完成，MySQL 服务将会自动启动，想要查看 MySQL 服务运行状态可以输入下面命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825153214.webp"><br>输出显示 MySQL 服务已经被启动，并且正在运行</p><h3 id="5-启动、重启、停止-MySQL-服务的命令"><a href="#5-启动、重启、停止-MySQL-服务的命令" class="headerlink" title="5.启动、重启、停止 MySQL 服务的命令"></a>5.启动、重启、停止 MySQL 服务的命令</h3><p>上一步的命令可以用来查看 MySQL 服务的运行状态，下面是启动、重启、停止命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start mysql</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop mysql</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br></pre></td></tr></table></figure><p>停止和启动命令的演示<br><img src="https://img.lonesome.cn/blog/record/s5yRX0ih.webp"><br><img src="https://img.lonesome.cn/blog/record/5duzWs8r.webp"></p><h3 id="6-开机自启动设置（可选）"><a href="#6-开机自启动设置（可选）" class="headerlink" title="6.开机自启动设置（可选）"></a>6.开机自启动设置（可选）</h3><p>注：使用<code>systemd</code>管理服务，前提是使用 apt 安装的 MySQL<br>当前新版本的 MySQL 服务默认是开机自启动，可以通过前面的<code>sudo systemctl status mysql</code>命令查看<br><img src="https://img.lonesome.cn/blog/record/CcyP3qLl.webp"><br>该处的参数为<code>enabled</code>，说明当前 MySQL 服务是开机自启动<br>可以用下面命令关闭开机自启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/V7INkdDD.webp"><br>查看状态可以发现原本的<code>enabled</code>参数变成了<code>disabled</code>，说明 MySQL 服务不再是开机自启动<br><img src="https://img.lonesome.cn/blog/record/P8A9j8Aa.webp"><br>附上开启开机自启动的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl enabled mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/ShgYmSAY.webp"><br>再次查看状态就可以发现又变回了<code>enabled</code></p><h2 id="二、MySQL-安全配置向导"><a href="#二、MySQL-安全配置向导" class="headerlink" title="二、MySQL 安全配置向导"></a>二、MySQL 安全配置向导</h2><p>MySQL 安装文件时会附带一个名为<code>mysql_secure_installation</code>的脚本，我们可以通过运行该脚本提高 MySQL 的安全性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825155820.webp"><br>这里有一个插件<code>VALIDATE PASSWORD PLUGIN</code>，它可以测试 MySQL 用户密码的强度，并且提高安全性，如果你想设置验证密码插件，按<code>y</code>回车后移动到下一个步骤<br><strong>注：如果不想设置复杂密码（比如想设置密码是 123456）的建议选择输入<code>n</code>不设置验证密码的插件，因为即使是下面的 LOW 策略也要求密码长度至少为 8 位（<del>安全性哪有方便重要</del>）</strong><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825160155.webp"><br>这里给出了低级，中级，高级三个级别的密码验证策略</p><ul><li>低级 长度 &gt;&#x3D; 8</li><li>中级 在低级的基础上，需要同时包含数字，大小写字母和特殊字符</li><li>高级 在中级的基础上，要求密码不能存在字典文件中</li></ul><p>可以输入对应级别前的数字进行选择，这边选择了 STRONG（即 2）<br><img src="https://img.lonesome.cn/blog/record/J_T8D9BD%60HFXU5E5LQHE0%7B4.webp"></p><blockquote><p>注：这里是输入 2 后回车，显示的上半部分内容，我在写本文时从网上找到的教程在这里都会有要你设置密码的一步，但是在新版本的 MySQL 是没有的，被上面这段话代替了，翻译过来的意思是：</p><blockquote><p>默认情况下，使用 auth_socket 进行身份验证，因此跳过为 root 用户设置密码。<br>如果你想改用密码身份验证，可以使用”ALTER_USER”命令进行设置。<br>请参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-user.html#alter-user-password-management">https://dev.mysql.com/doc/refman/8.0/en/alter-user.html#alter-user-password-management</a> 获取更多信息。</p></blockquote><p>这边仅做一个补充，为 root 用户设置密码的操作在第三部分会提到</p></blockquote><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825175750.webp"><br>询问是否删除匿名用户，建议输入<code>y</code>删除</p><ul><li>在 MySQL 中，默认情况下会存在一个匿名用户（没有用户名和密码就可以登录），该用户具有一些基本的权限</li><li>如果每个用户都有明确的身份和权限，可以更容易地追踪和监视数据库的活动，识别潜在的安全问题</li><li>为了确保数据库仅允许经过授权的用户进行访问和操作，减少潜在的安全风险，建议删除匿名用户</li></ul><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825180256.webp"><br>询问是否禁止 root 远程登录，根据自己需求选择，如果你想要使用 root 用户远程连接 MySQL 数据库，可以输入任意键跳过该设置<br>出于安全考虑，建议输入<code>y</code>禁止</p><ul><li>root 是 MySQL 数据库的超级管理员，拥有最高权限，一旦泄露后果非常严重，禁止 root 用户远程登录可以降低潜在的风险</li><li>更推荐的做法是创建一个普通用户，并为其授予适当的权限，以便远程访问数据库，这样做可以限制对数据库的访问权限，并提供额外的安全层</li><li>禁止 root 用户远程登录还可以防止意外的操作或误操作</li></ul><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825182358.webp"><br>询问是否删除 test 数据库，输入<code>y</code>删除<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825183859.webp"><br>询问是否重新加载权限表，输入<code>y</code>重新加载<br><img src="https://img.lonesome.cn/blog/record/%29%7D4J%5DMV405BP3QLORYL_A_W.webp"><br>Success.<br>All done!</p><h2 id="三、修改-root-用户验证方式（可选）"><a href="#三、修改-root-用户验证方式（可选）" class="headerlink" title="三、修改 root 用户验证方式（可选）"></a>三、修改 root 用户验证方式（可选）</h2><p>在 MySQL 5.7（及更高版本）的 Ubuntu 系统中，root 用户默认使用 auth_socket 插件授权，而不是通过密码进行身份验证（即使输入了密码也不会验证），但这并不意味着安全性降低，因为他有两个限制：</p><ul><li>只能用 UNIX 的 socket 方式登陆，这就保证了只能本地登陆，用户在使用这种登陆方式时已经通过了操作系统的安全验证</li><li>操作系统的用户和 MySQL 数据库的用户名必须一致，如果你要登陆 MySQL 的 root 用户，必须使用操作系统的 root 用户</li></ul><p>在多数情况下，这可以获得更高的安全性和可用性，但也会阻碍你使用外部程序（如 phpMyAdmin）访问数据库，或者是想使用 root 用户远程连接数据库等<br>对此有两种解决方案：</p><ul><li>将身份验证方式从 auth_socket 修改为 caching_sha2_password（即使用密码验证 root 用户）<ul><li>我在写本文时从网上找到的教程都是修改为 mysql_native_password，主要原因是因为 caching_sha2_password 在 MySQL 8.0.3 才开始引入，并且由老版本升级为新版本时会出现一些问题</li><li>但相比于 mysql_native_password，caching_sha2_password 的安全性更高，从 MySQL 8.0.4 开始，此插件成为 MySQL 服务器的新默认身份验证插件</li><li>因为我们安装的是新版的 MySQL，所以我更建议使用 caching_sha2_password</li></ul></li><li>创建一个新的管理用户，拥有所有数据库的访问权限</li></ul><h3 id="1-使用-root-身份登录-MySQL"><a href="#1-使用-root-身份登录-MySQL" class="headerlink" title="1.使用 root 身份登录 MySQL"></a>1.使用 root 身份登录 MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%7BS03JJH24BI47W_DJ%7B2OB_L.webp"><br>登入成功后输出如上图</p><h3 id="2-查看不同用户使用的身份验证方法"><a href="#2-查看不同用户使用的身份验证方法" class="headerlink" title="2.查看不同用户使用的身份验证方法"></a>2.查看不同用户使用的身份验证方法</h3><p>输入下面的命令查看数据库对不同用户使用的身份验证方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/lkdnflwelqfl.webp"><br>可以看到 root 用户确实是使用的 auth_socket 插件进行身份验证，并且密码为空</p><h3 id="方案一：修改身份验证方式"><a href="#方案一：修改身份验证方式" class="headerlink" title="方案一：修改身份验证方式"></a>方案一：修改身份验证方式</h3><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>输入下面命令将 root 用户的身份验证方式 auth_socket 修改成 caching_sha2_password，并设置登录的密码（包含在单引号之间）<br>注：需要满足在安全配置向导中选择的密码强度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;your_password&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826014853.webp"><br>如果设置的密码不满足之前选择的强度则会报下图的错误<br><img src="https://img.lonesome.cn/blog/record/G9C%29K50NNSME3D%5BN%7BLJ_OUG.webp"><br>最后输入下面命令，重新加载授权表并将更改更新到 MySQL 数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/hsu6Q8hz.webp"><br>完成后，再次运行以下命令确认 root 用户不再使用 auth_socket 进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/mANsO1EA.webp"><br>从上图中，我们可以看到 root 身份验证方式已经修改为 caching_sha2_password，即 root 用户可以使用密码作为验证方式登陆了</p><h4 id="修改后登录"><a href="#修改后登录" class="headerlink" title="修改后登录"></a>修改后登录</h4><p>输入<code>exit</code>退出 MySQL<br><img src="https://img.lonesome.cn/blog/record/dsydG4lP.webp"><br>由于我们更改了 root 的身份验证方法，因此我们不能再使用之前的命令（即<code>sudo mysql</code>）登录 MySQL<br><img src="https://img.lonesome.cn/blog/record/OaEP42tR.webp"><br>我们在登陆时需要加上用户名和密码参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>-u 表示 user，-p 表示 password，当你按下回车后，服务器会要求你输入密码<br><img src="https://img.lonesome.cn/blog/record/A_BV%7DRX%28UR$VGJB1N%2808Y66.webp"><br>考虑到安全性，输入的密码不会在屏幕上显示出来，输入正确的密码后回车即可<br><img src="https://img.lonesome.cn/blog/record/AgPmCexJ.webp"><br>登录成功</p><h3 id="方案二：创建新的管理用户（推荐）"><a href="#方案二：创建新的管理用户（推荐）" class="headerlink" title="方案二：创建新的管理用户（推荐）"></a>方案二：创建新的管理用户（推荐）</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建一个新的管理用户，并赋予所有数据库的访问权限<br>注：需要满足在安全配置向导中选择的密码强度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户并设置密码</span><br><span class="line">CREATE USER &#x27;new_root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;your_password&#x27;;</span><br><span class="line"># 赋予用户所有权限</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;new_root&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/@$H$@06%28B%5D%60ZCZ@$N4%7D9R$V.webp"><br>输入下面命令，重新加载授权表并将更改更新到 MySQL 数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/hsu6Q8hz.webp"><br>查看创建用户的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for new_root@localhost;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%5DTKB3%7B6I9W%60%60FD@J_0A1BYV.webp"><br><del>输出格式怪怪的，可能是终端的问题，但是问题不大</del><br>可以看到所有权限都被赋予了我们新创建的 new_root 用户，之后我们就能将该用户当作 root 用户使用</p><h4 id="登录创建用户"><a href="#登录创建用户" class="headerlink" title="登录创建用户"></a>登录创建用户</h4><p>我们依旧可以使用<code>sudo mysql</code>命令登录 root 用户，但是现在我们想要登录新创建的 new_root 用户<br>输入<code>exit</code>退出 MySQL<br><img src="https://img.lonesome.cn/blog/record/dsydG4lP.webp"><br>我们在登陆时需要加上用户名和密码参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u new_root -p</span><br></pre></td></tr></table></figure><p>-u 表示 user，-p 表示 password，当你按下回车后，服务器会要求你输入密码<br><img src="https://img.lonesome.cn/blog/record/b5WrDFE0.webp"><br>考虑到安全性，输入的密码不会在屏幕上显示出来，输入正确的密码后回车即可<br><img src="https://img.lonesome.cn/blog/record/eyTXwCw1.webp"><br>登录成功</p><h2 id="四、配置远程连接"><a href="#四、配置远程连接" class="headerlink" title="四、配置远程连接"></a>四、配置远程连接</h2><p>先使用 root 身份登录 MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 没修改过 root 用户身份验证方式</span><br><span class="line">sudo mysql</span><br><span class="line"># 修改过 root 用户身份验证方式</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>推荐的做法是创建一个普通用户，并为其授予适当的权限，用来远程访问数据库<ul><li>该部分可以参考本文 <strong>修改 root 用户验证方式（可选）</strong> 中的 <strong>方案二：创建新的管理用户</strong> 部分</li><li>不同的地方在于可以根据自己的实际情况赋予创建的用户权限，相关命令可以自行百度，<del>懒得写了</del></li><li>如果暂时不清楚需要给什么权限，可以先赋予所有权限（跟着方案二即可），后续再修改</li></ul></li><li>如果想要<strong>使用 root 用户进行远程连接</strong>，请先确保已经跟着方案一<strong>修改好了 root 用户的验证方式</strong></li><li><strong>root 用户或者是自己新创建的用户，后续配置远程连接的操作都是一样的</strong>，这里用 root 用户进行演示，如果选择创建一个新的用户进行远程连接，将带有 root 用户名的部分都替换成新创建用户的用户名即可</li></ul><h3 id="1-修改-host"><a href="#1-修改-host" class="headerlink" title="1.修改 host"></a>1.修改 host</h3><p>查看 root 用户的 host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,host FROM mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/7G15spb7.webp"><br>如果 root 用户的 host 为<code>localhost</code>，表示只能在本地（该服务器内）登录 root 用户<br>修改  root  用户的 host  为<code>%</code><br>注：host 为<code>%</code>表示所有 ip 都有连接权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用名为 mysql 的数据库</span><br><span class="line">use mysql</span><br><span class="line"># 修改 host</span><br><span class="line">update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br><span class="line"># 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/9E2DV_AXTXM4HC9X%7DYNV759.webp"><br>再次查看 root 用户的 host，确认已经修改为<code>%</code><br><img src="https://img.lonesome.cn/blog/record/X%60LWJI@_%5BCCR@94K%291N0A%28P.webp"></p><h3 id="2-注释掉-bind-address"><a href="#2-注释掉-bind-address" class="headerlink" title="2.注释掉 bind-address"></a>2.注释掉 bind-address</h3><p>输入<code>exit</code>退出 MySQL，回到 Ubuntu 终端<br>使用 vim 查看编辑 MySQL 配置文件，输入下面命令后回车</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826035630.webp"><br>移动光标找到下图中标记的位置<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826035754.webp"><br>按下<code>i</code>进入 vim 的编辑模式（在英文输入法下）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826040253.webp"><br>将该行（意思是只允许本地访问）注释掉（在前面加<code>#</code><br>然后按下<code>Esc</code>键退出编辑模式<br>再输入<code>:wq</code>（包括<code>:</code>号，在英文输入法下）后回车即保存退出</p><h3 id="3-重启-mysql-服务"><a href="#3-重启-mysql-服务" class="headerlink" title="3.重启 mysql 服务"></a>3.重启 mysql 服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/ky1POFqj.webp"></p><h3 id="4-云服务器放行-3306-端口"><a href="#4-云服务器放行-3306-端口" class="headerlink" title="4.云服务器放行 3306 端口"></a>4.云服务器放行 3306 端口</h3><p>在云服务器厂商找到对应云服务器的防火墙，并放行 3306 端口（MySQL 的默认端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/vGyI9iT3.webp"><br><img src="https://img.lonesome.cn/blog/record/JISJICEU.webp"><br>有这样一条记录就说明 3306 端口已经放行了</p><h3 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5.测试连接"></a>5.测试连接</h3><p>本文使用 Navicat 测试连接云服务器上的 MySQL<br><img src="https://img.lonesome.cn/blog/record/R14YCN%29F%5DMK%2997@GX%7DF%601%60T.webp"><br>主机填你云服务器的 ip 地址<br>用户名填你用来进行远程连接的 MySQL 用户名<br><img src="https://img.lonesome.cn/blog/record/TYVWZ7KR1EX%60L%5BM7EA_EI%280.webp"><br>结束！</p>]]></content>
    
    
    <summary type="html">Ubuntu 安装 MySQL 并配置远程连接记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Gorm 简易教程</title>
    <link href="https://lonesome.cn/posts/gorm-simple-tutorial/"/>
    <id>https://lonesome.cn/posts/gorm-simple-tutorial/</id>
    <published>2023-08-15T01:30:00.000Z</published>
    <updated>2024-08-13T13:22:47.872Z</updated>
    
    <content type="html"><![CDATA[<p>精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gorm（MySQL）<br><a href="https://www.bilibili.com/video/BV1dj411z7pW/?share_source=copy_web&vd_source=220eb9848825e3e6c13414db26a32f45">B 站授课链接点击此处</a></p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><h4 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h4><ul><li>ORM 是 Object Relational Mapping 的缩写，译为 ”对象关系映射“，他解决了对象和关系型数据库之间的数据交互问题</li><li>将<em>程序中的对象&#x2F;实例</em>与<em>关系型数据库</em>映射起来</li><li>三个映射关系<ul><li>数据表对应结构体</li><li>数据行对应结构体实例</li><li>字段对应结构体字段</li></ul></li><li>以 Go 为例：</li><li><img src="https://img.lonesome.cn/blog/go-web/84878fff-e7ef-4ab6-b6ae-3b9a52a5ff3a.webp"></li></ul><h4 id="为什么使用-ORM"><a href="#为什么使用-ORM" class="headerlink" title="为什么使用 ORM"></a>为什么使用 ORM</h4><ul><li>提高开发效率</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">    Sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := UserInfo&#123;<span class="number">1</span>, <span class="string">&quot;XiMo&quot;</span>, <span class="number">3</span>, <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 将 user 存入数据库</span></span><br><span class="line">    <span class="comment">// SQL 语句</span></span><br><span class="line">    <span class="comment">// insert into userinfo values(1,&quot;XiMo&quot;,3,&quot;male&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// orm 语句</span></span><br><span class="line"><span class="comment">// orm.Create(&amp;user)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点<ul><li>自动生成 SQL 语句，会牺牲一定的性能</li><li>对于复杂的数据库操作，ORM 通常难以处理，即使能够处理，也不如直接手写原生 SQL 语句灵活</li><li>弱化 SQL 能力</li></ul></li></ul><h3 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h3><ul><li><a href="https://gorm.io/zh_CN/">GORM</a> 是 Go 语言目前比较热门的数据库 ORM 操作库，对开发者也比较友好，使用非常简单</li></ul><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>在使用 gorm 之前我们需要下载 gorm 以及对应数据库 mysql 的驱动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get -u gorm.io/gorm</span><br><span class="line">$ <span class="keyword">go</span> get -u gorm.io/driver/mysql</span><br></pre></td></tr></table></figure><h5 id="简单连接"><a href="#简单连接" class="headerlink" title="简单连接"></a>简单连接</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="keyword">var</span> DB *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := <span class="string">&quot;root&quot;</span></span><br><span class="line">    pass := <span class="string">&quot;123456&quot;</span></span><br><span class="line">    host := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    port := <span class="string">&quot;3306&quot;</span></span><br><span class="line">    DBname := <span class="string">&quot;gorm_learn&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dsn data-source-name 告知数据库所在的位置以及数据库相关的属性</span></span><br><span class="line">    <span class="comment">// user:pass@tcp(host:port)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local</span></span><br><span class="line">    dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">        user, pass, host, port, DBname)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库，获得 DB 类型实例，用于后面对数据库进行的操作</span></span><br><span class="line">    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database, error = &quot;</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值给全局变量</span></span><br><span class="line">    DB = db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 做一层简单的封装，后续操作可以直接利用全局变量 DB 进行</span></span><br><span class="line">    Init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><p>在使用 ORM 工具时，通常我们需要在代码中定义模型（Model）与数据库中的数据表进行映射，在 GORM 中模型（Model）通常是正常定义的结构体、由 Go 的基本数据类型、实现了 <a href="https://pkg.go.dev/database/sql/?tab=doc#Scanner">Scanner</a> 和 <a href="https://pkg.go.dev/database/sql/driver#Valuer">Valuer</a> 接口的自定义类型及其指针或别名组成<br>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID           <span class="type">uint</span></span><br><span class="line">    Name         <span class="type">string</span></span><br><span class="line">    Email        *<span class="type">string</span></span><br><span class="line">    Age          <span class="type">uint8</span></span><br><span class="line">    Birthday     *time.Time</span><br><span class="line">    MemberNumber sql.NullString</span><br><span class="line">    ActivatedAt  sql.NullTime</span><br><span class="line">    CreatedAt    time.Time</span><br><span class="line">    UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动迁移建表"><a href="#自动迁移建表" class="headerlink" title="自动迁移建表"></a>自动迁移建表</h3><p><code>AutoMigrate</code> 会根据结构体帮我们自动创建一个表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB.AutoMigrate(&amp;User)</span><br></pre></td></tr></table></figure><p><code>AutoMigrate</code> 的逻辑是只新增，不删除，不修改（可以修改大小）<br>例如 User 结构体中将 Name 改成 Username，对应的表中会多出一个 username 的字段，但是原本的 name 字段不会删除</p><h3 id="Gorm-约定"><a href="#Gorm-约定" class="headerlink" title="Gorm 约定"></a>Gorm 约定</h3><p>GORM 倾向于约定优于配置 默认情况下</p><ul><li><code>Gorm</code> 使用名为 <code>ID</code> 的字段作为主键</li><li>如果没有 <code>TableName</code> 函数，使用结构体的蛇形复数作为表名</li><li>字段名的蛇形作为列名</li><li>使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建更新时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体的蛇形复数作为表名（UserInfo --&gt; user_infos）</span></span><br><span class="line"><span class="comment">// 默认列名是字段名的蛇形小写（CreatedAt --&gt; created_at）</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">uint</span> <span class="comment">// 默认为主键</span></span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    Age       <span class="type">int</span></span><br><span class="line">    CreatedAt time.Time <span class="comment">// 创建记录时，如果该字段值为零值，则将该字段的值设为当前时间</span></span><br><span class="line">    UpdatedAt time.Time <span class="comment">// 更新记录时，将该字段的值设为当前时间，创建记录时，如果该字段值为零值，则将该字段的值设为当前时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果遵循 GORM 的约定，就可以少写一些配置、代码。 当然，如果约定不符合你的实际要求，<a href="https://gorm.io/zh_CN/docs/conventions.html">GORM 允许你配置它们</a></p><h4 id="主键（Primary-Key）"><a href="#主键（Primary-Key）" class="headerlink" title="主键（Primary Key）"></a>主键（Primary Key）</h4><p>GORM 默认会使用名为 ID 的字段作为表的主键，你可以通过标签 <code>primaryKey</code> 将其它字段设为主键</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 UUID 作为主键</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">uint</span></span><br><span class="line">    UUID <span class="type">int64</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复数表名（Table-Name）"><a href="#复数表名（Table-Name）" class="headerlink" title="复数表名（Table Name）"></a>复数表名（Table Name）</h4><p>表名默认就是结构体的蛇形复数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `user_infos`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 UserInfo 的表名设置为 `user`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UserInfo)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了这种方式外还有别的方法，比如临时修改表名、修改 Gorm 的命名策略等，这边不多做涉及，可以自行查阅文档</span></span><br></pre></td></tr></table></figure><h4 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h4><p>数据表的列名使用的是 struct 字段名的蛇形命名<br>可以使用 <code>column</code> 标签来覆盖列名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID       <span class="type">uint</span>   <span class="string">`gorm:&quot;column:user_id&quot;`</span>  <span class="comment">// 将列名设为 `user_id`</span></span><br><span class="line">    UserName <span class="type">string</span> <span class="string">`gorm:&quot;column:name&quot;`</span>     <span class="comment">// 将列名设为 `name`</span></span><br><span class="line">    Age      <span class="type">int64</span>  <span class="string">`gorm:&quot;column:user_age&quot;`</span> <span class="comment">// 将列名设为 `user_age`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间戳追踪"><a href="#时间戳追踪" class="headerlink" title="时间戳追踪"></a>时间戳追踪</h4><h5 id="CreatedAt"><a href="#CreatedAt" class="headerlink" title="CreatedAt"></a>CreatedAt</h5><p>对于有 <code>CreatedAt</code> 字段的模型，创建记录时，如果该字段值为零值，则将该字段的值设为当前时间<br>可以通过将 <code>autoCreateTime</code> 标签置为 <code>false</code> 来禁用时间戳追踪</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    CreatedAt time.Time <span class="string">`gorm:&quot;autoCreateTime:false&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UpdatedAt"><a href="#UpdatedAt" class="headerlink" title="UpdatedAt"></a>UpdatedAt</h5><p>对于有 <code>UpdatedAt</code> 字段的模型，更新记录时，将该字段的值设为当前时间。创建记录时，如果该字段值为零值，则将该字段的值设为当前时间<br>可以通过将 <code>autoUpdateTime</code> 标签置为 <code>false</code> 来禁用时间戳追踪</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    UpdatedAt time.Time <span class="string">`gorm:&quot;autoUpdateTime:false&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标记（tag）"><a href="#结构体标记（tag）" class="headerlink" title="结构体标记（tag）"></a>结构体标记（tag）</h3><p>声明 model 时，tag 是可选的，GORM 支持以下 tag：tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格，多个 tag 之间用 <code>;</code> 分格</p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>column</td><td>指定 db 列名</td></tr><tr><td>type</td><td>列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td>serializer</td><td>指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td>size</td><td>定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td>primaryKey</td><td>将列定义为主键</td></tr><tr><td>unique</td><td>将列定义为唯一键</td></tr><tr><td>default</td><td>定义列的默认值</td></tr><tr><td>precision</td><td>指定列的精度</td></tr><tr><td>scale</td><td>指定列大小</td></tr><tr><td>not null</td><td>指定列为 NOT NULL</td></tr><tr><td>autoIncrement</td><td>指定列为自动增长</td></tr><tr><td>autoIncrementIncrement</td><td>自动步长，控制连续记录之间的间隔</td></tr><tr><td>embedded</td><td>嵌套字段</td></tr><tr><td>embeddedPrefix</td><td>嵌入字段的列名前缀</td></tr><tr><td>autoCreateTime</td><td>创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td>autoUpdateTime</td><td>创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td>index</td><td>根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td>uniqueIndex</td><td>与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td>check</td><td>创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td>&lt;-</td><td>设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td>-&gt;</td><td>设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td>-</td><td>忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td>comment</td><td>迁移时为字段添加注释</td></tr></tbody></table><p>tag 使用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID       <span class="type">uint</span>   <span class="string">`gorm:&quot;autoIncrement&quot;`</span>                    <span class="comment">// 自增主键</span></span><br><span class="line">    Name     <span class="type">string</span> <span class="string">`gorm:&quot;size:10&quot;`</span>                          <span class="comment">// 大小为 10 个字符</span></span><br><span class="line">    Age      <span class="type">int</span>    <span class="string">`gorm:&quot;size:3; check:age &gt; 0&quot;`</span>            <span class="comment">// 大小为 3 位数，并且值要 &gt; 0</span></span><br><span class="line">    Email    <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(25); unique;&quot;`</span>        <span class="comment">// 类型为 varchar(25)，唯一</span></span><br><span class="line">    Password <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); default:123456&quot;`</span> <span class="comment">// 类型为 varchar(20)，默认值为 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h3><p>对于一张数据表的每一条数据来说，都有自增主键，创建、更新与删除时间等比较通用的字段，因此 GORM 将其抽出来并定义了 gorm.Model，包含 <code>ID</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>, <code>DeletedAt</code> 四个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">uint</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">    UpdatedAt time.Time</span><br><span class="line">    DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将它嵌入到你自己的模型中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    Age       <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">    UpdatedAt time.Time</span><br><span class="line">    DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    Age       <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">uint</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">    Sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建记录-1"><a href="#创建记录-1" class="headerlink" title="创建记录"></a>创建记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;XiMo&quot;</span>, Age: <span class="number">3</span>, Sex: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><ul><li>注：Create 传入的参数是指针而不是值</li><li>由于传递的是一个指针，执行完 Create 函数后 user 中就有了该记录相关的信息，比如创建的 ID</li></ul><p>我们还可以使用 <code>Create()</code> 创建多项记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">users := []User&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;惜寞&quot;</span>, Age: <span class="number">3</span>, Sex: <span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;青鸟&quot;</span>, Age: <span class="number">18</span>, Sex: <span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;users) <span class="comment">// 传入切片的指针</span></span><br><span class="line"></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><h3 id="用指定的字段创建记录"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录</h3><p>创建记录并为指定的字段分配值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Create(&amp;user)</span><br></pre></td></tr></table></figure><p>创建记录并忽略要省略的传递字段的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Create(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="根据-Map-创建（不常用）"><a href="#根据-Map-创建（不常用）" class="headerlink" title="根据 Map 创建（不常用）"></a>根据 Map 创建（不常用）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;竹林&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">19</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 []map[string]interface&#123;&#125;&#123;&#125; 批量插入</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;知更鸟&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;桑葚&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/create.html">更多</a></h3><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><h3 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h3><ul><li>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象</li><li>提供了 <code>Find</code> 方法，以便从数据库中检索全部对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询第一条记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询最后一条记录</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有的记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// 返回错误</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>当目标对象有一个主键值时，将使用主键构建查询条件</li><li>使用 <code>First</code> 等方法查询单个记录时，如果查询不到数据会返回 <code>ErrRecordNotFound</code> 错误</li><li>使用 <code>Find</code> 查询时，查询不到数据不会返回错误</li></ul></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="string-条件"><a href="#string-条件" class="headerlink" title="string 条件"></a>string 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="struct-Map-条件"><a href="#struct-Map-条件" class="headerlink" title="struct &amp; Map 条件"></a>struct &amp; Map 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice of primary keys</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><p>注意：使用 struct 查询时，GORM 将仅使用非零字段进行查询，这意味着如果你的字段的值为 <code>0</code> <code>&#39;&#39;</code> <code>false</code> 或其他零值时，将不会用于构建查询条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><p>要在查询条件中包含零值，可以使用 map，它会将所有键值作为查询条件包含在内，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="指定结构体查询字段"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a>指定结构体查询字段</h4><p>在使用 struct 进行搜索时，指定在查询条件中要使用结构体中的哪些特定值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br><span class="line"></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get by primary key if it were a non-integer type</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="Not-条件"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE NOT name = &quot;jinzhu&quot; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">18</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &lt;&gt; 18 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1;</span></span><br></pre></td></tr></table></figure><h4 id="Or-条件"><a href="#Or-条件" class="headerlink" title="Or 条件"></a>Or 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>, Age: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br></pre></td></tr></table></figure><h3 id="选择特定字段"><a href="#选择特定字段" class="headerlink" title="选择特定字段"></a>选择特定字段</h3><p><code>Select</code> 允许指定要从数据库中检索的字段，没有 <code>Select</code> GORM 将默认选择所有字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple orders</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br></pre></td></tr></table></figure><h3 id="Limit-Offset"><a href="#Limit-Offset" class="headerlink" title="Limit &amp; Offset"></a>Limit &amp; Offset</h3><p><code>Limit</code> 指定要检索的最大记录数，<code>Offset</code> 指定在开始返回记录之前要跳过的记录数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 表示检索所有记录</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br><span class="line"></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span></span><br></pre></td></tr></table></figure><p>注意：<code>Offset</code> 不能单独使用，要和 <code>Limit</code> 要一起使用</p><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/query.html">更多</a></h3><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><ul><li>以查询到记录为基础</li><li>更新的记录不存在不会报 error</li></ul><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><p><code>Save</code> 会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><ul><li>如果保存值不包含主键（或者主键值在数据库中不存在），它将执行 Create 创建</li><li>主键存在则会执行更新保存所有字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Save(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;)</span></span><br><span class="line"></span><br><span class="line">db.Save(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</span></span><br></pre></td></tr></table></figure><h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><ul><li>需要通过 <code>Model</code> 函数来传入要更新的模型，主要是用来确定表名</li><li>当使用该方法并且其值具有主值时，主键将用于构建条件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据条件更新</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键更新</span></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件和主键更新</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><h3 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h3><ul><li>如果要更新多个字段的话，可以使用 <code>Updates</code> 函数，该函数需要传入一个结构体或 map</li><li>在使用结构体时，不会更新零值，如果要更新的话，需要使用 map 或者更新选定字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用结构体更新</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 map 更新</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><p>如果要在更新时更新所选字段或忽略某些字段，可以使用 <code>select</code> 和 <code>omit</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select with Map</span></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select with Struct (select zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;new_name&#x27;, age=0 WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields but omit Role (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Omit(<span class="string">&quot;Role&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>如果我们没有指定主键值，GORM 将执行批量更新 <code>Model</code>，更新所有符合条件的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update with struct</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE role = &#x27;admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with map</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;id IN ?&quot;</span>, []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br></pre></td></tr></table></figure><h3 id="更多-2"><a href="#更多-2" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/update.html">更多</a></h3><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><ul><li>以查询到记录为基础</li><li>删除的记录不存在不会报 error</li></ul><h3 id="删除一条记录"><a href="#删除一条记录" class="headerlink" title="删除一条记录"></a>删除一条记录</h3><p>删除一条记录时，删除对象需要指定主键，否则会触发批量删除<br><strong>注</strong>：删除的记录不存在不会报 error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">// DELETE from users where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;user)</span><br><span class="line"><span class="comment">// DELETE from users where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><p>GORM 允许通过主键和内联条件来删除对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联条件</span></span><br><span class="line">db.Delete(&amp;user&#123;&#125;, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE from users where name LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE from users where name LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure><h4 id="阻止全局删除"><a href="#阻止全局删除" class="headerlink" title="阻止全局删除"></a>阻止全局删除</h4><p>当你试图执行不带任何条件的批量删除时，GORM 将不会运行并返回<code>ErrMissingWhereClause</code> 错误<br>如果一定要这么做，你必须添加一些条件，或者使用原生 SQL，或者开启<code>AllowGlobalUpdate</code> 模式，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;).Error</span><br><span class="line"><span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要主键值</span></span><br><span class="line">db.Delete(&amp;[]User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;&#125;).Error</span><br><span class="line"><span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;1 = 1&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE 1=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">db.Exec(<span class="string">&quot;DELETE FROM users&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br><span class="line"></span><br><span class="line">db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="literal">true</span>&#125;).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果你的模型包含了 <code>gorm.DeletedAt</code> 字段（该字段也被包含在 <code>gorm.Model</code> 中），那么该模型将会自动获得软删除的能力<br>当调用 <code>Delete</code> 时，GORM 并不会从数据库中删除该记录，而是将该记录的 <code>DeleteAt</code> 设置为当前时间，而后的一般查询方法将无法查找到此条记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user&#x27;s ID is `111`</span></span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软删除的记录在查询时会被忽略</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br></pre></td></tr></table></figure><p>如果你并不想嵌套 <code>gorm.Model</code>，你也可以像下方例子那样开启软删除特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Deleted gorm.DeletedAt</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找被软删除的记录"><a href="#查找被软删除的记录" class="headerlink" title="查找被软删除的记录"></a>查找被软删除的记录</h4><p>你可以使用 <code>Unscoped</code> 来查询到被软删除的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h4><p>你可以使用 <code>Unscoped</code> 来永久删除匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user&#x27;s ID is `10`</span></span><br><span class="line">db.Unscoped().Delete(&amp;user)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id=10;</span></span><br></pre></td></tr></table></figure><h3 id="更多-3"><a href="#更多-3" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/delete.html">更多</a></h3>]]></content>
    
    
    <summary type="html">精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gorm（MySQL）</summary>
    
    
    
    <category term="Go Web" scheme="https://lonesome.cn/categories/go-web/"/>
    
    
    <category term="Go" scheme="https://lonesome.cn/tags/Go/"/>
    
    <category term="Gorm" scheme="https://lonesome.cn/tags/Gorm/"/>
    
  </entry>
  
  <entry>
    <title>Gin 简易教程</title>
    <link href="https://lonesome.cn/posts/gin-simple-tutorial/"/>
    <id>https://lonesome.cn/posts/gin-simple-tutorial/</id>
    <published>2023-08-13T01:30:00.000Z</published>
    <updated>2024-08-11T12:53:23.545Z</updated>
    
    <content type="html"><![CDATA[<p>精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gin 框架<br><a href="https://www.bilibili.com/video/BV1o841197jX/?share_source=copy_web&vd_source=220eb9848825e3e6c13414db26a32f45">B 站授课链接点击此处</a></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="Go-内置的-net-http-包"><a href="#Go-内置的-net-http-包" class="headerlink" title="Go 内置的 net&#x2F;http 包"></a>Go 内置的 net&#x2F;http 包</h3><ul><li>Go 语言内置的 net&#x2F;http 包十分优秀，提供了 HTTP 客户端和服务端的实现</li><li>这里使用 Go 语言中的 net&#x2F;http 包来编写一个简单的接收 HTTP 请求的服务端（后端）示例，具体的代码如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 函数是需要我们自己实现的一个函数，它有两个规定的参数</span></span><br><span class="line"><span class="comment">// 第一个参数用于给前端的响应（Response）写入数据，响应想要返回什么，就往这个参数里面写什么</span></span><br><span class="line"><span class="comment">// 第二个参数用于获取前端发送的请求（Request）</span></span><br><span class="line"><span class="comment">// Web 开发的本质就是一个请求对应一个响应的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// fmt 包中的 Fprintln 函数是一个简单的可以往 w 里写东西的函数</span></span><br><span class="line">    <span class="comment">// 使用 Fprintln 函数将 &quot;Hello 精弘!&quot; 这句话以纯文本的形式写进 w 后返回给前端</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;Hello 精弘!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// HandleFunc 函数接受两个参数，第一个是路径，即前端请求的 URL，另一个是回调函数，用于处理前端发送的请求</span></span><br><span class="line">    <span class="comment">// HandleFunc 函数是一个设置路由的函数，它的作用是将前端对 /hello 路径的请求映射到 SayHello 函数</span></span><br><span class="line">    <span class="comment">// 当前端访问 /hello 路径的时候，就去执行 SayHello 的函数，往响应写入 &quot;Hello 精弘!&quot; 后返回给前端</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, SayHello)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListenAndServe 函数用于启动服务（Serve）并监听（Listen），接收两个参数</span></span><br><span class="line">    <span class="comment">// 第一个参数是 ip:port 格式的 string 参数，给 /hello 路径确定访问它的 ip 地址和端口号</span></span><br><span class="line">    <span class="comment">// 第二个参数指的是处理 HTTP 请求的处理器，填入nil表示使用默认的处理器</span></span><br><span class="line">    <span class="comment">// &quot;:8080&quot; 是简写，省略了 ip，默认为本机的所有 ip 如 127.0.0.1 就是其中一个，端口号指定为 8080</span></span><br><span class="line">    <span class="comment">// 在浏览器（前端）访问 127.0.0.1:8080/hello 就可以看到 SayHello 函数做出的响应了</span></span><br><span class="line">    <span class="comment">// 另外有一个 err 参数，如果端口被占用或者启动失败会返回错误，正常启动则返回 nil，即空（没有错误）</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理，如果错误不为 nil 则在终端打印错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;http server failed, err:%v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译运行后，在浏览器的地址栏中输入<code>127.0.0.1:8080/hello</code>后回车，就能够看到如下页面：<br><img src="https://img.lonesome.cn/blog/go-web/Nyw4d2eA.webp"></p><h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><ul><li>什么是 Web 框架<ul><li>用于进行 Web 开发的一套软件架构</li><li>为 Web 应用程序提供了基础的功能</li></ul></li><li>优点<ul><li>可以利用它更容易、方便、快速的做一些事情</li></ul></li><li>缺点<ul><li>作为一套体系，它会有一些自己的规定或约束，不可能百分百的满足你的需求</li></ul></li><li>为什么要用 Web 框架<ul><li>如果从零开始，利用 Go 的基础库去搭建，过程会很繁琐</li></ul></li><li>主要作用<ul><li>简化应用开发</li><li>在 Web 框架的基础上实现自己的业务逻辑</li><li>框架提供基础功能</li><li>只需要专注应用的业务逻辑</li></ul></li></ul><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Gin 是 Go 世界里最流行的一个 Web 框架，Github 上有 69K+ star，封装比较优雅，API 友好，源码注释比较明确，  是一个简单易用的轻量级框架，并且<a href="https://gin-gonic.com/zh-cn/">中文文档</a>齐全。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、先初始化当前文件夹（如果没有初始化）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init `name`</span><br></pre></td></tr></table></figure><p>2、下载并安装 Gin<br>go get 是 go 安装软件包的下载命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>将上节课的代码用 Gin 框架来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 gin 引入到代码中</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 函数是一个处理 HTTP 请求的回调函数</span></span><br><span class="line"><span class="comment">// 接受一个 gin 封装过的规定参数，即上下文对象 Context，它是所有请求处理器（处理请求的函数或方法）的入口参数</span></span><br><span class="line"><span class="comment">// Context 包含了 Request 和 ResponseWriter 两个参数，用于获取前端请求信息和返回响应</span></span><br><span class="line"><span class="comment">// 本质上是对于 Request 和 Response 的封装，提供了丰富的方法用于获取当前请求的上下文信息以及返回响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 200 表示 HTTP 响应状态码（&lt;=&gt; http.StatusOK）</span></span><br><span class="line">    <span class="comment">// 使用 Context 的 String 函数将 &quot;Hello 精弘!&quot; 这句话以纯文本（字符串）的形式返回给前端</span></span><br><span class="line">    <span class="comment">// 实际上是对返回响应的封装</span></span><br><span class="line">    c.String(<span class="number">200</span>, <span class="string">&quot;Hello 精弘!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// gin.Default 函数会生成一个默认的 Engine（路由引擎）对象（集成了 Logger 和 Recovery 两个中间件，中间件后面的课会讲）</span></span><br><span class="line">    <span class="comment">// 变量名 r 是 router（路由）的一个简写</span></span><br><span class="line">    <span class="comment">// Engine 是 Gin 框架最重要的数据结构，它是 Gin 框架的入口，本质上是一个 Http Handler</span></span><br><span class="line">    <span class="comment">// 它是一个用于处理 HTTP 请求的对象，维护了一张路由表，将不同的 HTTP 请求路径映射到不同的处理函数上</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r.GET 函数接受两个参数，一个是路径，即前端请求的 URL，另一个是回调函数，用于处理前端发送的请求</span></span><br><span class="line">    <span class="comment">// r.GET 函数将 /hello 路径添加到了 r 的路由表中，将对 /hello 路径的 GET 请求映射到 SayHello 函数上</span></span><br><span class="line">    <span class="comment">// 表示前端给后端的 /hello 路由发送一个 HTTP 的 GET 请求时</span></span><br><span class="line">    <span class="comment">// 后端会执行后面的 SayHello 函数，对前端的请求做出一个响应，给前端返回一个 &quot;Hello 精弘!&quot; 的字符串</span></span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, SayHello)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务并监听,只接受一个 ip:port 格式的 string 参数，表示服务运行的 ip 地址和端口号</span></span><br><span class="line">    <span class="comment">// &quot;:8080&quot; 是简写，省略了 ip，表示监听本地所有 ip （如 127.0.0.1）的 8080 端口，接收并处理 HTTP 请求</span></span><br><span class="line">    <span class="comment">// 在浏览器（前端）访问 127.0.0.1:8080/hello 就可以看到 SayHello 函数做出的响应</span></span><br><span class="line">    <span class="comment">// 等价于 r.Run()，将 port 端口也省略，默认为 8080 端口</span></span><br><span class="line">    err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理，如果错误不为 nil 则在终端打印错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;http server failed, err:%v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译运行后，在浏览器的地址栏中输入<code>127.0.0.1:8080/hello</code>后回车，就能够看到和上节一样的页面：<br><img src="https://img.lonesome.cn/blog/go-web/Nyw4d2eA.webp"></p><ul><li><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码</a><ul><li>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求，当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求</li><li>常见的 HTTP 状态码<ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它 URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul></li></ul></li></ul><h2 id="响应返回-JSON"><a href="#响应返回-JSON" class="headerlink" title="响应返回 JSON"></a>响应返回 JSON</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.String(<span class="number">200</span>, <span class="string">&quot;Hello 精弘!&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>上节课我们讲的是 c.String 给前端返回一个字符串，但在实际的前后端分离的开发过程中，直接使用 string 进行前后端数据传输并不便利，所以我们往往会选择使用 JSON 的数据格式进行前后端的数据传输</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul><li>JSON 数据类型<ul><li>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式，用它可以来表示各种各样复杂的数据，如对象，数组，集合，以及集合的集合等数据</li><li>JSON 实际上就是一串字符串，只不过元素会使用特定的符号标注。 {} 双括号表示对象，[] 中括号表示数组，”” 双引号内是属性或值，: 冒号表示后者是前者的值(这个值可以是字符串、数字、也可以是另一个数组或对象)。</li></ul></li><li>一些常见的 JSON 格式<ul><li>一个 JSON 对象——JSONObject<ul><li><code>&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3&#125;</code></li><li><code>&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3，&quot;address&quot;:&#123;&quot;city&quot;:HangZhou&quot;, &quot;country&quot;:&quot;China&quot;&#125;&#125;</code></li></ul></li><li>一个 JSON 数组——JSONArray<ul><li><code>[&quot;XiMo&quot;, &quot;惜寞&quot;]</code></li><li><code>[&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3&#125;, &#123;&quot;name&quot;:&quot;惜寞&quot;, &quot;age&quot;:4&#125;]</code></li><li><code>[&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3, &quot;address&quot;:&#123;&quot;city&quot;:&quot;HangZhou&quot;, &quot;country&quot;:&quot;China&quot;&#125;&#125;, &#123;&quot;name&quot;:&quot;惜寞&quot;, &quot;age&quot;: 4, &quot;address&quot;:&#123;&quot;city&quot;:&quot;JiaXing&quot;, &quot;country&quot;:&quot;China&quot;&#125;&#125;]</code></li></ul></li><li>可以通过<a href="http://www.esjson.com/jsonviewer.html">可视化</a>将 JSON 数据类型格式化来查看，结构清晰，并且内容相同，字符串形式只是将空格回车给去掉了而已</li><li>当然，数组可以包含对象，在对象中也可以包含数组</li></ul></li><li>为什么普遍选择 JSON 用于前后端数据的传输<ul><li>采用完全独立于任何程序语言的文本格式，使 JSON 成为理想的数据交换语言</li><li>易于人阅读和编写，键值对类型的数据结构具有良好的可读性</li><li>数据格式比较简单, 格式都是压缩的，占用带宽小，能有效地提升网络传输效率</li><li>易于解析，前端可以很方便的进行 JSON 数据的读取</li><li>JSON 格式能够直接为后端代码使用，大大简化了前后端的代码开发量，但是完成的任务不变，且易于维护</li></ul></li></ul><p>和返回 string 一样，Gin 在 Context 里面也给我们封装了返回 JSON 的方法，下面是一个简单的 Gin 返回 JSON 的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Json</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.使用结构体，可以灵活利用 tag 对字段进行&quot;换名&quot;</span></span><br><span class="line">    <span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name     <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">        Age      <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">        Password <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 忽略该字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user := UserInfo&#123;</span><br><span class="line">        Name:     <span class="string">&quot;XiMo&quot;</span>,</span><br><span class="line">        Age:      <span class="number">3</span>,</span><br><span class="line">        Password: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.JSON 实际上是将结构体和 map 类型的变量进行序列化（将对象转换为JSON格式的字符串的过程）</span></span><br><span class="line">    <span class="comment">// 注意 UserInfo.Name 在序列化中变成了 &quot;username&quot;，UserInfo.Age 变成了 &quot;age&quot;</span></span><br><span class="line">    <span class="comment">// &quot;-&quot; 表示忽略该字段，所以 UserInfo.Password 在序列化的时候会被忽略</span></span><br><span class="line">    <span class="comment">// 响应将返回：&#123;&quot;username&quot;: &quot;XiMo&quot;, &quot;age&quot;: 3&#125;</span></span><br><span class="line">    c.JSON(<span class="number">200</span>, user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2.使用 map</span></span><br><span class="line">    <span class="comment">// userMap := map[string]any&#123;</span></span><br><span class="line">    <span class="comment">//     &quot;name&quot;: &quot;XiMo&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;age&quot;:  3,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.JSON(200, userMap)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 3.使用 gin.H</span></span><br><span class="line">    <span class="comment">// // gin.H 实际上是 map[string]any 的一种快捷方式</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//     &quot;name&quot;: &quot;XiMo&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;age&quot;:  3,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/json&quot;</span>, Json)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实除了 JSON 和 string 类型的返回，Gin 还给我们提供了响应 XML、YAML、HTML 等的方式，但由于使用较少，所以这里不多涉及，感兴趣的可以自行查阅</p><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><h3 id="Query-查询参数"><a href="#Query-查询参数" class="headerlink" title="Query 查询参数"></a>Query 查询参数</h3><ul><li>Query 参数是在 URL 中的一部分，用于向服务器发送额外的数据，由键值对组成，以 <code>?</code> 为起始符号，键值对之间使用 <code>&amp;</code> 分隔，例如：<code>/user/search?name=XiMo&amp;age=3</code></li><li>Query 参数常用于 HTTP GET 请求</li><li>常见的地方有搜索（浏览器等等）<br><img src="https://img.lonesome.cn/blog/go-web/fksrMZry.webp"></li></ul><p>Gin 里面给我们封装的 Context 参数提供了丰富的方法帮我们获取 Query 参数</p><table><thead><tr><th>Query 方法</th><th>说明</th></tr></thead><tbody><tr><td>Query</td><td>获取 key 对应的值，不存在返回空字符串</td></tr><tr><td>DefaultQuery</td><td>key 不存在时返回一个默认值</td></tr><tr><td>GetQuery</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryArray</td><td>获取 key 对应的值，值是一个字符串数组，不存在返回空字符串数组</td></tr><tr><td>GetQueryArray</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，不存在返回空</td></tr><tr><td>GetQueryMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，并且返回 bool 标识，标识成功或者失败</td></tr></tbody></table><p>需要注意的是通过 Query 获取到的参数都是 string 类型</p><p>下面是一些代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 访问 /query?name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// Query 获取key对应的值，不存在返回空字符串</span></span><br><span class="line">    nameQuery := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    ageQuery := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    sexQuery := c.Query(<span class="string">&quot;sex&quot;</span>)</span><br><span class="line">    organizationQuery := c.Query(<span class="string">&quot;organization&quot;</span>)</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;nameQuery&quot;</span>:         nameQuery,</span><br><span class="line">        <span class="string">&quot;ageQuery&quot;</span>:          ageQuery,</span><br><span class="line">        <span class="string">&quot;sexQuery&quot;</span>:          sexQuery,</span><br><span class="line">        <span class="string">&quot;organizationQuery&quot;</span>: organizationQuery,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// // DefaultQuery key不存在时返回一个默认值</span></span><br><span class="line">    <span class="comment">// organizationDefaultQuery := c.DefaultQuery(&quot;organization&quot;, &quot;精弘网络&quot;)</span></span><br><span class="line">    <span class="comment">// sexDefaultQuery := c.DefaultQuery(&quot;sex&quot;, &quot;male&quot;)</span></span><br><span class="line">    <span class="comment">// nameDefaultQuery := c.DefaultQuery(&quot;name&quot;, &quot;惜寞&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;organizationDefaultQuery&quot;: organizationDefaultQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;sexDefaultQuery&quot;:          sexDefaultQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;nameDefaultQuery&quot;:         nameDefaultQuery,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// // GetQuery 获取key对应的值，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// nameGetQuery, nameExist := c.GetQuery(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetQuery, sexExist := c.GetQuery(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetQuery, orgaorganizationExist := c.GetQuery(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetQuery&quot;:          nameGetQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:             nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetQuery&quot;:           sexGetQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:              sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetQuery&quot;:  organizationGetQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;: orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// // QueryArray</span></span><br><span class="line">    <span class="comment">// hobbyQuery := c.Query(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// hobbyQueryArray := c.QueryArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// nameQueryArray := c.QueryArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexQueryArray := c.QueryArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationQueryArray := c.QueryArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyQuery&quot;:             hobbyQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyQueryArray&quot;:        hobbyQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;nameQueryArray&quot;:         nameQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexQueryArray&quot;:          sexQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationQueryArray&quot;: organizationQueryArray,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// // GetQueryArray</span></span><br><span class="line">    <span class="comment">// hobbyGetQueryArray, hobbyExist := c.GetQueryArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// nameGetQueryArray, nameExist := c.GetQueryArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetQueryArray, sexExist := c.GetQueryArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetQueryArray, orgaorganizationExist := c.GetQueryArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyGetQueryArray&quot;:        hobbyGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyExist&quot;:                hobbyExist,</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetQueryArray: &quot;:       nameGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:                 nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetQueryArray&quot;:          sexGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:                  sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetQueryArray&quot;: organizationGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;:     orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// // QueryMap</span></span><br><span class="line">    <span class="comment">// userQueryMap := c.QueryMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminQueryMap := c.QueryMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userQueryMap&quot;:  userQueryMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminQueryMap&quot;: adminQueryMap,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// // GetQueryMap</span></span><br><span class="line">    <span class="comment">// userGetQueryMap, userExist := c.GetQueryMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminGetQueryMap, adminExist := c.GetQueryMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userGetQueryMap&quot;:  userGetQueryMap,</span></span><br><span class="line">    <span class="comment">//  &quot;userExist&quot;:        userExist,</span></span><br><span class="line">    <span class="comment">//  &quot;adminGetQueryMap&quot;: adminGetQueryMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminExist&quot;:       adminExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/query&quot;</span>, Query)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Param-动态参数"><a href="#Param-动态参数" class="headerlink" title="Param 动态参数"></a>Param 动态参数</h3><ul><li>Param 参数获取到的数据类型也是 string 类型</li><li>路由形式一般写成 <code>/user/:name/:age</code>，这里的 <code>:</code> 表示后面的参数是一个占位符</li><li>请求的参数可以通过 URL 路径传递，<code>name</code> 和 <code>age</code> 可以通过访问 <code>/user/XiMo/3</code> 这个路由去获取 <code>XiMo</code> 和 <code>3</code> ，访问 <code>/user/惜寞/4</code> 可以获取 <code>惜寞</code> 和 <code>4</code></li></ul><p>Gin 给我们提供了 Param 方法去获取这些参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意会匹配 /param/XiMo 但不会匹配 /param/ 或者 /param</span></span><br><span class="line">    r.GET(<span class="string">&quot;/param/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 访问 /param/XiMo</span></span><br><span class="line">        name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在会返回空字符串</span></span><br><span class="line">        age := c.Param(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:  age,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostForm-表单参数"><a href="#PostForm-表单参数" class="headerlink" title="PostForm 表单参数"></a>PostForm 表单参数</h3><ul><li>和 Query 很像，不同之处在于数据不通过 URL 来传递，而是处于请求的主体当中</li><li>表单参数常用于 POST 请求中</li></ul><p>Gin 提供的 PostForm 函数与 Query 基本上一一对应的，具体情况见下表：</p><table><thead><tr><th>Query 方法</th><th>PostForm 方法</th><th>说明</th></tr></thead><tbody><tr><td>Query</td><td>PostForm</td><td>获取 key 对应的值，不存在返回空字符串</td></tr><tr><td>DefaultQuery</td><td>DefaultPostForm</td><td>key 不存在时返回一个默认值</td></tr><tr><td>GetQuery</td><td>GetPostForm</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryArray</td><td>PostFormArray</td><td>获取 key 对应的值，值是一个字符串数组，不存在返回空字符串数组</td></tr><tr><td>GetQueryArray</td><td>GetPostFormArray</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryMap</td><td>PostFormMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，不存在返回空</td></tr><tr><td>GetQueryMap</td><td>GetPostFomMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，并且返回 bool 标识，标识成功或者失败</td></tr></tbody></table><p>下面是一些代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostForm</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// PostForm 获取key对应的值，不存在返回空字符串</span></span><br><span class="line">    <span class="comment">// name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    namePostForm := c.PostForm(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    agePostForm := c.PostForm(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    sexPostForm := c.PostForm(<span class="string">&quot;sex&quot;</span>)</span><br><span class="line">    organizationPostForm := c.PostForm(<span class="string">&quot;organization&quot;</span>)</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;namePostForm&quot;</span>:         namePostForm,</span><br><span class="line">        <span class="string">&quot;agePostForm&quot;</span>:          agePostForm,</span><br><span class="line">        <span class="string">&quot;sexPostForm&quot;</span>:          sexPostForm,</span><br><span class="line">        <span class="string">&quot;organizationPostForm&quot;</span>: organizationPostForm,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // DefaultPostForm key不存在时返回一个默认值</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// organizationDefaultPostForm := c.DefaultPostForm(&quot;organization&quot;, &quot;精弘网络&quot;)</span></span><br><span class="line">    <span class="comment">// sexDefaultPostForm := c.DefaultPostForm(&quot;sex&quot;, &quot;male&quot;)</span></span><br><span class="line">    <span class="comment">// nameDefaultPostForm := c.DefaultPostForm(&quot;name&quot;, &quot;惜寞&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;organizationPostForm&quot;:        organizationPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationDefaultPostForm&quot;: organizationDefaultPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;sexPostForm&quot;:                 sexPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;sexDefaultPostForm&quot;:          sexDefaultPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;namePostForm&quot;:                namePostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;nameDefaultPostForm&quot;:         nameDefaultPostForm,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // GetPostForm 获取key对应的值，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// nameGetPostForm, nameExist := c.GetPostForm(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetPostForm, sexExist := c.GetPostForm(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetPostForm, orgaorganizationExist := c.GetPostForm(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetPostForm&quot;:         nameGetPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:               nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetPostForm&quot;:          sexGetPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:                sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetPostForm&quot;: organizationGetPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;:   orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // PostFormArray 获取key对应的值，值是一个字符串数组，不存在返回空字符串数组</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// hobbyPostForm := c.PostForm(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// hobbyPostFormArray := c.PostFormArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// namePostFormArray := c.PostFormArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexPostFormArray := c.PostFormArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationPostFormArray := c.PostFormArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyPostForm&quot;:             hobbyPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyPostFormArray&quot;:        hobbyPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;namePostFormArray&quot;:         namePostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexPostFormArray&quot;:          sexPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationPostFormArray&quot;: organizationPostFormArray,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // GetPostFormArray 获取key对应的值，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// hobbyGetPostFormArray, hobbyExist := c.GetPostFormArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// nameGetPostFormArray, nameExist := c.GetPostFormArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetPostFormArray, sexExist := c.GetPostFormArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetPostFormArray, orgaorganizationExist := c.GetPostFormArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyGetPostFormArray&quot;:        hobbyGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyExist&quot;:                   hobbyExist,</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetPostFormArray: &quot;:       nameGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:                    nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetPostFormArray&quot;:          sexGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:                     sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetPostFormArray&quot;: organizationGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;:        orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // PostFormMap 获取key对应的值，值是一个字符串map[string]string，不存在返回空</span></span><br><span class="line">    <span class="comment">// // user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// userPostFormMap := c.PostFormMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminPostFormMap := c.PostFormMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userPostFormMap&quot;:  userPostFormMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminPostFormMap&quot;: adminPostFormMap,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // GetPostFormMap 获取key对应的值，值是一个字符串map[string]string，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// // user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// userGetPostFormMap, userExist := c.GetPostFormMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminGetPostFormMap, adminExist := c.GetPostFormMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userGetPostFormMap&quot;:  userGetPostFormMap,</span></span><br><span class="line">    <span class="comment">//  &quot;userExist&quot;:           userExist,</span></span><br><span class="line">    <span class="comment">//  &quot;adminGetPostFormMap&quot;: adminGetPostFormMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminExist&quot;:          adminExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/post-form&quot;</span>, PostForm)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetRawData-原始参数"><a href="#GetRawData-原始参数" class="headerlink" title="GetRawData 原始参数"></a>GetRawData 原始参数</h3><p>我们如果想去获取前端传来的 JSON 数据类型就需要用到这个方法，但是实际上 Gin 帮我们封装了一种更简便的方式（参数绑定里的 ShouldBindJSON 方法），所以这个方法我们很少会用到，因此不专门去讲，有兴趣了解的可以看看</p><p>利用 GetRawData 方法可以获取请求体中 body 的内容，我们也是通过这种方式来获取前端给我们传来的 JSON 数据，但实际上通过这个方法我们不仅仅是可以获取 JSON ，还可以获取很多别的一些数据类型像是 xml、html 等等，这里我们仅仅是用获取 JSON 数据为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Raw</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// GetRawData 实际上是去获取 request.body 中的内容</span></span><br><span class="line">    <span class="comment">// 它返回两个参数，一个是获取到的 []byte 类型的 body 数据，另一个是 error 类型</span></span><br><span class="line">    <span class="comment">// 这里忽略了 error 的处理</span></span><br><span class="line">    data, _ := c.GetRawData()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 data 可以看到传过来的原始数据</span></span><br><span class="line">    fmt.Println(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 []byte 转成 string 类型可以看它实际传过来的内容</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：下面是对 JSON 数据类型的处理</span></span><br><span class="line">    <span class="comment">// 我们可以通过 json 包里的 Unmarshal 来对 JSON 数据类型进行反序列化</span></span><br><span class="line">    <span class="comment">// 就是我前几节课所说的用 JSON 中的数据去给结构体和 map 类型变量赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.结构体，tag 在反序列化的时候依旧可用，会根据 tag 将对应的值赋给对应的键</span></span><br><span class="line">    <span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">        Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">        Sex  <span class="type">string</span> <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userStruct UserInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 反序列化，会返回一个 error，这里忽略了对其的处理</span></span><br><span class="line">    _ = json.Unmarshal(data, &amp;userStruct)</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, userStruct)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2.map</span></span><br><span class="line">    <span class="comment">// var userMap map[string]interface&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _ = json.Unmarshal(data, &amp;userMap)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //获取 JSON 中的 key，注意使用 [&quot;key&quot;] 获取</span></span><br><span class="line">    <span class="comment">// // name := userMap[&quot;name&quot;]</span></span><br><span class="line">    <span class="comment">// // age := userMap[&quot;age&quot;]</span></span><br><span class="line">    <span class="comment">// // sex := userMap[&quot;sex&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.JSON(200, userMap)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/raw&quot;</span>, Raw)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的代码运行起来，然后可以利用 apifox 新建一个快捷请求去查看效果：<br><img src="https://img.lonesome.cn/blog/go-web/IsmjGIUz.webp"></p><p>发送请求后的结果如下：<br><img src="https://img.lonesome.cn/blog/go-web/1yu5vlul.webp"></p><p>说明我们成功的收到了前端传来的 JSON 参数并且解析到了我们的结构体和 map 上，并将其响应返回给了前端</p><h3 id="Bind-参数绑定"><a href="#Bind-参数绑定" class="headerlink" title="Bind 参数绑定"></a>Bind 参数绑定</h3><p>下面是 Gin 的官方文档给出的介绍：<br>Gin 提供了两类绑定方法：</p><ul><li><strong>Type</strong> - Must bind<ul><li><strong>Methods</strong> - <code>Bind</code>, <code>BindJSON</code>, <code>BindXML</code>, <code>BindQuery</code>, <code>BindYAML</code></li><li><strong>Behavior</strong> - 这些方法属于  <code>MustBindWith</code>  的具体调用。 如果发生绑定错误，则请求终止，并触发  <code>c.AbortWithError(400, err).SetType(ErrorTypeBind)</code>。响应状态码被设置为 400 并且  <code>Content-Type</code>  被设置为  <code>text/plain; charset=utf-8</code>。 如果您在此之后尝试设置响应状态码，Gin 会输出日志  <code>[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422</code>。 如果您希望更好地控制绑定，考虑使用  <code>ShouldBind</code>  等效方法。</li></ul></li><li><strong>Type</strong> - Should bind<ul><li><strong>Methods</strong> - <code>ShouldBind</code>, <code>ShouldBindJSON</code>, <code>ShouldBindXML</code>, <code>ShouldBindQuery</code>, <code>ShouldBindYAML</code></li><li><strong>Behavior</strong> - 这些方法属于  <code>ShouldBindWith</code>  的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。</li></ul></li></ul><p>使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用  <code>MustBindWith</code>  或  <code>ShouldBindWith</code>。</p><p>你也可以指定必须绑定的字段。 如果一个字段的 tag 加上了  <code>binding:&quot;required&quot;</code>，但绑定时是空值, Gin 会报错。</p><ul><li>我们一般不会使用 Must Bind 相关的绑定方法，因为绑定一旦发生错误，就会修改你的响应状态码，不便于你对绑定状态的控制</li><li>通常使用 Should Bind 方法，发生绑定错误可以自由进行处理</li></ul><p>简单来说：<br>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的 <code>Content-Type</code> 识别请求数据类型并利用反射机制自动提取请求中 <code>Query</code>、<code>Param</code>、<code>Form</code>、<code>JSON</code> 等参数到结构体中。 下面的示例代码演示了 <code>ShouldBind()</code> 强大的功能，它能够基于请求自动提取相应类型的数据，并把值绑定到指定的结构体对象中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`form:&quot;name_form&quot; uri:&quot;name_uri&quot; json:&quot;name_form&quot; binding:&quot;required&quot;`</span> <span class="comment">// binding:&quot;required&quot; tag 表示该属性值不能为空</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`form:&quot;age_form&quot; uri:&quot;age_uri&quot; json:&quot;age_form&quot;`</span></span><br><span class="line">    Sex  <span class="type">string</span> <span class="string">`form:&quot;sex_form&quot; uri:&quot;sex&quot; json:&quot;sex_form&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag form</span></span><br><span class="line">    <span class="comment">// 绑定 Query 示例</span></span><br><span class="line">    <span class="comment">// 1. /query?name_form=ximo&amp;age_form=3&amp;sex_form=male 正常响应</span></span><br><span class="line">    <span class="comment">// 2. /query?name_form=ximo&amp;age_form=3&amp;sex_form= 或 /query?name_form=ximo&amp;age_form=3 正常响应</span></span><br><span class="line">    <span class="comment">// 3. /query?age_form=3&amp;sex_form=male 或 /query?name_form=&amp;age_form=3&amp;sex_form=male 返回 error，binding:&quot;required&quot; tag 表示 Name 属性值不能为空</span></span><br><span class="line">    r.GET(<span class="string">&quot;/query&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据请求的 Content-type 自动识别请求数据类型并利用反射机制自动提取请求中的参数到结构体中</span></span><br><span class="line">        <span class="comment">// 会返回一个 error 参数</span></span><br><span class="line">        err := c.ShouldBind(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag uri</span></span><br><span class="line">    <span class="comment">// 绑定 Param 的示例 /param/ximo/3/male</span></span><br><span class="line">    r.POST(<span class="string">&quot;/param/:name_uri/:age_uri/:sex_uri&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Param 比较特殊，不能直接通过 ShouldBind 绑定</span></span><br><span class="line">        err := c.ShouldBindUri(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag json</span></span><br><span class="line">    <span class="comment">// 绑定 JSON 的示例</span></span><br><span class="line">    <span class="comment">// 1. &#123;&quot;user_json&quot;: &quot;ximo&quot;, &quot;age_json&quot;: 3, &quot;sex_json&quot;: male&#125; 正常响应</span></span><br><span class="line">    <span class="comment">// 2. &#123;&quot;user_json&quot;: &quot;ximo&quot;, &quot;age_json&quot;: 3&#125; 或 &#123;&quot;user_json&quot;: &quot;ximo&quot;, &quot;age_json&quot;: 3, &quot;sex_json&quot;:&quot;&quot;&#125; 正常响应</span></span><br><span class="line">    <span class="comment">// 3. &#123;&quot;age_json&quot;: 3, &quot;sex_json&quot;: male&#125; 或 &#123;&quot;user_json&quot;: &quot;&quot;, &quot;age_json&quot;: 3, &quot;sex_json&quot;: male&#125;返回 error，binding:&quot;required&quot; tag 表示 Name 属性值不能为空</span></span><br><span class="line">    r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        err := c.ShouldBind(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag form（和 Query 相同）</span></span><br><span class="line">    <span class="comment">// 绑定 form 表单示例</span></span><br><span class="line">    <span class="comment">// 1. name_form=ximo&amp;age_form=3&amp;sex_form=male 正常响应</span></span><br><span class="line">    <span class="comment">// 2. name_form=ximo&amp;age_form=3&amp;sex_form= 或 name_form=ximo&amp;age_form=3 正常响应</span></span><br><span class="line">    <span class="comment">// 3. age_form=3&amp;sex_form=male 或 name_form=&amp;age_form=3&amp;sex_form=male 返回 error，binding:&quot;required&quot; tag 表示 Name 属性值不能为空</span></span><br><span class="line">    r.POST(<span class="string">&quot;/post-form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        err := c.ShouldBind(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Should Bind</code> 会按照下面的顺序解析请求中的数据完成绑定：</p><ul><li><ol><li>如果是  <code>GET</code>  请求，只使用  <code>Form</code>  绑定（<code>query</code>）</li></ol></li><li><ol start="2"><li>其他请求，根据  <code>Content-Type</code>  自动识别对应类型，匹配不上会默认使用  <code>Form</code>（<code>form-data</code>）</li></ol></li></ul></li><li><p>如果你明确知道要绑定什么数据类型，推荐直接使用 <code>ShouldBindWith</code></p></li><li><p>比如你明确接收到的是一个 JSON 数据，就可以使用</p><ul><li><code>ShouldBindWith(&amp;user, binding.JSON)</code></li><li>或者 <code>ShouldBindJSON(&amp;user)</code> （实际上是上面方法的缩写，通常写这个）</li></ul></li></ul><p>我们主要知道如何用 ShouldBindJSON 去获取前端发送过来的 JSON 数据就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot; binding:&quot;required&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Sex  <span class="type">string</span> <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定 JSON，接收前端发送过来的 JSON 数据</span></span><br><span class="line">        err := c.ShouldBindJSON(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在 Gin 中，路由是指将 HTTP 请求映射到相应的处理函数的机制</p><h3 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br><span class="line">r.PUT(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br><span class="line">r.DELETE(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>Any</code> 方法<ul><li>可以匹配所有 HTTP 请求</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Any(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>NoRoute</code>  方法<ul><li>用于处理找不到路由的情况，即当没有匹配到任何定义的路由时执行的处理函数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>NoMethod</code> 方法<ul><li>用于处理请求的 HTTP 方法不被允许的情况，即当请求的 HTTP 方法与路由定义的方法不匹配时执行的处理函数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.NoMethod(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/path/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;) <span class="comment">// 匹配带有 id 参数的GET请求</span></span><br><span class="line">r.GET(<span class="string">&quot;/path/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;) <span class="comment">// 匹配任意路径的 GET 请求，只要是以 /path 开头</span></span><br></pre></td></tr></table></figure><p>通过参数路由，可以根据不同的参数值生成不同的 URL，实现对不同资源的访问。</p><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>我们可以将拥有共同 URL 前缀的路由划分为一个路由组，习惯性一对 <code>&#123;&#125;</code> 包裹同组的路由，这只是为了看着清晰，用不用 <code>&#123;&#125;</code> 包裹功能上没什么区别<br>通常将路由分组用在划分业务逻辑或划分 API 版本时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        user.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">admin := r.Group(<span class="string">&quot;/admin&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        admin.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        admin.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        admin.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>路由组支持嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 路由组嵌套</span></span><br><span class="line">        login := user.Group(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            login.POST(<span class="string">&quot;/email&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">            login.POST(<span class="string">&quot;/phone&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">            login.POST(<span class="string">&quot;/password&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实可以类比成文件夹</p><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>REST 与技术无关，代表的是一种软件架构风格，REST 是 Representational State Transfer 的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p><p>简单来说，REST 的含义就是客户端（前端）与 Web 服务器（后端）之间进行交互的时候，使用 HTTP 协议中的 4 个请求方法代表不同的动作。</p><ul><li><code>GET</code> 用来获取资源</li><li><code>POST</code> 用来新建资源</li><li><code>PUT</code> 用来更新资源</li><li><code>DELETE</code> 用来删除资源</li></ul><p>只要 API 程序遵循了 REST 风格，那就可以称其为 RESTful API。目前在前后端分离的架构中，前后端基本都是通过 RESTful API 来进行交互。</p><p>例如，我们现在要编写一个管理外卖订单的系统，对一个订单进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们 Web 服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;order</td><td>查询订单信息</td></tr><tr><td>POST</td><td>&#x2F;create_order</td><td>创建订单</td></tr><tr><td>POST</td><td>&#x2F;update_order</td><td>更新订单信息</td></tr><tr><td>POST</td><td>&#x2F;delete_order</td><td>删除订单</td></tr></tbody></table><p>同样的需求我们按照 RESTful API 设计如下：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;order</td><td>查询订单信息</td></tr><tr><td>POST</td><td>&#x2F;order</td><td>创建订单</td></tr><tr><td>PUT</td><td>&#x2F;order</td><td>更新订单信息</td></tr><tr><td>DELETE</td><td>&#x2F;order</td><td>删除订单</td></tr></tbody></table><p>Gin 框架支持开发 RESTful API 的开发。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 对订单进行增删改查的操作</span></span><br><span class="line">    <span class="comment">// 可能的写法</span></span><br><span class="line">    r.GET(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/create_order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/update_order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/delete_order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// RESRful API 风格</span></span><br><span class="line">    r.GET(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    r.PUT(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    r.DELETE(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Gin 框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如<strong>登录认证、权限校验、数据分页、记录日志、耗时统计</strong>等。<br>中间件本质上是一个 handler，可以作用在单路由、路由组和全局的 Engine。</p><h3 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h3><ul><li>Gin 中的中间件必须是一个 <code>gin.HandlerFunc</code> 类型，其实和我们的处理函数是同样的类型。</li><li>下面其实就是一个中间件，只不过没有什么实际的作用：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;这是一个中间件&quot;</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 中间件也可以返回响应</span></span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;中间件&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把它注册到我们的路由当中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 m1 作为一个中间件注册到该路由</span></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, m1, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;这是处理函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;处理函数&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实际上访问 127.0.0.1:8080&#x2F; 的时候会返次两个响应，但是我们基本不会这么写，一次请求对应多次响应是不准确也是不安全的，仅仅是用来做一个示例</li><li>根据打印和响应我们也可以发现执行顺序是中间件在处理函数之前</li></ul><h4 id="Abort-和-Next"><a href="#Abort-和-Next" class="headerlink" title="Abort() 和 Next()"></a>Abort() 和 Next()</h4><ul><li><code>Abort()</code><ul><li>会中止当前请求，不执行该语句后面的所有内容，即使后面可能处理函数都没有执行</li><li>注意和 return 不同，return 只结束该函数内的内容，不影响后续函数的执行</li></ul></li><li><code>Next()</code><ul><li>从当前 handler 的调用位置跳到下一个 handler 执行，执行完后续 handler（如果没有再次调用 next ），再返回上一个 next 调用位置继续往下执行</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳到下一个 handler</span></span><br><span class="line">    c.Next()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 out...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m2 in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳到下一个 handler</span></span><br><span class="line">    c.Next()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;m2 out...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, m1, m2, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;/ in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;/ out...&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里写了两个中间件 m1 和 m2，遇到 Next 后会跳转到下一个 Handler</li><li>本质上就是一个函数嵌套调用的过程</li><li><img src="https://img.lonesome.cn/blog/go-web/0866b73a-4d10-4d7d-adcf-7ac6c9483a4f.webp"><br>所以运行后的输出结果为：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m1 in...</span><br><span class="line">m2 in...</span><br><span class="line">/ in...</span><br><span class="line">/ out...</span><br><span class="line">m2 out...</span><br><span class="line">m1 out...</span><br></pre></td></tr></table></figure><p>如果将 m1 中的 <code>c.Next()</code> 换成 <code>c.Abort()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止当前请求，后续函数和代码都不会执行</span></span><br><span class="line">    c.Abort()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m1 in...</span><br></pre></td></tr></table></figure><p>运行到 Abort() 就结束了</p><h4 id="Set-和-Get"><a href="#Set-和-Get" class="headerlink" title="Set() 和 Get()"></a>Set() 和 Get()</h4><ul><li>用于中间件（handler）之间的通信，可以是在 handler 之内，也可以是之间</li><li>因为中间件实际上是不同的函数，在不同的函数之间我们不能直接传递数据，想要传递数据就需要用到 Gin 给我们封装好的 Context 中的 Set 和 Get 方法</li><li><code>Set</code>：用于在请求上下文中设置数据。可以使用 <code>c.Set(key, value)</code> 方法将某个键和对应的值存储到请求上下文中</li><li><code>Get</code>：用于从请求上下文中获取数据。可以使用 <code>c.Get(key)</code> 方法根据键获取在请求上下文中存储的值</li><li>先 Set 再 Get</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    user := UserInfo&#123;</span><br><span class="line">        Name: <span class="string">&quot;XiMo&quot;</span>,</span><br><span class="line">        Age:  <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 user 以键值对的形式存储到 Context 中</span></span><br><span class="line">    c.Set(<span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, m1, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 根据 key 返回 value（any 类型）和一个 bool 值</span></span><br><span class="line">        <span class="comment">// bool 值用来判断是否有这个 key</span></span><br><span class="line">        user, ok := c.Get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        fmt.Println(gin.H&#123;</span><br><span class="line">            <span class="string">&quot;userExist&quot;</span>: ok,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言，会返回断言类型的值和一个 bool 值</span></span><br><span class="line">        <span class="comment">// bool 值用来判断是否断言成功</span></span><br><span class="line">        <span class="comment">// 断言失败，返回的值为断言类型的零值</span></span><br><span class="line">        _user, _ok := user.(UserInfo)</span><br><span class="line">        fmt.Println(gin.H&#123;</span><br><span class="line">            <span class="string">&quot;type assertion&quot;</span>: _ok,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        fmt.Println(_user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="记录接口耗时的中间件"><a href="#记录接口耗时的中间件" class="headerlink" title="记录接口耗时的中间件"></a>记录接口耗时的中间件</h4><p>我们可以写一个中间件用来记录接口耗时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计请求耗时的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatCost</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 请求开始的时间</span></span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">    c.Next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算耗时</span></span><br><span class="line">    cost := time.Since(start)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志形式打印</span></span><br><span class="line">    log.Println(cost)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>在 gin 框架中，我们可以为每个路由添加任意数量的中间件。</p><h4 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册 StatCost 中间件</span></span><br><span class="line">    r.Use(StatCost)</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 停1秒</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello 精弘!&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们之前所讲的 <code>gin.Default()</code> 实际上就默认帮我们注册了两个全局中间件 <code>Logger()</code> 和 <code>Recovery()</code></li><li>如果不想集成这两个中间件可以使用 <code>gin.New()</code> 方法</li></ul><h4 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 / 路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, StatCost, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 停1秒</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello 精弘!&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="为路由组注册中间件"><a href="#为路由组注册中间件" class="headerlink" title="为路由组注册中间件"></a>为路由组注册中间件</h4><p>为路由组注册中间件有以下两种写法。<br>写法 1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>, StatCost)</span><br><span class="line">&#123;</span><br><span class="line">    user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法 2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">user.Use(StatCost)</span><br><span class="line">&#123;</span><br><span class="line">    user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过路由组注册中间件易于定义中间件的使用范围<br>比如我只有 &#x2F;admin 相关的路由需要鉴权，判断是不是管理员，就可以通过路由组的方式去管理，而不需要单个一个个的注册或者全局注册（没有必要给所有路由都加上该中间件）</p>]]></content>
    
    
    <summary type="html">精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gin 框架
</summary>
    
    
    
    <category term="Go Web" scheme="https://lonesome.cn/categories/go-web/"/>
    
    
    <category term="Go" scheme="https://lonesome.cn/tags/Go/"/>
    
    <category term="Gin" scheme="https://lonesome.cn/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse——你没有见过的列存储</title>
    <link href="https://lonesome.cn/posts/clickhouse-column-storage/"/>
    <id>https://lonesome.cn/posts/clickhouse-column-storage/</id>
    <published>2023-02-16T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:23.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><p>数据库是结构化信息或数据的有序集合，一般以电子形式存储在计算机系统中。通常由数据库管理系统(DBMS)来控制。在现实中，数据、DBMS 及关联应用一起被称为数据库系统，通常简称为数据库</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><ul><li>数据解析整理成有序集合<ul><li><img src="https://img.lonesome.cn/blog/bytedance/CEHX_@B7@516RI4I@JRC7.webp"></li></ul></li><li>可以通过查询语言获取想要的信息<ul><li><img src="https://img.lonesome.cn/blog/bytedance/U80QJNAZFK2Q7TR8@_N.webp"></li></ul></li></ul><h3 id="数据库的类型"><a href="#数据库的类型" class="headerlink" title="数据库的类型"></a>数据库的类型</h3><ul><li>数据库有很多种，至于各种数据库孰优孰劣，主要取决于企业希望如何使用数据</li><li>关系数据库：关系型数据库是把数据以表的形式进行储存，然后再各个表之间建立关系，通过这些表之间的关系来操作不同表之间的数据</li><li>非关系数据库  <strong>：</strong> NoSQL 或非关系数据库，支持存储和操作非结构化及半结构化数据。相比于关系型数据库，NoSQL 没有固定的表结构，且数据之间不存在表与表之间的关系，数据之间可以是独立的。NoSQL 的关键是它们放弃了传统关系型数据库的强事务保证和关系模型，通过所谓最终一致性和非关系数据模型（例如键值对，图，文档）来提高 Web 应用所注重的高可用性和可扩展性</li><li>单机数据库：在一台计算机上完成数据的存储和查询的数据库系统</li><li>分布式数据库  <strong>：</strong>  分布式数据库由位于不同站点的两个或多个文件组成。数据库可以存储在多台计算机上，位于同一个物理位置，或分散在不同的网络上</li><li>OLTP 数据库  <strong>：</strong> OLTP（Online transactional processing）数据库是一种高速分析数据库，专为多个用户执行大量事务而设计</li><li>OLAP 数据库：OLAP (Online analytical processing) 数据库旨在同时分析多个数据维度，帮助团队更好地理解其数据中的复杂关系</li></ul><h3 id="OLAP-数据库"><a href="#OLAP-数据库" class="headerlink" title="OLAP 数据库"></a>OLAP 数据库</h3><ul><li>大量数据的读写，PB 级别的存储</li><li>多维分析，复杂的聚合函数</li><li>窗口函数，自定义 UDF (User Define Fucntion)</li><li>离线&#x2F;实时分析</li><li><img src="https://img.lonesome.cn/blog/bytedance/I2R7YO8J9L4AAPTUJF8.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/0XK4AOWRTPHOW1I.webp"></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>一种编程语言，目前几乎所有的关系数据库都使用 SQL (<strong>Structured Query Language</strong> <strong>)</strong>  编程语言来查询、操作和定义数据，进行数据访问控制</li><li>SQL 的结构<ul><li>一个简单的 SQL 查询包含 SELECT 关键词。星号(“*“)也可以用来指定查询应当返回查询表所有字段，可选的关键词和子句</li><li><img src="https://img.lonesome.cn/blog/bytedance/JNWROXOR20AAJZR16N3.webp"><ul><li><code>FROM</code>子句指定了选择的数据表。<code>FROM</code>子句也可以包含<code>JOIN</code>  二层子句来为数据表的连接设置规则</li><li><code>WHERE</code>子句后接一个比较谓词以限制返回的行。<code>WHERE</code>子句仅保留返回结果里使得比较谓词的值为 True 的行</li><li><code>GROUP BY</code>子句用于将若干含有相同值的行合并。 <code>GROUP BY</code>通常与 SQL 聚合函数连用，或者用于清除数据重复的行。<code>GROUP BY</code>子句要用在<code>WHERE</code>子句之后</li><li><code>HAVING</code>子句后接一个谓词来过滤从<code>GROUP BY</code>子句中获得的结果，由于其作用于<code>GROUP BY</code>子句之上，所以聚合函数也可以放到其谓词中</li><li><code>ORDER BY</code>子句指明将哪个字段用作排序关键字，以及排序顺序(升序&#x2F;降序)，如果无此子句，那么返回结果的顺序不能保证有序</li></ul></li></ul></li><li>SQL 的用途<ul><li>定义数据模型<ul><li><img src="https://img.lonesome.cn/blog/bytedance/E5G_9X21_GXMAXTV5BHZIL.webp"></li></ul></li><li>读写数据库数据<ul><li><img src="https://img.lonesome.cn/blog/bytedance/537JP3IHGZSOZFCWUMAP2.webp"></li></ul></li></ul></li><li>SQL 的优点<ul><li>标准化，ISO 和 ANSI 是长期建立使用的 SQL 数据库标准</li><li>高度非过程化，用 SQL 进行数据操作，用户只需提出“做什么”，而不必指明“怎么做”，因此用户无须了解存取路径，存取路径的选择以及 SQL 语句的操作过程由系统自动完成。这不但大大减轻了用户负担，而且有利于提高数据独立性</li><li>以同一种语法结构提供两种使用方式，用户可以在终端上直接输入 SQL 命令对数据库进行操作。作为嵌入式语言，SQL 语句能够嵌入到高级语言（如 C、C#、JAVA）程序中，供程序员设计程序时使用。而在两种不同的使用方式下，SQL 的语法结构基本上是一致的</li><li>语言简洁，易学易用：SQL 功能极强，但由于设计巧妙，语言十分简洁，完成数据定义、数据操纵、数据控制的核心功能只用了 9 个动词：CREATE、ALTER、DROP、SELECT、INSERT、UPDATE、DELETE、GRANT、REVOKE。且 SQL 语言语法简单，接近英语口语，因此容易学习，也容易使用</li></ul></li></ul><h3 id="数据库的架构"><a href="#数据库的架构" class="headerlink" title="数据库的架构"></a>数据库的架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/G2TED_REA98AJAP2CW5.webp"></p><ul><li>SQL 的执行<ul><li>Parser：词法分析，语法分析，生成 AST 树 (Abstract syntax tree)<ul><li><img src="https://img.lonesome.cn/blog/bytedance/25N84EDYOTWW727LHH.webp"></li></ul></li><li>Analyzer：变量绑定、类型推导、语义检查、安全、权限检查、完整性检查等，为生成计划做准备<ul><li>例如：<ul><li>判断 a，b 是不是类型正确</li><li>a，b 是不是来自表 t</li><li>group by 字段是否合法，是否存在聚合函数</li></ul></li></ul></li><li>Optimizer：为查询生成性能最优的执行计划，进行代价评估<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WT8ZRR0AXDQXFBEV_T.webp"></li></ul></li><li>Executor：将执行计划翻译成可执行的物理计划并驱动其执行<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OK49@A74MBVO_K3YU9.webp"></li></ul></li></ul></li><li>存储引擎<ul><li>管理内存数据结构<ul><li>索引</li><li>内存数据</li><li>缓存<ul><li>Query cache</li><li>Data cache</li><li>Index cache</li></ul></li></ul></li><li>管理磁盘数据<ul><li>磁盘数据的文件格式</li><li>磁盘数据的增删查改</li></ul></li><li>读写算子<ul><li>数据写入逻辑</li><li>数据读取逻辑</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/CWGR6ORM38UM1SA1VDQL.webp"></li><li>如何存储数据？<ul><li>是否可以并发处理</li><li>是否可以构建索引</li><li>行存、列存或者行列混合存储</li></ul></li><li>如何读写数据？<ul><li>读多写少</li><li>读少写多</li><li>点查场景</li><li>分析型场景</li></ul></li></ul></li></ul><h2 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h2><p><img src="https://img.lonesome.cn/blog/bytedance/PKD4_0IC7IL8RAGCBF8SV.webp"></p><h3 id="列式存储的优点"><a href="#列式存储的优点" class="headerlink" title="列式存储的优点"></a>列式存储的优点</h3><ul><li>数据压缩<ul><li>数据压缩可以使读的数据量更少，在 IO 密集型计算中获得大的性能优势</li><li>相同类型压缩效率更高</li><li>排序之后压缩效率更高</li><li>可以针对不同类型使用不同的压缩算法</li><li>几种常见的压缩算法<ul><li><img src="https://img.lonesome.cn/blog/bytedance/SJN41QW8AKJI7BD@0RJ.webp"></li><li>LZ4<ul><li>(5,4) 代表向前 5 个 byte，匹配到的内容长度有 4，即”bcde”是一个重复</li><li>重复项越多或者越长，压缩率就会越高</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/50FJIITPI5J@DQ.webp"></li><li>Run-length encoding<ul><li>压缩重复的数据</li><li>可以在压缩数据上直接计算</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/TAQQXVO7DYKPU5TJ8KE6.webp"></li><li>Delta encoding<ul><li>将数据存储为连续数据之间的差异，而不是直接存储数据本身</li><li>特定算子也能直接在压缩数据上计算</li></ul></li></ul></li></ul></li><li>数据选择<ul><li>可以选择特定的列做计算而不是读所有列</li><li>对聚合计算友好</li><li><img src="https://img.lonesome.cn/blog/bytedance/DA6UA6MFDM35XXHGQ0.webp"></li></ul></li><li>延迟物化<ul><li>物化：将列数据转换为可以被计算或者输出的行数据或者内存数据结果的过程，物化后的数据通常可以用来做数据过滤，聚合计算，Join<ul><li><img src="https://img.lonesome.cn/blog/bytedance/T4EG@FAOA4MU9JE@6SN2.webp"></li></ul></li><li>延迟物化：尽可能推迟物化操作的发生<ul><li><img src="https://img.lonesome.cn/blog/bytedance/37Z_4KXHMGCPY6QR4.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/5CI1O@@DT4KR8VDRQ6DU.webp"></li></ul></li><li>缓存友好</li><li>CPU &#x2F; 内存带宽友好</li><li>可以利用到执行计划和算子的优化，例如 filter</li><li>保留直接在压缩列做计算的机会</li></ul></li><li>向量化<ul><li>SIMD (single instruction multiple data)，对于现代多核 CPU，其都有能力用一条指令执行多条数据</li><li><img src="https://img.lonesome.cn/blog/bytedance/QO9AIIZ3LANAJFVP79E.webp"><ul><li>如果这时候 CPU 也可以并行的计算我们写的代码，那么理论上我们的处理速度就会是之前代码的 100 倍，幸运的是 SIMD 指令就是完成这样的工作的，用 SIMD 指令完成这样代码设计和执行就叫做向量化</li></ul></li><li>指令集<ul><li>SIMD 程序使用的指令集有 SSE 和 AVX 系列，AVX 有 AVX-256 和 AVX-512，SSE 提供 128-bits 的寄存器，AVX-256 提供 256-bits，AVX-512 提供 512bits 的寄存器</li><li><img src="https://img.lonesome.cn/blog/bytedance/VEN5P_JQZ1LYTSWYRBU.webp"></li><li>数据格式要求<ul><li>需要处理多个数据，因此数据需要是连续内存</li><li>需要明确数据类型</li></ul></li></ul></li><li>执行模型<ul><li>数据需要按批读取</li><li>函数的调用需要明确数据类型</li><li><img src="https://img.lonesome.cn/blog/bytedance/8UNLAQJXO16BNM9NQ.webp"></li></ul></li><li>列存数据库适合设计出这样的执行模型，从而使用向量化技术<ul><li>按列读取</li><li>每种列类型定义数据读写逻辑</li><li>函数按列类型处理</li></ul></li></ul></li></ul><h3 id="行存-VS-列存"><a href="#行存-VS-列存" class="headerlink" title="行存 VS 列存"></a>行存 VS 列存</h3><p><img src="https://img.lonesome.cn/blog/bytedance/WOT_J@6XGPZU.webp"></p><h2 id="ClickHouse-存储设计"><a href="#ClickHouse-存储设计" class="headerlink" title="ClickHouse 存储设计"></a>ClickHouse 存储设计</h2><h3 id="表定义和结构"><a href="#表定义和结构" class="headerlink" title="表定义和结构"></a>表定义和结构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/00LOWTITE5442QHI07A24.webp"></p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/IRFQIBSJW3G98YAG89.webp"></p><h3 id="引擎架构"><a href="#引擎架构" class="headerlink" title="引擎架构"></a>引擎架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/PU372W3ME0D63GFZ2_HYG1.webp"></p><h3 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a>存储架构</h3><ul><li>文件组织<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5WFMS9UBJ2GP9G_L_I.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/ZY3WA2J3OKANJS88@9.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/73NEN87QO379E671Y0N8@W.webp"></li></ul></li><li>part 和 partition<ul><li>part 是物理文件夹的名字</li><li>partition 是逻辑结构</li><li><img src="https://img.lonesome.cn/blog/bytedance/3Z3H1VRE@BFM852EK8V.webp"></li></ul></li><li>part 和 column<ul><li>每个 column 都是一个文件</li><li>所有的 column 文件都在自己的 part 文件夹下</li></ul></li><li>column 和 index<ul><li>一个 part 有一个主键索引</li><li>每个 column 都有列索引</li></ul></li></ul><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul><li><p>Hash index</p><ul><li>将输入的 key 通过一个 HashFunction 映射到一组 bucket 上</li><li>每个 bucket 都包含一个指向一条记录的地址</li><li>哈希索引在查找的时候只适用于等值比较</li><li><img src="https://img.lonesome.cn/blog/bytedance/N8SP9JS4RQXDE68AQ9.webp"></li></ul></li><li><p>B-Tree</p><ul><li>数据写入是有序的，支持增删查改</li><li>每个节点有多个孩子节点</li><li>每个节点都按照升序排列 key 值</li><li>每个 key 有两个指向左右孩子节点的引用<ul><li>左孩子节点保存的 key 都小于当前 key</li><li>右孩子节点的保存的 key 都大于当前 key</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/EF@XOTDJ59URWZVVHD.webp"></li></ul></li><li><p>B+Tree</p><ul><li>所有的数据都存储在叶子节点，非叶子节点只保存 key 值</li><li>叶子节点维护到相邻叶子节点的引用</li><li>可以通过 key 值做二分查找，也可以通过叶子节点做顺序访问</li><li><img src="https://img.lonesome.cn/blog/bytedance/0BK74THVRW2@2UE4B.webp"></li></ul></li><li><p>对于大数据量，B(B+)-Tree 深度太高</p></li><li><p>索引数据量太大，多个列如何平衡查询和存储——LSM-Tree</p></li><li><p>OLAP 场景写入量非常大，如何优化写入</p></li><li><p>Log-structured merge-tree(LSM tree)是一种为大吞吐写入场景而设计的数据结构</p><ul><li>着重优化顺序写入</li><li>主要数据结构<ul><li>SSTables</li><li>Memtable</li></ul></li></ul></li><li><p>SSTables</p><ul><li>Key 按顺序存储到文件中，称为 segment</li><li>包含多个 segment</li><li>每个 segment 写入磁盘后都是不可更改的，新加的数据只能生成新的 segment</li><li><img src="https://img.lonesome.cn/blog/bytedance/XQR4WUOWCIQ50BNV8OOE.webp"></li></ul></li><li><p>Memtable</p><ul><li>在内存中的数据保存在 memtable 中，大多数实现都是一颗 Binary search tree</li><li>当 memtable 存储的数据到达一定的阈值的时候，就会按顺序写入到磁盘</li></ul></li><li><p>数据查询</p><ul><li>需要从最新的 segment 开始遍历每个 key</li><li>也可以为每个 segment 建一个索引，例如</li><li><img src="https://img.lonesome.cn/blog/bytedance/KVH55HBDZL@WOR0FQBNL.webp"></li></ul></li><li><p>Compaction(合并)</p><ul><li>Compaction 指将多个 segments 合并成一个 segments 的过程<ul><li>一般是有一个后台线程完成</li><li>不同的 segments 写入新的 segment 的时候也是需要排序，形成新的 segment 之后，旧的 segment 文件就会被删除</li><li><img src="https://img.lonesome.cn/blog/bytedance/4EJF@_Q5D4YMC96QELIGYMY.webp"></li></ul></li></ul></li></ul><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><ul><li>主键索引<ul><li><img src="https://img.lonesome.cn/blog/bytedance/FEGZO4JNMI@R6KEGREQ.webp"></li></ul></li><li>数据按照主键顺序依次做排序<ul><li>首先按照 UserID 做排序</li><li>再按照 URL 排序</li><li>最后是 EventTime</li><li><img src="https://img.lonesome.cn/blog/bytedance/QJQ5KNRLNQTVXDAVLCP.webp"></li></ul></li><li>数据被划分成 granule<ul><li>granule 是最小的数据读取单元</li><li>不同的 granulas 可以并行读取</li><li><img src="https://img.lonesome.cn/blog/bytedance/6JYEJOEWIK6GUY3TTXQ.webp"></li></ul></li><li>每个 granule 都对应 primary.idx 里面的一行<ul><li><img src="https://img.lonesome.cn/blog/bytedance/UTDTHUYPXCSH1YXN0ZKG1.webp"></li></ul></li><li>默认每 8192 行记录主键的一行值，primary.idx 需要被全部加载到内存里面<ul><li><img src="https://img.lonesome.cn/blog/bytedance/51SM_886L@BDX9FR18R.webp"></li></ul></li><li>里面保存的每一行数据被称为一个 index mark<ul><li><img src="https://img.lonesome.cn/blog/bytedance/8SZH9EMI0U5PAUSKV7.webp"></li></ul></li><li>每个列都有这样一个 mark 文件<ul><li>mark 文件保存的是每个 granule 的物理地址</li><li>每一列都有一个自己的 mark 文件</li><li><img src="https://img.lonesome.cn/blog/bytedance/QLHU57ICKK6HZKFB.webp"></li></ul></li><li>mark 文件里面的每一行存储两个地址<ul><li>第一个地址称为 block_offset，用于定位一个 granule 的压缩数据在物理文件中的位置，压缩数据会以一个 block 为单位解压到内存中</li><li>第二个地址称为 granule_offset，用于定位一个 granule 在解压之后的 block 中的位置</li></ul></li><li>缺陷：数据按照 key 的顺序做排序，因此只有第一个 key 的过滤效果好，后面的 key 过滤效果依赖第一个 key 的基数大小<ul><li><img src="https://img.lonesome.cn/blog/bytedance/KDX85Y3E11Y83ZKVKAS.webp"></li></ul></li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul><li>secondary index：在 URL 列上构建二级索引<ul><li><img src="https://img.lonesome.cn/blog/bytedance/HZVH8TNFNGGMYPW4B.webp"></li></ul></li><li>构建多个主键索引<ul><li>再建一个表<ul><li><img src="https://img.lonesome.cn/blog/bytedance/3VGMLBRP69HXNYZQWJX2.webp"></li><li>数据需要同步两份</li><li>查询需要用户判断查哪张表</li><li><img src="https://img.lonesome.cn/blog/bytedance/L9GYTY7VM_CDL5CN32.webp"></li></ul></li><li>建一个物化视图<ul><li>物化视图：可以通过 select 查询将一个表的数据写入一张隐式表</li><li><img src="https://img.lonesome.cn/blog/bytedance/2FA41GG3XFBRCLH8SQ.webp"></li><li>数据自动同步到隐式表</li><li>查询需要用户判断查哪张表</li><li><img src="https://img.lonesome.cn/blog/bytedance/6W@6O@3CE90@9N26@IL.webp"></li></ul></li><li>使用 Projection<ul><li>projection：类似于物化试图，但是不是将数据写入新的表，而是存储在原始表中，以一个列文件的形式存在</li><li><img src="https://img.lonesome.cn/blog/bytedance/8L@4OYSF7ERH6I6QH4.webp"></li><li>数据自动同步到隐式表</li><li>查询自动路由到最优的表</li><li><img src="https://img.lonesome.cn/blog/bytedance/UG9QDSRX@8O@N.webp"></li></ul></li><li>小结<ul><li>主键包含的数据顺序写入</li><li>主键构造一个主键索引</li><li>每个列构建一个稀疏索引</li><li>通过 mark 的选择让主键索引可以定位到每一列的索引</li><li>可以通过多种手段优化非主键列的索引</li></ul></li></ul></li></ul><h3 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h3><ul><li>一个 part 内的数据是有序的<ul><li><img src="https://img.lonesome.cn/blog/bytedance/K1NA40_HNS530SP.webp"></li></ul></li><li>不同 part 之间的数据是无序的<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5YZP99G7328T0USPD7HNE.webp"></li></ul></li><li>数据合并是将多个 part 合并成一起的过程<ul><li><img src="https://img.lonesome.cn/blog/bytedance/A3M5GT@6XKREIKZ5ATZEKO.webp"></li></ul></li><li>part 的合并发生在一个分区内<ul><li><img src="https://img.lonesome.cn/blog/bytedance/N_YTPXL84Y1_OBS2RFGU.webp"></li></ul></li><li>数据的可见性<ul><li>数据合并过程中，未被合并的数据对查询可见</li><li>数据合并完成后，新 part 可见，被合并的 part 被标记删除</li><li><img src="https://img.lonesome.cn/blog/bytedance/2BH5UXQFR05SSZP.webp"></li></ul></li></ul><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul><li>通过主键找到需要读的 mark<ul><li><img src="https://img.lonesome.cn/blog/bytedance/QOYM1NWECQECEJI7DTKG.webp"></li></ul></li><li>切分 marks，然后并发的调度 reader<ul><li><img src="https://img.lonesome.cn/blog/bytedance/MI_H1T9J1LS47W0O@@6M@E.webp"></li></ul></li><li>Reader 通过 mark block_offset 得到需要读的数据文件的偏移量</li><li>Reader 通过 mark granule_offset 得到解压之后数据的偏移量<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1RME807C1Y1J6VU@F@7Q.webp"></li></ul></li><li>构建列式 filter 做数据过滤<ul><li><img src="https://img.lonesome.cn/blog/bytedance/6QTSQZE29C5IP7V@BF.webp"></li></ul></li></ul><h2 id="ClickHouse-应用场景"><a href="#ClickHouse-应用场景" class="headerlink" title="ClickHouse 应用场景"></a>ClickHouse 应用场景</h2><ul><li>大宽表存储和查询<ul><li>大宽表查询<ul><li>可以建非常多的列</li><li>可以增加，删除，清空每一列的数据</li><li>查询的时候引擎可以快速选择需要的列</li><li>可以将列涉及到的过滤条件下推到存储层从而加速查询</li><li><img src="https://img.lonesome.cn/blog/bytedance/HWE7DFM65_ZXZLY2@7R.webp"></li></ul></li><li>动态表结构<ul><li>map 中的每个 key 都是一列</li><li>map 中的每一列都可以单独的查询</li><li>使用方式同普通列，可以做任何计算</li><li><img src="https://img.lonesome.cn/blog/bytedance/VFU9KVR8SU8W03EHDU6K.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/CB79G2W151S@D_IDB01.webp"></li></ul></li></ul></li><li>离线数据分析<ul><li>数据导入<ul><li>数据可以通过 spark 生成 clickhouse 格式的文件</li><li>导入到 hdfs 上由 hive2ch 导入工具完成数据导入</li><li>数据直接导入到各个物理节点</li><li><img src="https://img.lonesome.cn/blog/bytedance/WH0TMCLIMFSUK43I5HH.webp"></li></ul></li><li>数据按列导入<ul><li>保证查询可以及时访问已有数据</li><li>可以按需加载需要的列</li><li><img src="https://img.lonesome.cn/blog/bytedance/H3RJMXT_C9SULC61R@M.webp"></li></ul></li></ul></li><li>实时数据分析<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0FG21J8@O0AUHH6R8X9.webp"></li><li>使用 memory table 减少 parts 数量<ul><li>数据先缓存在内存中</li><li>到达一定阈值再写到磁盘</li><li><img src="https://img.lonesome.cn/blog/bytedance/MY9HP64NWE8UZUOKWK.webp"></li></ul></li></ul></li><li>复杂类型查询<ul><li>bitmap 索引<ul><li>构建<ul><li><img src="https://img.lonesome.cn/blog/bytedance/ET9NNRG6LKXR3RF1Z2OE.webp"></li></ul></li><li>查询<ul><li><img src="https://img.lonesome.cn/blog/bytedance/BHCF3510IEQ_WCYFOK.webp"></li></ul></li></ul></li><li>bitmap64 类型<ul><li><img src="https://img.lonesome.cn/blog/bytedance/AJEYVMCWOEXLB748EO9.webp"></li></ul></li><li>lowcardinality<ul><li>对于低基数列使用字典编码</li><li>减少数据存储和读写的 IO 使用</li><li>可以做运行时的压缩数据过滤</li><li><img src="https://img.lonesome.cn/blog/bytedance/M__P1U9P2A80W_N2BQF0.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/8MTTVKRU6TFUF8BK0Y.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/5M9EMKCKKIX5LCZ2_@AS.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/@N5L83ZNGWETRQS9H3J6.webp"></li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ClickHouse 是标准的列存结构</li><li>存储设计是 LSM-Tree 架构</li><li>使用稀疏索引加速查询</li><li>每个列都有丰富的压缩算法和索引结构</li><li>基于列存设计的高效的数据处理逻辑</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库基本概念&quot;&gt;&lt;a href=&quot;#数据库基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库基本概念&quot;&gt;&lt;/a&gt;数据库基本概念&lt;/h2&gt;&lt;p&gt;数据库是结构化信息或数据的有序集合，一般以电子形式存储在计算机系统中。通常由数据库管理系统(DBMS</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="ClickHouse" scheme="https://lonesome.cn/tags/ClickHouse/"/>
    
  </entry>
  
  <entry>
    <title>Redis——大厂程序员是怎么用的</title>
    <link href="https://lonesome.cn/posts/how-top-tech-programmers-use-redis/"/>
    <id>https://lonesome.cn/posts/how-top-tech-programmers-use-redis/</id>
    <published>2023-02-15T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:22.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-是什么"><a href="#Redis-是什么" class="headerlink" title="Redis 是什么"></a>Redis 是什么</h2><ul><li>为什么需要 Redis<ul><li>数据从单表，演进出了分库分表<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1834A2OICLDX7C4CX6.webp"></li></ul></li><li>Mysql 从单机演进出了集群<ul><li>数据量增长</li><li>读写数据压力的不断增加</li></ul></li><li>数据分冷热<ul><li>热数据：经常被访问到的数据</li></ul></li><li>将热数据存储到内存中</li><li><img src="https://img.lonesome.cn/blog/bytedance/4QMRLI99NKP8UT8KBX.webp"></li></ul></li><li>Redis 基本工作原理<ul><li><img src="https://img.lonesome.cn/blog/bytedance/YF0FAQ6DF4C6LI4R37M.webp"></li><li>数据从内存中读写</li><li>数据保存到硬盘上防止重启数据丢失<ul><li>增量数据保存到 AOF 文件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/CKJ4Z6G@KZJISJQI4.webp"></li></ul></li><li>全量数据 RDB 文件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/VZEPJXPJSVEK60FVA.webp"></li></ul></li></ul></li><li>单线程处理所有操作命令<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1YKFIJBZZMNL@XONF.webp"></li></ul></li></ul></li></ul><h2 id="Redis-应用案例"><a href="#Redis-应用案例" class="headerlink" title="Redis 应用案例"></a><a href="https://gitee.com/wedone/redis_course">Redis 应用案例</a></h2><ul><li>1、连续签到<ul><li>掘金每日连续签到<ul><li>用户每日有一次签到机会，如果断签，连续签到计数将归为 0</li><li>连续签到的定义：每天必须在 23:59:59 前签到</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/5@H6PUZ3MD8O45O_E.webp"><ul><li>Key：cc_uid_1165894833417101</li><li>value：252</li><li>expireAt：后天的零点</li></ul></li><li>String 数据结构<ul><li>数据结构-sds</li><li><img src="https://img.lonesome.cn/blog/bytedance/YH9_XC4HXY16@EBYN.webp"><ul><li>可以存储字符串、数字、二进制数据</li><li>通常和 expire 配合使用</li><li>场景：存储计数、Session</li></ul></li></ul></li></ul></li><li>2、消息通知<ul><li>用 list 作为消息队列</li><li>使用场景：消息通知<ul><li>例如当文章更新时，将更新后的文章推送到 ES，用户就能搜索到最新的文章数据</li><li><img src="https://img.lonesome.cn/blog/bytedance/OUEGDJFIAMJC7FC22H7O.webp"></li></ul></li><li>List 数据结构 Quicklist<ul><li>Quicklist 由一个双向链表和 listpack 实现</li><li><img src="https://img.lonesome.cn/blog/bytedance/6_XP84SI3W6AC52HKJCCF.webp"></li><li>Listpack 数据结构<ul><li><img src="https://img.lonesome.cn/blog/bytedance/D1QVL7B8RSVHCFJ8@NCF.webp"></li></ul></li></ul></li></ul></li><li>3、计数<ul><li>一个用户有多项计数需求，可通过 hash 结构存储</li><li><img src="https://img.lonesome.cn/blog/bytedance/C5YNICY5QPFH_Z92X107.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/D0MX8QMNUBH0NN8K.webp"></li><li>Hash 数据结构 dict<ul><li><img src="https://img.lonesome.cn/blog/bytedance/BVM_SDVMBQBS0URV74.webp"></li><li>rehash：rehash 操作是将 ht[O]中的数据全部迁移到 ht[1]中。数据量小的场景下直接将数据从 ht[O 拷贝到 ht[1]速度是较快的。数据量大的场景，例如存有上百万的 KV 时，迁移过程将会明显阻塞用户请求</li><li>渐进式 rehash：为避免出现这种情况，使用了 rehash 方案。基本原理就是，每次用户访问时都会迁移少量数据。将整个迁移过程，平摊到所有的访问用不请求过程中</li></ul></li></ul></li><li>排行榜<ul><li>积分变化时，排名要实时变更</li><li><img src="https://img.lonesome.cn/blog/bytedance/0HG0COLNIAVE1A8HMK.webp"></li><li>zset 数据结构 zskiplist<ul><li>查找数字 7 的路径，head，3，3，7</li><li>结合 dict 时，可实现通过 key 操作跳表的功能<ul><li>ZINCRBY myzset 2 “Alex”</li><li>ZSCORE myzset “Alex”</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/ER5I2HKVBT5KJM27KTJ.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/6VM829WCWJW7_UVFI2.webp"></li></ul></li></ul></li><li>5、限流<ul><li>要求 1 秒内放行的请求为 N，超过 N 则禁止访问</li><li><img src="https://img.lonesome.cn/blog/bytedance/3CVV_Q9I9F93F_L5SBCJ.webp"></li><li>Key：comment_freq_limit_1671356046<ul><li>对这个 Key 调用 incr，超过限制 N 则禁止访问</li><li>1671356046 是当前时间戳</li></ul></li></ul></li><li>分布式锁<ul><li>并发场景，要求一次只能有一个协程运行，执行完成后，其他等待中的协程才能执行</li><li><img src="https://img.lonesome.cn/blog/bytedance/R2JOO8V45N89SK_YIK.webp"></li><li>可以使用 redis 的 setnx 实现，利用了两个特性<ul><li>Redis 是单线程执行命令</li><li>setnx 只有未设置过才能执行成功</li></ul></li></ul></li></ul><h2 id="Redis-使用注意事项"><a href="#Redis-使用注意事项" class="headerlink" title="Redis 使用注意事项"></a>Redis 使用注意事项</h2><h3 id="大-Key、热-Key"><a href="#大-Key、热-Key" class="headerlink" title="大 Key、热 Key"></a>大 Key、热 Key</h3><ul><li><p>大 Key 的定义</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/YHIQXGKJS5Y816ZAX.webp"></li></ul></li><li><p><img src="https://img.lonesome.cn/blog/bytedance/LDCX12BXH6T95D74LON.webp"></p></li><li><p>大 Key 的危害</p><ul><li>读取成本高</li><li>容易导致慢查询（过期、删除）</li><li>主从复制异常，服务组塞无法正常响应请求</li></ul></li><li><p>业务侧使用大 Key</p><ul><li>请求 Redis 超时报错</li></ul></li><li><p>消除大 Key 的方法</p><ul><li>1、拆分<ul><li>将大 Key 拆分为小 Key。例如一个 String 拆分成多个 String</li><li><img src="https://img.lonesome.cn/blog/bytedance/2LZ8_62MHWK29T30DJW.webp"></li></ul></li><li>2、压缩<ul><li>将 valuel 压缩后写入 redis，读取时解压后再使用。压缩算法可以是 gzip、snappy、lz4 等。通常情况下，一个压缩算法压缩率高、则解压耗时就长。需要对实际数据进行测试后，选择一个合适的算法</li><li>如果存储的是 JSON 字符串，可以考虑使用 MessagePack 进行序列化</li></ul></li><li>3、集合类结构 hash、list、set<ul><li>拆分：可以用 hash 取余、位掩码的方式决定放在哪个 Key 中</li><li>区分冷热：如榜单列表场景使用 zset，只缓存前 10 页数据，后续数据走 db</li></ul></li></ul></li><li><p>热 Key 的定义</p><ul><li>用户访问一个 Key 的 QPS 特别高，导致 Server 实例出现 CPU 负载突增或者不均的情况</li><li>热 key 没有明确的标准，QPS 超过 500 就有可能被识别为热 Key</li><li><img src="https://img.lonesome.cn/blog/bytedance/TO@0JW9OAOTAP7NU.webp"></li></ul></li><li><p>解决热 Key 的方法</p><ul><li>1、设置 Localcache<ul><li>在访问 Redis 前，在业务服务侧设置 Localcache，降低访问 Redis 的 QPS。LocalCache 中缓存过期或未命中，则从 Redist 中将数据更新到 LocalCache。Java 的 Guava、Golang 的 Bigcache 就是这类 LocalCache</li><li><img src="https://img.lonesome.cn/blog/bytedance/7N5_6X_Y5O0XAUME.webp"></li></ul></li><li>2、拆分<ul><li>将 key : value 这一个热 Key 复制写入多份，例如 key1 : value,key2 : value，访问的时候访问多个 key，但 value 是同一个，以此将 qps 分散到不同实例上，降低负载。代价是，更新时需要更新多个 key，存在数据短暂不一致的风险</li><li><img src="https://img.lonesome.cn/blog/bytedance/DUYBC3FMWI7JBM1Z8MAC4.webp"></li></ul></li><li>3、使用 Redis 代理的热 Key 承载能力<ul><li>字节跳动的 Redis 访问代理就具备热 Key 承载能力。本质上是结合了“热 Key 发现”、“LocalCache”两个功能</li><li><img src="https://img.lonesome.cn/blog/bytedance/P3QS8SD3R6IFK3KEOC.webp"></li></ul></li></ul></li></ul><h3 id="慢查询场景"><a href="#慢查询场景" class="headerlink" title="慢查询场景"></a>慢查询场景</h3><ul><li>容易导致 redis 慢查询的操作<ul><li>批量操作一次性传入过多的 key&#x2F;value，如 mset&#x2F;hmset&#x2F;sadd&#x2F;zadd 等 O(n)操作建议单批次不要超过 100，超过 100 之后性能下降明显</li><li>Zset 大部分命令都是 O(log(n))，当大小超过 5k 以上时，简单的 zadd&#x2F;zrem 也可能导致慢查询</li><li>操作的单个 vaue 过大，超过 10KB。也即，避免使用大 Key</li><li>对大 key 的 delete&#x2F;expire 操作也可能导致慢查询，Redis4.0 之前不支持异步删除 unlink，大 key 删除会阻塞 Redis</li></ul></li></ul><h3 id="缓存穿透、缓存雪崩"><a href="#缓存穿透、缓存雪崩" class="headerlink" title="缓存穿透、缓存雪崩"></a>缓存穿透、缓存雪崩</h3><ul><li>缓存穿透：热点数据查询绕过缓存，直接查询数据库</li><li>缓存雪崩：大量缓存同时过期</li><li>缓存穿透的危害<ul><li>查询一个一定不存在的数据<ul><li>通常不会缓存不存在的数据，这类查询请求都会直接打到 db，如果有系统 bug 或人为攻击，那么容易导致 db 响应慢甚至宕机</li></ul></li><li>缓存过期时<ul><li>在高并发场景下，一个热 key 如果过期，会有大量请求同时击穿至 db，容易影响 db 性能和稳定</li><li>同一时间有大量 key 集中过期时，也会导致大量请求落到 db 上，导致查询变慢，甚至出现 db 无法响应新的查询</li></ul></li></ul></li><li>如何减少缓存穿透<ul><li>缓存空值<ul><li>如一个不存在的 userlD。这个 id 在缓存和数据库中都不存在。则可以缓存一个空值，下次再查缓存直接反空值</li></ul></li><li>布隆过滤器<ul><li>通过 bloom filter 算法来存储合法 Key，得益于该算法超高的压缩率，只需占用极小的空间就能存储大量 key 值</li></ul></li></ul></li><li>如何避免缓存雪崩<ul><li>缓存空值<ul><li>将缓存失效时间分散开，比如在原有的失效时间基础上增加一个随机值，例如不同 Key 过期时间可以设置为 10 分 1 秒过期，10 分 23 秒过期，10 分 8 秒过期。单位秒部分就是随机时间，这样过期时间就分散了</li><li>对于热点数据，过期时间尽量设置得长一些，冷门的数据可以相对设置过期时间短一些</li></ul></li><li>使用缓存集群，避免单机宕机造成的缓存雪崩</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-是什么&quot;&gt;&lt;a href=&quot;#Redis-是什么&quot; class=&quot;headerlink&quot; title=&quot;Redis 是什么&quot;&gt;&lt;/a&gt;Redis 是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么需要 Redis&lt;ul&gt;
&lt;li&gt;数据从单表，演进出了分库分表&lt;u</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Redis" scheme="https://lonesome.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL——深入理解RDBMS</title>
    <link href="https://lonesome.cn/posts/deep-understanding-of-rdbms/"/>
    <id>https://lonesome.cn/posts/deep-understanding-of-rdbms/</id>
    <published>2023-02-13T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:22.624Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.lonesome.cn/blog/bytedance/ZEW16CSVEKU@SM10IR0JPI.webp"></p><h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><ul><li>从一场红包雨说起<ul><li><img src="https://img.lonesome.cn/blog/bytedance/2FVS4PX3SREBSTOL_V58.webp"></li></ul></li><li>RDBMS 事务 ACID<ul><li>事务(Transaction)：是由一组 SQL 语句组成的一个程序执行单元（Unit），它需要满足 ACID 特性<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5TU_YNQEDKMA17YREL.webp"></li></ul></li><li>ACID：<ul><li>原子性(<strong>Atomicity</strong>)：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生</li><li>一致性(<strong>Consistency</strong>)：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性</li><li>隔离性(<strong>Isolation</strong>)：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果</li><li>持久性(<strong>Durability</strong>)：在事务完成以后，该事务所对数据库所做的更改便持久的保存在数据库之中，并不会被回滚</li></ul></li><li>红包雨 与 ACID<ul><li><img src="https://img.lonesome.cn/blog/bytedance/56XYK56QIG0GRUG436.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/F091PF@MTFDPOP5FQOQ.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/@YJYQ32NE5W3WQ18C3J2.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/NKLRZFDXR0@BSO1ZTXC9.webp"></li></ul></li><li>红包雨 与 高并发<ul><li><img src="https://img.lonesome.cn/blog/bytedance/Y3AS7IBHF34F49MUVV.webp"></li></ul></li><li>红包雨 与 高可靠<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DWACJCWDRIVZ23ZYAPS.webp"></li></ul></li></ul></li></ul><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="前-DBMS-时代"><a href="#前-DBMS-时代" class="headerlink" title="前 DBMS 时代"></a>前 DBMS 时代</h3><ul><li>人工管理<ul><li>在现代计算机发明出来以前，通过人工的方式进行数据记录和管理</li></ul></li><li>文件系统<ul><li>1950s，现代计算机的雏形基本出现。1956 年 IBM 发布了第一个磁盘驱动器–Model 305 RAMAC，从此数据存储进入硬盘时代。在这个阶段，数据管理直接通过文件系统来实现</li></ul></li></ul><h3 id="DBMS-时代"><a href="#DBMS-时代" class="headerlink" title="DBMS 时代"></a>DBMS 时代</h3><ul><li>1960s，传统的文件系统已经不能满足人们的需要，数据库管理系统（<strong>DBMS</strong>）应运而生</li><li>DBMS：按照某种数据模型来组织、存储和管理数据的仓库</li><li>所以通常按照数据模型的特点将传统数据库系统分成<strong>网状数据库</strong>、<strong>层次数据库</strong>和<strong>关系数据库</strong>三类</li><li><img src="https://img.lonesome.cn/blog/bytedance/I@TYJV0_F@IF88_JAVB.webp"></li></ul><h3 id="DBMS-数据模型"><a href="#DBMS-数据模型" class="headerlink" title="DBMS 数据模型"></a>DBMS 数据模型</h3><ul><li>网状模型<ul><li>网状数据库所基于的网状数据模型建立的数据之间的联系，能反映现实世界中信息的关联，是许多空间对象的自然表达形式</li><li>1964 年，世界上第一个数据库系统一集成数据存储（Integrated Data Storage，IDS）诞生于通用电气公司。1DS 是世界上第一个网状数据库，奠定了数据库发展的基础，在当时得到了广泛的应用。在 1970s 网状数据库系统十分流行，在数据库系统产品中占据主导地位</li><li><img src="https://img.lonesome.cn/blog/bytedance/BGK8K3HRU_JZSWJOSF5YI.webp"></li></ul></li><li>层次模型<ul><li>1968 年，世界上第一个层次数据库一信息管理系统（Information Management System，IMS）诞生于于 IBM 公司，这也是世界上第一个大型商用的数据库系统。层次数据模型，即使用树形结构来描述实体及其之间关系的数据模型</li><li><img src="https://img.lonesome.cn/blog/bytedance/M89HJZ5DFCTQ45WWGC.webp"></li></ul></li><li>关系模型<ul><li>1970 年，IBM 的研究员 E.F.Codd 博士发表了一篇名为“A Relational Model of Data for large Shared Data Banks”的论文，提出了关系模型的概念，奠定了关系模型的理论基础。1979 年 Oracle 首次将关系型数据库商业化，后续 DB2，SAP Sysbase ASE，and Informix 等知名数据库产品也纷纷面世</li><li><img src="https://img.lonesome.cn/blog/bytedance/CDY81XGW5AK1T47SW6HE.webp"></li></ul></li><li>优劣势<ul><li><img src="https://img.lonesome.cn/blog/bytedance/RA@T_XGVQ8T54C_73F.webp"></li></ul></li></ul><h3 id="SQL-语言"><a href="#SQL-语言" class="headerlink" title="SQL 语言"></a>SQL 语言</h3><ul><li>1974 年 IBM 的 Ray Boycei 和 Don Chamberlin 将 Codd 关系数据库的 12 条准则的数学定义以简单的关键字语法表现出来，里程碑式地提出了 SQL(Structured Query Language)语言<ul><li>语法风格接近自然语言</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>语言简洁，易学易用</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/JEHRBF7W0P3I4AMIUEI5.webp"></li></ul><h3 id="历史回顾"><a href="#历史回顾" class="headerlink" title="历史回顾"></a>历史回顾</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ANUJJ5MW5E1E@37OQU9.webp"></p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h3 id="一条-SQL-的一生"><a href="#一条-SQL-的一生" class="headerlink" title="一条 SQL 的一生"></a>一条 SQL 的一生</h3><p><img src="https://img.lonesome.cn/blog/bytedance/IX8HEIYE5Y3CKAIFD6.webp"></p><h3 id="SQL-引擎"><a href="#SQL-引擎" class="headerlink" title="SQL 引擎"></a>SQL 引擎</h3><ul><li>Parser<ul><li>解析器(Parser)一般分为词法分析(Lexical analysis)、语法分析(Syntax analysis))、语义分析(Semantic analyzer)等步骤</li><li><img src="https://img.lonesome.cn/blog/bytedance/JI_PSRX64RWUZ_5VTXMVN.webp"></li></ul></li><li>Optimizer<ul><li>为什么需要一个优化器(Optimizer)？<ul><li><img src="https://img.lonesome.cn/blog/bytedance/IL7VWM1OW6N@8LW@4.webp"></li></ul></li><li>基于规则的优化(<strong>RBO</strong> Rule Base Optimizer)<ul><li>条件化简<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OOM4HXWSUIJ4OGBRM.webp"></li></ul></li><li>表连接优化<ul><li>总是小表先进行连接</li></ul></li><li>Scan 优化<ul><li>唯一索引</li><li>普通索引</li><li>全表扫描</li></ul></li><li>数据库索引：是数据库管理系统中辅助数据结构，以协助快速查询、更新数据库表中数据。目前数据库中最常用的索引是通过 B+树实现的</li></ul></li><li>基于代价的优化(CBO Cost Base Optimizer)<ul><li>一个查询有多种执行方案，CBO 会选择其中代价最低的方案去真正的执行</li><li>什么是代价？<ul><li><img src="https://img.lonesome.cn/blog/bytedance/9LRZMYRJAQZ9@JL.webp"></li></ul></li></ul></li></ul></li><li>Executor<ul><li>火山模型<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5B7FVB2M3VM48FYB0.webp"></li><li>每个 Operator 调用 Next 操作，访问下层 Operator，获得下层 Operator 返回的一行数据，经过计算之后，将这行数据返回给上层</li><li>优点：<ul><li>每个算子独立抽象实现，相互之间没有耦合，逻辑结构简单</li></ul></li><li>缺点：<ul><li>每计算一条数据有多次函数调用开销，导致 CPU 效率不高</li></ul></li></ul></li><li>向量化<ul><li><img src="https://img.lonesome.cn/blog/bytedance/BDAN4U@9LIF1M51549D.webp"></li><li>每个 ○perator 每次操作计算的不再是一行数据，而是一批数据(Batch N 行数据)，计算完成后向上层算子返回一个 Batch</li><li>优点：<ul><li>函数调用次数降低为 1&#x2F;N</li><li>CPU cache 命中率更高</li><li>可以利用 CPU 提供的 SIMD(Single Instruction Multi Data)机制</li></ul></li></ul></li><li>编译执行<ul><li><img src="https://img.lonesome.cn/blog/bytedance/76FIP7OEWDIFLQ2ULM24NE.webp"></li><li>将所有的操作封装到一个函数里面，函数调用的代价也能大幅度降低</li><li>用户 SQL 干变万化怎么办？难道要穷举用户的所有 SQL,给每一个 SQL 都预先写好一个执行函数吗？<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@V6T1NMDHVUQ7H1MY.webp"></li></ul></li></ul></li></ul></li></ul><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li>InnoDB<ul><li><img src="https://img.lonesome.cn/blog/bytedance/V8X_Y3GRTIAY5X4_DJ.webp"></li><li>In-Memory：<ul><li>Buffer Pool</li><li>Change Buffer</li><li>Adaptive Hash Index</li><li>Log Buffer</li></ul></li><li>On-Disk：<ul><li>System Tablespace(ibdata1)</li><li>General Tablespaces(xxx.ibd)</li><li>Undo Tablespaces(xxx.ibu)</li><li>Temporary Tablespaces(xxx.ibt)</li><li>Redo Log(ib_logfileN)</li></ul></li></ul></li><li>Buffer Pool<ul><li><img src="https://img.lonesome.cn/blog/bytedance/UKR1BW0Q4B8BT6Z6.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/XG_PRVEHBH5AJGE.webp"></li></ul></li><li>Page<ul><li><img src="https://img.lonesome.cn/blog/bytedance/13N89GLL1FTV2BWKETF.webp"></li></ul></li><li>B+ Tree<ul><li><img src="https://img.lonesome.cn/blog/bytedance/LNTJY320TBS3H@1L3L8OX.webp"></li><li>页面内：<ul><li>页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>从根到叶：<ul><li>中间节点存储</li></ul></li><li>点查：<ul><li>Select * from table wehre id &#x3D; 2000;</li></ul></li><li>范围查询：<ul><li>Select * from table wehre id &gt; 2000;</li></ul></li></ul></li></ul><h3 id="事务引擎"><a href="#事务引擎" class="headerlink" title="事务引擎"></a>事务引擎</h3><ul><li>Atomicity 与 Undo Log<ul><li><img src="https://img.lonesome.cn/blog/bytedance/XN3R5VMNEFM_94.webp"></li><li>如何将数据库回退到修改之前的状态？<ul><li>Undo Log<ul><li>Undo Log 是<strong>逻辑日志</strong>，记录的是数据的<strong>增量变化</strong>。利用 Undo Log 可以进行事务回滚，从而保证事务的原子性。同时也实现了多版本并发控制(MVCC)，解决读写冲突和一致性读的问题</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/62FKKM3ZY48URE2R2PW.webp"></li></ul></li></ul></li><li>Isolation 与 锁<ul><li>前情提要：羊老师从抖音抢了一个亿红包，又从头条抢了一个亿。抖音和头条都要往羊老师的账户转一个亿，如果两个操作同时进行，发生冲突怎么办？</li><li><img src="https://img.lonesome.cn/blog/bytedance/7S3G1OLVHYYC_55R.webp"></li></ul></li><li>Isolation 与 MVCC<ul><li><img src="https://img.lonesome.cn/blog/bytedance/V74Z8ASO2Y7DY7C37DR.webp"></li><li>MVCC 的意义：<ul><li>读写互补阻塞</li><li>降低死锁概率</li><li>实现一致性读</li></ul></li><li>Undo Log 在 MVCC 的作用：<ul><li>每个事务有一个单增的事务 ID</li><li>数据页的行记录中包含了 DB_ROW_ID，DB_TRX_ID，DB_ROLL_PTR</li><li>DB_ROLL_PTR 将数据行的所有快照记录都通过链表的结构串联了起来</li></ul></li></ul></li><li>Durability 与 Redo Log<ul><li>如何保证事务结束后，对数据的修改永久的保存？</li><li>方案一：事务提交前页面写盘<ul><li><img src="https://img.lonesome.cn/blog/bytedance/A1PP56F0BI8OMA00L.webp"></li><li>问题：随机 IO、写放大</li></ul></li><li>方案二：WAL(Write-ahead logging)<ul><li>redo log 是物理日志，记录的是页面的变化，它的作用是保证事务持久化。如果数据写入磁盘前发生故障，重启 MySQL 后会根据 redo log 重做</li></ul></li></ul></li></ul><h2 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h2><h3 id="春节红包雨挑战"><a href="#春节红包雨挑战" class="headerlink" title="春节红包雨挑战"></a>春节红包雨挑战</h3><p><img src="https://img.lonesome.cn/blog/bytedance/YKR7C8H6H7U71IJIUND5.webp"></p><h3 id="大流量-Sharding"><a href="#大流量-Sharding" class="headerlink" title="大流量-Sharding"></a>大流量-Sharding</h3><ul><li>问题背景<ul><li>单节点写容易成为瓶颈</li><li>单机数据容量上限</li></ul></li><li>解决方案<ul><li>业务数据进行水平拆分</li><li>代理层进行分片路由</li></ul></li><li>实施效果<ul><li>数据库写入能力扩展</li><li>数据库容量线性扩展</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/8NQB5_V616@TOCTCZL9.webp"></li></ul><h3 id="流量突增"><a href="#流量突增" class="headerlink" title="流量突增"></a>流量突增</h3><ul><li>扩容<ul><li>问题背景<ul><li>活动流量上涨</li><li>集群性能不满足要求</li></ul></li><li>解决方案<ul><li>扩容 DB 物理节点数量</li><li>利用影子表进行压测</li></ul></li><li>实施效果<ul><li>数据库集群提供更高的吞吐</li><li>保证集群可以承担预期流量</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/TFBGJXV_S_CWURD8UL.webp"></li></ul></li><li>代理连接池<ul><li>问题背景<ul><li>突增流量导致大量建联</li><li>大量建联导致负载变大，延时上升</li></ul></li><li>解决方案<ul><li>业务侧预热连接池</li><li>代理则预热连接池</li><li>代理侧则支持连接队列</li></ul></li><li>实施效果<ul><li>避免 DB 被突增流量打死</li><li>避免代理和 DB 被大量建联打死</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/O9J3XWP3IO6PA5T3M4.webp"></li></ul></li></ul><h3 id="稳定性-可靠性"><a href="#稳定性-可靠性" class="headerlink" title="稳定性&amp;可靠性"></a>稳定性&amp;可靠性</h3><ul><li>3AZ 高可用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DBX19QOBV1YDSYLR.webp"></li></ul></li><li>HA 管理<ul><li>问题背景<ul><li>db 所在机器异常宕机</li><li>db 节点异常宕机</li></ul></li><li>解决方案<ul><li>ha 服务监管、切换宕机节点</li><li>代理支持配置热加载</li><li>代理自动屏蔽宕机读节点</li></ul></li><li>实施效果<ul><li>读节点宕机秒级恢复</li><li>写节点宕机 30s 内恢复服务</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/T_96F64E94360SHAG2L.webp"></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/bytedance/ZEW16CSVEKU@SM10IR0JPI.webp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;经典案例&quot;&gt;&lt;a href=&quot;#经典案例&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>带你认识存储的本质——状态</title>
    <link href="https://lonesome.cn/posts/the-essence-of-storage/"/>
    <id>https://lonesome.cn/posts/the-essence-of-storage/</id>
    <published>2023-02-12T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:22.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><ul><li>数据的产生<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WSEP50IU2J4@1BK2YDUE7.webp"></li></ul></li><li>数据的流动<ul><li><img src="https://img.lonesome.cn/blog/bytedance/L2G18WHQLARXJX7K4NK.webp"></li></ul></li><li>数据的持久化<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DJUSTW7KHJZCV5P868XFF.webp"></li></ul></li><li>潜在的问题<ul><li>数据库怎么保证<strong>数据不丢</strong></li><li>数据库怎么处理<strong>多人同时修改</strong>的问题</li><li>为什么用数据库，除了数据库还能存到<strong>别的存储系统</strong>吗</li><li>数据库只能处理<strong>结构化数据</strong>吗</li><li>有哪些操作数据库的<strong>方式</strong>，要用什么<strong>编程语言</strong></li></ul></li></ul><h2 id="存储-数据库简介"><a href="#存储-数据库简介" class="headerlink" title="存储 &amp; 数据库简介"></a>存储 &amp; 数据库简介</h2><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><ul><li>系统概览<ul><li>什么是存储系统？</li><li>一个提供了读写、控制类的接口，能够安全有效的把数据持久化的软件，就可以称为<strong>存储系统</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/0XU1H09SRBXM@@WUB.webp"></li></ul></li><li>系统特点<ul><li>作为后端软件的底座，<strong>性能敏感</strong></li><li>存储系统软件架构，<strong>容易受硬件影响</strong></li><li>存储系统<strong>代码，既“简单”又“复杂”</strong></li></ul></li><li>存储器层级结构<ul><li><img src="https://img.lonesome.cn/blog/bytedance/H4P0LHX0K21NID7VMVS.webp"></li></ul></li><li>数据怎么从应用到存储介质<ul><li><img src="https://img.lonesome.cn/blog/bytedance/D3NES3@5M0ZMW27IZ05.webp"></li><li><strong>[缓存]</strong> 很重要，贯穿整个存储体系</li><li><strong>[拷贝]</strong> 很昂贵，应该尽量减少</li><li>硬件设备五花八门，需要有抽象统一的接入层</li></ul></li><li>RAID 技术<ul><li>单机存储系统怎么做到<strong>高性能&#x2F;高性价比&#x2F;高可靠性</strong>？<ul><li><strong>R</strong>(edundant) <strong>A</strong>(rray) of <strong>I</strong>(nexpensive) <strong>D</strong>(isks)</li></ul></li><li>RAID 出现的背景：<ul><li>单块大容量磁盘的<strong>价格</strong>&gt;多块小容量磁盘</li><li>单块磁盘的写入<strong>性能</strong>&lt;多块磁盘的并发写入性能</li><li>单块磁盘的<strong>容错能力</strong>有限，不够安全</li></ul></li><li>RAID 0<ul><li>多块磁盘简单组合</li><li>数据条带化存储，提高磁盘宽带</li><li>没有额外的容错设计</li></ul></li><li>RAID 1<ul><li>一块磁盘对应一块额外镜像盘</li><li>真实空间利用率仅 50%</li><li>容错能力强</li></ul></li><li>RAID 0+1<ul><li>结合了 RAID 0 和 RAID 1</li><li>真实空间利用率仅 50%</li><li>容错能力强，写入宽带好</li></ul></li></ul></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>数据库和存储系统<strong>不一样</strong><ul><li>关系型数据库</li><li>非关系型数据库</li></ul></li><li>概览<ul><li><strong>关系</strong>（Relation）是什么？<ul><li>Edgar.F.Codd 于 1970 年提出 <strong>[关系模型]</strong></li><li>关系 &#x3D; <strong>集合</strong> &#x3D; 任意元素组成的若干有序偶对反映了事物间的联系</li><li>关系代数 &#x3D; 对关系作<strong>运算的抽象查询语言</strong><ul><li>交、并、笛卡尔积……</li></ul></li><li>SQL &#x3D; 一种 DSL &#x3D; <strong>方便人类阅读</strong>的关系代数表达形式</li></ul></li></ul></li><li>关系型数据库特点<ul><li><strong>关系型数据库是存储系统</strong>，但是在存储之外，又发展出<strong>其他能力</strong><ul><li>结构化数据友好</li><li>支持事务（ACID）</li><li>支持复杂查询语言</li></ul></li></ul></li><li>非关系型数据库特点<ul><li>非关系型数据体也是存储系统，但是<strong>一般不要求严格的结构化</strong><ul><li>半结构化数据友好</li><li>可能支持事务（ACID）</li><li>可能支持复杂查询语言</li></ul></li></ul></li></ul><h3 id="数据库-vs-经典存储"><a href="#数据库-vs-经典存储" class="headerlink" title="数据库 vs 经典存储"></a>数据库 vs 经典存储</h3><ul><li>结构化数据管理<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@B6QO3YCEEF2LAOXO3.webp"></li></ul></li><li>事务能力<ul><li>凸显出数据库支持[事务]的优越性</li><li>事务具有：<ul><li>A(tomicity).事务内的操作要么全做，要么不做</li><li>C(onsistency).事务执行前后，数据状态是一致的</li><li>I(solation).可以隔离多个并发事务，避免影响</li><li>D(urability).事务一旦提交成功，数据保证持久性</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/XTAE5ZDHD1BNKISY43_2.webp"></li></ul></li><li>复杂查询能力<ul><li>写入数据之后，想做很复杂的查询怎么办？</li><li>Example：请查询出名字以 xiao 开头，且密码提示问题小于 10 个字的人，并按性别分组统计人数</li><li><img src="https://img.lonesome.cn/blog/bytedance/PG0_F0@GCUOK97NT8F.webp"></li></ul></li></ul><h3 id="数据库使用方式"><a href="#数据库使用方式" class="headerlink" title="数据库使用方式"></a>数据库使用方式</h3><ul><li>Everything is D(omain) S(pecific) L(anguage) &#x3D;&#x3D;&gt; maybe SQL</li><li>以 SQl 为例，要操作数据时，支持以下操作：<ul><li>Insert</li><li>Update</li><li>Select</li><li>Delete</li><li>Where 子句</li><li>GroupBy</li><li>OrderBy</li></ul></li><li>要对数据库定义做修改时，支持以下操作：<ul><li>Create User</li><li>Create database</li><li>Create table</li><li>Alter table</li><li>……</li></ul></li></ul><h2 id="主流产品剖析"><a href="#主流产品剖析" class="headerlink" title="主流产品剖析"></a>主流产品剖析</h2><h3 id="单机存储"><a href="#单机存储" class="headerlink" title="单机存储"></a>单机存储</h3><ul><li>概览<ul><li>单机存储 &#x3D; 单个计算机节点上的存储软件系统，一般不涉及网络交互<ul><li>本地文件系统</li><li>key-value 存储</li></ul></li></ul></li><li>本地文件系统<ul><li>Linux 经典哲学：<strong>一切皆文件</strong></li><li>文件系统的管理单元：文件</li><li>文件系统接口：文件系统繁多，如 Ext2&#x2F;3&#x2F;4，sysfs，rootfs 等，但都遵循 VFS 的统一抽象接口</li><li>Linux 文件系统的两大数据结构：<strong>Index Node</strong> &amp; <strong>Directory Entry</strong><ul><li><strong>Index Node</strong><ul><li>记录文件元数据，如 id、大小、权限、磁盘位置等 inode 是一个文件的<strong>唯一标识</strong>，会被存储到磁盘上 inode 的总数在格式化文件系统时就固定了</li></ul></li><li><strong>Directory Entry</strong><ul><li>记录文件名、inode 指针，层级关系（parent）等</li><li>dentry 是内存结构，与 inode 的关系 N:1（hardlink 的实现）</li></ul></li></ul></li></ul></li><li>key-value 存储<ul><li>世间一切皆<strong>key-value</strong></li><li>常见使用方式：put(k,v)&amp;get(k)</li><li>常见数据结构：LSM-Tree，某种程度上牺牲读性能，追求写入性能</li><li>拳头产品：RocksDB</li><li><img src="https://img.lonesome.cn/blog/bytedance/OBUH3UXU3T0NFUZV76.webp"></li></ul></li></ul><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><ul><li>概览<ul><li>分布式存储 &#x3D; 在单机存储基础上实现了<strong>分布式协议</strong>，涉及大量网络交互<ul><li>分布式文件系统</li><li>分布式对象存储</li></ul></li></ul></li><li>HDFS<ul><li>HDFS：堪称大数据时代的<strong>基石</strong></li><li>时代背景：专用的高级硬件<strong>很贵</strong>，同时数据存量<strong>很大</strong>，要求超高<strong>吞吐</strong></li><li>HDFS 核心特点：<ul><li>支持<strong>海量数据存储</strong></li><li><strong>高容错性</strong></li><li><strong>弱 POSIX 语义</strong></li><li>使用普通 x86 服务器，<strong>性价比高</strong></li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/YOGWN319DE8JG5MZWD.webp"></li></ul></li><li>Ceph<ul><li>Ceph：开源分布式存储系统里的 <strong>[万金油]</strong></li><li>Ceph 的核心特点：<ul><li>一套系统支持对象接口、块接口、文件接口，但是<strong>一切皆对象</strong></li><li>数据写入采用<strong>主备复制模型</strong></li><li>数据分布模型采用 CRUSH 算法</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/FTWWBPCHG75C1QU9K_F72.webp"></li></ul></li></ul><h3 id="单机数据库"><a href="#单机数据库" class="headerlink" title="单机数据库"></a>单机数据库</h3><ul><li>概览<ul><li>单机数据库 &#x3D; 单个计算机节点上的数据库系统</li><li><strong>事务在单机内执行，也可能通过网络交互实现分布式事务</strong><ul><li>关系型数据库</li><li>非关系型数据库</li></ul></li></ul></li><li>关系型数据库<ul><li>商业产品 Oracle 称王，开源产品<strong>MySQL</strong> &amp; <strong>PostgreSQL</strong>称霸</li><li>关系型数据库的通用组件：<ul><li>Query Engine——负责解析 query，生成查询计划</li><li>Txn Manager——负责事务并发管理</li><li>Lock Manager——负责锁相关的策略</li><li>Storage Engine——负责组织内存&#x2F;磁盘数据结构</li><li>Replication——负责主备同步</li></ul></li><li>关键内存数据结构：B-Tree、B+-Tree、LRU List 等</li><li>关键磁盘数据结构：WriteAheadLog（RedoLog）、Page</li><li><img src="https://img.lonesome.cn/blog/bytedance/U36CVB1LKX3F397JE_ALFY.webp"></li></ul></li><li>非关系型数据库<ul><li><strong>MongoDB</strong>、<strong>Redis</strong>、<strong>Elasticsearch</strong>三足鼎立</li><li>关系型数据库一般直接使用 SQL 交互，而非关系型数据库<strong>交互方式各不相同</strong></li><li>非关系型数据库的数据结构千奇百怪，没有关系约束后，<strong>schema 相对灵活</strong></li><li>不管是否关系型数据库，大家都在尝试支持<strong>SQL（子集）和“事务”</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/G91D4W3@DB@RACQPMHQ.webp"></li></ul></li><li>Elasticsearch 使用案例<ul><li><img src="https://img.lonesome.cn/blog/bytedance/YHGLRQDTXO4GXZK30W6L.webp"></li></ul></li></ul><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><ul><li>从单机到分布式数据库<ul><li>单机数据库遇到了哪些问题 &amp; 挑战，需要我们引入<strong>分布式架构</strong>来解决？<ul><li>容量</li><li>弹性</li><li>性价比</li></ul></li></ul></li><li>解决容量问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0ADRQT8RY50YDU0B6.webp"></li></ul></li><li>解决弹性问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0YM1U6QJW@OGXFKEW.webp"></li></ul></li><li>解决性价比问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1IQ9IOVQI8FLHWYQQ94GB.webp"></li></ul></li><li>More to Do<ul><li>单写 vs <strong>多写</strong></li><li>从磁盘弹性到<strong>内存弹性</strong></li><li><strong>分布式事务</strong>优化</li></ul></li></ul><h2 id="新技术演进"><a href="#新技术演进" class="headerlink" title="新技术演进"></a>新技术演进</h2><ul><li>概览<ul><li><img src="https://img.lonesome.cn/blog/bytedance/MRYS352X4UW70H9US.webp"></li></ul></li><li>SPDK<ul><li><img src="https://img.lonesome.cn/blog/bytedance/8IXGJW0VDN9NQ1L6ZLY.webp"></li></ul></li><li>AI &amp; Storage<ul><li>AI 领域相关技术，如 Machine Learning 在很多领域：如推荐、风控、视觉领域证明了有效性</li><li><img src="https://img.lonesome.cn/blog/bytedance/2HDQ7CAXO3D51CES0.webp"></li></ul></li><li>高性能硬件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4DSZ57JZB25JWHVMNNI.webp"></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img.lonesome.cn/blog/bytedance/KGDUN@6YBT7OUZP5PB.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经典案例&quot;&gt;&lt;a href=&quot;#经典案例&quot; class=&quot;headerlink&quot; title=&quot;经典案例&quot;&gt;&lt;/a&gt;经典案例&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据的产生&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/byt</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="存储" scheme="https://lonesome.cn/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>RPC原理与实现</title>
    <link href="https://lonesome.cn/posts/rpc-principle-and-implementation/"/>
    <id>https://lonesome.cn/posts/rpc-principle-and-implementation/</id>
    <published>2023-02-10T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:22.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="本地函数调用"><a href="#本地函数调用" class="headerlink" title="本地函数调用"></a>本地函数调用</h3><p><img src="https://img.lonesome.cn/blog/bytedance/TRPJ39738A38QJL28O33.webp"></p><ol><li>将 a 和 b 的值压栈</li><li>通过函数指针找到 calculate 函数，进入函数取出栈中的值 2 和 3，将其赋予 x 和 y</li><li>计算 x * y，并将结果存在 z</li><li>将 z 的值压栈，然后从 calculate 返回</li><li>从栈中取出 z 返回值，并赋值给 result</li></ol><h3 id="远程函数调用（RPC-Remote-Procedure-Calls）"><a href="#远程函数调用（RPC-Remote-Procedure-Calls）" class="headerlink" title="远程函数调用（RPC-Remote Procedure Calls）"></a>远程函数调用（RPC-Remote Procedure Calls）</h3><p><img src="https://img.lonesome.cn/blog/bytedance/7JFHRZWK39EJ7P5GHCPG.webp"></p><ul><li>RPC 需要解决的问题<ul><li>函数映射</li><li>数据转换成字节流</li><li>网络传输</li></ul></li></ul><h3 id="RPC-概念模型"><a href="#RPC-概念模型" class="headerlink" title="RPC 概念模型"></a>RPC 概念模型</h3><p><img src="https://img.lonesome.cn/blog/bytedance/512XM2K7JJZM3IY11.webp"></p><p>1984 年 Neison 发表了论文《Implementing Remote Procedure Calls》，其中提出了 RPC 的过程由 5 个模型组成：User、User-Stub、RPC-Runtime、Server-Stub、Server</p><h3 id="一次-RPC-的完整过程"><a href="#一次-RPC-的完整过程" class="headerlink" title="一次 RPC 的完整过程"></a>一次 RPC 的完整过程</h3><p><img src="https://img.lonesome.cn/blog/bytedance/U1HJEDMCZ41V08CG.webp"></p><ul><li>IDL（Interface description language）文件<ul><li>IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信</li></ul></li><li>生成代码<ul><li>通过编译器工具把 IDL 文件转换成语言对应的静态库</li></ul></li><li>编解码<ul><li>从内存中表示到字节序列的转换称为编码，反之为解码，也常叫做序列化和反序列化</li></ul></li><li>通信协议<ul><li>规范了数据在网络中的传输内容和格式，除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</li></ul></li><li>网络传输<ul><li>通常基于成熟的网络库走 TCP&#x2F;UDP 传输</li></ul></li></ul><h3 id="RPC-的好处"><a href="#RPC-的好处" class="headerlink" title="RPC 的好处"></a>RPC 的好处</h3><p><img src="https://img.lonesome.cn/blog/bytedance/AFNBEUZNZ7R6PDBA6N5EH.webp"></p><ol><li>单一职责，有利于分工协作和运维开发</li><li>可扩展性强，资源使用率更优</li><li>故障隔离，服务的整体可靠性更高</li></ol><h3 id="RPC-带来的问题"><a href="#RPC-带来的问题" class="headerlink" title="RPC 带来的问题"></a>RPC 带来的问题</h3><ol><li>服务宕机，对方应该如何处理？</li><li>在调用过程中发生网络异常如何保证消息的可达性？</li><li>请求量暴增导致服务无法及时处理，有哪些应对措施？</li></ol><h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><h3 id="以-Apache-Thrift-为例"><a href="#以-Apache-Thrift-为例" class="headerlink" title="以 Apache Thrift 为例"></a>以 Apache Thrift 为例</h3><p><img src="https://img.lonesome.cn/blog/bytedance/MOJJ1YQRR@B8H8VY.webp"></p><h3 id="编解码层"><a href="#编解码层" class="headerlink" title="编解码层"></a>编解码层</h3><p><img src="https://img.lonesome.cn/blog/bytedance/FHORA5PC1MY45IT777ZHY.webp"></p><ul><li>生成代码<ul><li><img src="https://img.lonesome.cn/blog/bytedance/9YHHPWC7UP8C01WKT4O@A24.webp"></li></ul></li><li>数据格式<ul><li>语言特定的格式<ul><li>许多编程语言都内建了将内存对象编码为字节序列的支持，例如 Java 有 Java.io.Serializable</li></ul></li><li>文本格式<ul><li>JSON、XML、CSV 等文本格式，具有人类可读性</li></ul></li><li>二进制编码<ul><li>具备跨语言和高性能等优点，常见有 Thrift 的 BinaryProtocol，Protobuf 等</li></ul></li></ul></li><li>二进制编码<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DZMPLP@PCD3EZW71Q.webp"></li><li>TLV 编码<ul><li><ul><li>Tag：标签，可以理解为类型</li></ul></li><li><ul><li>Lenght：长度</li></ul></li><li><ul><li>Value：值，Value 也可以是个 TLV 结构</li></ul></li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/DEUD@BFR@W2YKJRQZF.webp"></li></ul></li><li>选型<ul><li>兼容性<ul><li>支持自动增加新的字段，而不影响老的服务，这将提高系统的灵活性</li></ul></li><li>通用性<ul><li>支持跨平台、跨语言</li></ul></li><li>性能<ul><li>从空间和时间两个维度来考虑，也就是编码后数据大小和编码耗费时长</li></ul></li></ul></li></ul><h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><p><img src="https://img.lonesome.cn/blog/bytedance/YBC83@JWP2L7P@8_6.webp"></p><ul><li>概念<ul><li>特殊结束符：一个特殊字符作为每个协议单元结束的标识<ul><li><img src="https://img.lonesome.cn/blog/bytedance/CUR3O6FWNIPF5O7HMOSVK.webp"></li></ul></li><li>变长协议：以定长加不定长的部分组成，其中定长的部分需要描述不定长的内容长度<ul><li><img src="https://img.lonesome.cn/blog/bytedance/POY2ZMTOD62ILMMQDFA9M.webp"></li></ul></li></ul></li><li>协议构造<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DGMZFYCGOKKXLY2OUW2.webp"></li><li>LENGTH：数据包大小，不包含自身</li><li>HEADER MAGIC：标识版本信息，协议解析时候快速校验</li><li>SEQUENCE NUMBER：表示数据包的 seqID，可用于多路复用，单连接内递增</li><li>HEADER SIZE：头部长度，从第 14 个字节开始计算一直到 PAYLOAD 前</li><li>PROTOCAL ID：编解码方式，有 Binary 和 Compact 两种</li><li>TRANSFORM ID：压缩方式，如 zlib 和 snappy</li><li>INFO ID：传递一些定制的 meta 信息</li><li>PAYLOAD：消息体</li></ul></li><li>协议解析<ul><li><img src="https://img.lonesome.cn/blog/bytedance/26OR90Z3Y9EBFXTRV0T.webp"></li></ul></li></ul><h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><p><img src="https://img.lonesome.cn/blog/bytedance/VSOIV45FZUUNWW_I.webp"></p><ul><li>Sockets API<ul><li><img src="https://img.lonesome.cn/blog/bytedance/ZWWBGERE2L3HCMI55V3GBH.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/BIXBO4WW2LMFIKXD.webp"></li></ul></li><li>网络库<ul><li>提供易用 API<ul><li>封装底层 Socket API</li><li>连接管理和事件分发</li></ul></li><li>功能<ul><li>协议支持：tcp、udp 和 uds 等</li><li>优雅退出、异常处理等</li></ul></li><li>性能<ul><li>应用层 buffer 减少 copy</li><li>高性能定时器、对象池等</li></ul></li></ul></li></ul><h2 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>保障策略<ul><li>熔断：保护调用方，防止被调用的服务出现问题而影响到整个链路</li><li>限流：保护被调用方，防止大流量把服务压垮</li><li>超时控制：避免浪费资源在不可用节点上</li><li><img src="https://img.lonesome.cn/blog/bytedance/S6A3H_LMNOXI_7XYQQ.webp"></li></ul></li><li>请求成功率<ul><li>负载均衡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/39IN3BZXND36SZYKK.webp"></li></ul></li><li>重试<ul><li><img src="https://img.lonesome.cn/blog/bytedance/G2T02HQNLOBUN7MEJE.webp"></li></ul></li></ul></li><li>长尾请求<ul><li>Backup Request<ul><li><img src="https://img.lonesome.cn/blog/bytedance/61E7E8SJS8S@3WELA.webp"></li></ul></li></ul></li><li>注册中间件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/JU7W5IZQRU5F@IE9G6N1S.webp"></li></ul></li></ul><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul><li>开箱即用<ul><li>合理的默认参数选项，丰富的文档</li></ul></li><li>周边工具<ul><li>生成代码工具，脚手架工具</li></ul></li></ul><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ul><li>Middleware</li><li>Option</li><li>编解码层</li><li>协议层</li><li>网络传输层</li><li>代码生成工具插件扩展</li><li><img src="https://img.lonesome.cn/blog/bytedance/QP0@QS03672V40WMI5E.webp"></li></ul><h3 id="观测性"><a href="#观测性" class="headerlink" title="观测性"></a>观测性</h3><ul><li>Log、Metric、Tracing</li><li>内置观测性服务</li><li><img src="https://img.lonesome.cn/blog/bytedance/WPVDCEY8H8K94XZTD9M.webp"></li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>场景<ul><li>单机多机</li><li>单连接多连接</li><li>单&#x2F;多 client 单&#x2F;多 server</li><li>不同大小的请求包</li><li>不同请求类型：例如 pingpong、streaming 等</li></ul></li><li>目标<ul><li>高吞吐</li><li>低延迟</li></ul></li><li>手段<ul><li>连接池</li><li>多路复用</li><li>高性能编解码协议</li><li>高性能网络库</li></ul></li></ul><h2 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h2><h3 id="整体架构-Kitex"><a href="#整体架构-Kitex" class="headerlink" title="整体架构-Kitex"></a>整体架构-Kitex</h3><p><img src="https://img.lonesome.cn/blog/bytedance/2M60HMIITZ74HLUR4YY.webp"></p><ul><li>Kitex Core<ul><li>核心组件</li></ul></li><li>Kitex Byted<ul><li>与公司内部基础设施集成</li></ul></li><li>Kitex Tool<ul><li>代码生成工具</li></ul></li></ul><h3 id="自研网络库"><a href="#自研网络库" class="headerlink" title="自研网络库"></a>自研网络库</h3><ul><li>背景<ul><li>原生库无法感知连接状态问题<ul><li>在使用连接池时，池中存在失效链接，影响连接池的复用</li></ul></li><li>原生库存在 goroutine 暴涨的风险<ul><li>一个连接一个 goroutine 的模式，由于连接利用率低下，存在大量 goroutine 占用调度开销，影响性能</li></ul></li></ul></li><li>Netpoll<ul><li>解决无法感知连接状态问题<ul><li>引入 epoll 主动监听机制，感知连接状态</li></ul></li><li>解决 goroutine 暴涨的风险<ul><li>建议 goroutine 池，复用 goroutine</li></ul></li><li>提升性能<ul><li>引入 Nocopy Buffer，向上层提供 NoCopy 的调用接口，编解码层面零拷贝</li></ul></li></ul></li></ul><h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><ul><li>支持多协议，也支持灵活的自定义协议扩展</li><li><img src="https://img.lonesome.cn/blog/bytedance/28NXVC1IYITITAF7QHV.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/IFGHVH3ABFLQXASE_V.webp"></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>网络库优化<ul><li>调度优化<ul><li>epoll_wait 在调度上的控制</li><li>gopool 重用 goroutine 降低同时运行协程数</li></ul></li><li>LinkBuffer<ul><li>读写并行无锁，支持 nocopy 地流式读写</li><li>高效扩缩容</li><li>Nocopy Buffer 池化，减少 GC</li></ul></li><li>Pool<ul><li>引入内存池和对象池，减少 GC 开销</li></ul></li></ul></li><li>编解码优化<ul><li>Codegen<ul><li>预计算并预分配内存，减少内存操作次数，包括次数分配和拷贝</li><li>Inline 减少函数调用次数和减少不必要的反射操作等</li><li>自研了 Go 语言实现的 Thrift IDL 解析和代码生成器，支持完善的 Thrift IDL 语法和语义检查，并支持了插件机制 - Thriftgo</li></ul></li><li>JIT<ul><li>使用 JIT 编译技术改善用户体验的同时带来更强的编解码性能，减轻用户维护生成代码的负担</li><li>基于 JIT 编译技术的高性能动态 Thrift 编解码器 - Frugal</li></ul></li></ul></li></ul><h3 id="合并部署"><a href="#合并部署" class="headerlink" title="合并部署"></a>合并部署</h3><ul><li>微服务过微，传输和序列化开销越来越大</li><li>将亲和性强的服务实例尽可能调度到同一个物理机，远程 RPC 调用优化为本地 IPC 调用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4CNU55C9G4Z9B8VI@O.webp"><img src="https://img.lonesome.cn/blog/bytedance/RVAG16RR2VC870XCOT.webp"></li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/JMH8_L9PG2NMB6JVQ.webp"></li><li>中心化的部署调度和流量控制</li><li>基于共享内存的通信协议</li><li>定制化的服务发现和连接池实现</li><li>定制化的服务启动和监听逻辑</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;本地函数调用&quot;&gt;&lt;a href=&quot;#本地函数调用&quot; class=&quot;headerlink&quot; title=&quot;本地函数调</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="RPC" scheme="https://lonesome.cn/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>消息队列原理与实战</title>
    <link href="https://lonesome.cn/posts/message-queue-principle-and-practice/"/>
    <id>https://lonesome.cn/posts/message-queue-principle-and-practice/</id>
    <published>2023-02-09T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:21.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li><p>案例一：系统崩溃</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/5R89LNJTF647MDEXS.webp"></li><li>解决方案：解耦<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4WNK6CJEEMGECSKHCPMC.webp"></li></ul></li></ul></li><li><p>案例二：服务能力有限</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/MNEQBGWPC8_M8VBUPBS.webp"></li><li>解决方案：削峰<ul><li><img src="https://img.lonesome.cn/blog/bytedance/VBLQS58S4FIILB_196D.webp"></li></ul></li></ul></li><li><p>案例三：链路耗时长尾</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/9VWDDLW20T2U18@DFSJ.webp"></li><li>解决方案：异步<ul><li><img src="https://img.lonesome.cn/blog/bytedance/I64F3@AHGYM7HCGH15.webp"></li></ul></li></ul></li><li><p>案例四：日志存储</p><ul><li>服务器故障日志丢失</li><li>解决方案：<ul><li><img src="https://img.lonesome.cn/blog/bytedance/K_4XQ0ZIMSX5YH530L.webp"></li></ul></li></ul></li><li><p>什么是消息队列？</p><ul><li>消息队列（MQ），指保存消息的一个容器，本质是个队列，但这个队列需要支持<strong>高吞吐、高并发、并且高可用</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/C3TFQIP0H0JIW_CM.webp"></li></ul></li></ul><h2 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h2><h3 id="消息队列发展历程"><a href="#消息队列发展历程" class="headerlink" title="消息队列发展历程"></a>消息队列发展历程</h3><p><img src="https://img.lonesome.cn/blog/bytedance/OHZDGHXJR82MSNC.webp"></p><h3 id="业内消息队列对比"><a href="#业内消息队列对比" class="headerlink" title="业内消息队列对比"></a>业内消息队列对比</h3><p><img src="https://img.lonesome.cn/blog/bytedance/R3YSMQYA6C5OLP.webp"></p><h2 id="消息队列-Kafka"><a href="#消息队列-Kafka" class="headerlink" title="消息队列-Kafka"></a>消息队列-Kafka</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img src="https://img.lonesome.cn/blog/bytedance/H236IBJV5VLNT@VP@6WHT5.webp"></p><h3 id="如何使用-Kafka"><a href="#如何使用-Kafka" class="headerlink" title="如何使用 Kafka"></a>如何使用 Kafka</h3><p><img src="https://img.lonesome.cn/blog/bytedance/7UN0I5IT52B3E73IFST4L.webp"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img.lonesome.cn/blog/bytedance/AJ82YE_0QMJ@6MXRU.webp"></p><ul><li><p>Topic：逻辑队列，不同 Topic 可以建立不同的 Topic</p></li><li><p>Cluster：物理集群，每个集群中可以建立多个不同的 Topic</p></li><li><p>Producer：生产者，负责将业务消息发送到 Topic 中</p></li><li><p>Consumer：消费者，负责消费 Topic 中的消息</p></li><li><p>ConsumerGroup：消费者组，不同组 Consumer 消费进度互不干涉</p></li><li><p>Offset：消息在 partition 内的相对位置信息，可以理解为唯一 ID，在 partition 内部严格递增</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/286K1OY8M3SLGDY7BCP4G.webp"></li></ul></li><li><p>Replica：每个分片有多个 Replica，Leader Replica 将会从 ISR 中选出</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/VEJW8PF@2QN2M6CIOU7.webp"></li></ul></li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p><img src="https://img.lonesome.cn/blog/bytedance/D8HND8S@QPRK2VLHQ2EPX3.webp"></p><h3 id="Kafka-架构"><a href="#Kafka-架构" class="headerlink" title="Kafka 架构"></a>Kafka 架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/FKJ81SZTZPAQJR376.webp"></p><h3 id="一条消息的自述"><a href="#一条消息的自述" class="headerlink" title="一条消息的自述"></a>一条消息的自述</h3><ul><li><img src="https://img.lonesome.cn/blog/bytedance/3XM6AAEWBXLAJ8PF.webp"><ul><li>从一条消息的视角，看看为什么 Kafka 能支撑这么高的吞吐？</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/NXTS0QLQVHPOWV8@MQ9Q.webp"><ul><li>如果发送一条消息，等到其成功后再发一条会有什么问题？</li></ul></li></ul><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><ul><li>批量发送<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4YD6JMHGCZFAI_NS2.webp"></li><li>如果消息量很大，网络宽带不够用，如何解决？</li></ul></li><li>数据压缩<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OP507PS2_YM@MV57XY1.webp"></li></ul></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><ul><li>数据的存储<ul><li><img src="https://img.lonesome.cn/blog/bytedance/USQOFQGQ4PGJ6W.webp"></li><li>如何存储到磁盘？</li><li>消息文件结构<ul><li><img src="https://img.lonesome.cn/blog/bytedance/6QZ60UO5Z0C00B8M@UC86.webp"></li><li>数据路径：&#x2F;Topic&#x2F;Partition&#x2F;Segment&#x2F;(log | index |timeindex | …)</li></ul></li></ul></li><li>磁盘结构<ul><li>移动磁头找到对应磁道，磁盘转动。找到对应扇区，最后写入，寻道成本比较高，因此顺序可以减少寻道所带来的时间成本</li><li><img src="https://img.lonesome.cn/blog/bytedance/D8HND8S@QPRK2VLHQ2EPX3.webp"></li></ul></li><li>顺序写<ul><li><img src="https://img.lonesome.cn/blog/bytedance/7AD4YU@XHHCUJDD9X80@OG.webp"></li><li>采用顺序写的方式进行写入，以提高写入效率</li></ul></li><li>如何找到消息<ul><li>Consumer 通过发送 FetchRequest 请求消息数据，Broker 会将指定 Offset 处的消息，按照时间窗口和消息大小窗口发送给 Consumer，<strong>寻找数据这个细节是如何做到的呢？</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/4XV_1C0X_5@HMRYXR6O.webp"></li><li>偏移量索引数据<ul><li>目标：寻找 offset &#x3D; 28</li><li><img src="https://img.lonesome.cn/blog/bytedance/4G5SK7ZFRPNYRMZFXE.webp"></li><li>二分找到小于目标 offset 的最大文件</li><li><img src="https://img.lonesome.cn/blog/bytedance/W_CRVSDH_1XJ03Y2EQ7V.webp"></li></ul></li><li>时间戳索引文件<ul><li>二分找到小于目标时间戳最大的索引位置，在通过寻找 offset 的方式找到最终数据</li><li><img src="https://img.lonesome.cn/blog/bytedance/W7E2YS7VCNJKE2WN0OM.webp"></li></ul></li></ul></li><li>传统数据拷贝<ul><li><img src="https://img.lonesome.cn/blog/bytedance/057TA64BORKKJH23OQ4J5.webp"></li></ul></li><li>零拷贝<ul><li><img src="https://img.lonesome.cn/blog/bytedance/6CCGG60GGVYWECA74X09.webp"></li></ul></li></ul><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><ul><li>消息的接收端<ul><li><img src="https://img.lonesome.cn/blog/bytedance/093Q7M1S9EQED@9.webp"></li><li>如何解决 Partition 在 Consumer Group 中的分配问题？</li></ul></li><li>Low Level<ul><li>通过手动进行分配，哪一个 Consumer 消费哪一个 Partition 完全由业务来决定</li><li><img src="https://img.lonesome.cn/blog/bytedance/S8HHQZL3C7UV8IR4I63L6.webp"></li><li>这种方式的缺点是什么？<ul><li>如果 Consumer3 挂掉了，7，8 分片就停止消费了</li><li>如果新增了一台 Consumer4 ，需要重新停掉整个集群，重新修改配置再上线，保证 Consumer4 也可以消费数据</li></ul></li></ul></li><li>High Level<ul><li><img src="https://img.lonesome.cn/blog/bytedance/D_@6EYBYRJNWATDUQNR4Q.webp"></li><li>Rebalance<ul><li><img src="https://img.lonesome.cn/blog/bytedance/3O5HWNT_WN_JILBC6I.webp"></li></ul></li></ul></li></ul><h4 id="一些可以帮-Kafka-提高吞吐或者稳定性的功能"><a href="#一些可以帮-Kafka-提高吞吐或者稳定性的功能" class="headerlink" title="一些可以帮 Kafka 提高吞吐或者稳定性的功能"></a>一些可以帮 Kafka 提高吞吐或者稳定性的功能</h4><ul><li>Producer：批量发送、数据压缩</li><li>Broker：顺序写，消息索引，零拷贝</li><li>Consumer：Reblance</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>数据复制问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OVSR_5K56PP9IK2@8GN2.webp"></li></ul></li><li>重启操作<ul><li><img src="https://img.lonesome.cn/blog/bytedance/A3GG44EYVLU61CKC.webp"></li></ul></li><li>替换、扩容、缩容<ul><li><img src="https://img.lonesome.cn/blog/bytedance/R14137A9ZNX_31W.webp"></li></ul></li><li>负载不均衡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WCFDEY@ZHG2DFJAYK@S.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/ZMIGNAO2@KRIJKZB.webp"></li></ul></li><li>问题总结<ul><li>运维成本高</li><li>对于负载不均衡的场景，解决方案复杂</li><li>没有自己的缓存，完全依赖 Page cache</li><li>Controller 和 Coordinator 和 Broker 在同一进程中，大量 IO 会造成其性能下降</li></ul></li></ul><h2 id="消息队列-BMQ"><a href="#消息队列-BMQ" class="headerlink" title="消息队列-BMQ"></a>消息队列-BMQ</h2><h3 id="BMQ-简介"><a href="#BMQ-简介" class="headerlink" title="BMQ 简介"></a>BMQ 简介</h3><p>兼容 Kafka 协议，存算分离，云原生消息队列</p><h3 id="BMQ-介绍"><a href="#BMQ-介绍" class="headerlink" title="BMQ 介绍"></a>BMQ 介绍</h3><p><img src="https://img.lonesome.cn/blog/bytedance/CHJ3VZQO_FHB30A.webp"></p><h3 id="运维操作对比"><a href="#运维操作对比" class="headerlink" title="运维操作对比"></a>运维操作对比</h3><p><img src="https://img.lonesome.cn/blog/bytedance/UHWJ6@VNJYLSSRP3.webp"></p><h3 id="HDFS-写文件流程"><a href="#HDFS-写文件流程" class="headerlink" title="HDFS 写文件流程"></a>HDFS 写文件流程</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ZFPGPGXJE42J64@STF4.webp"></p><h3 id="BMQ-文件结构"><a href="#BMQ-文件结构" class="headerlink" title="BMQ 文件结构"></a>BMQ 文件结构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/HW_U7ZWQRBE@C_SINGUF.webp"></p><h3 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h3><ul><li>Partition 状态机<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@8T1TWUKNN@IUYD90D@S8R.webp"></li><li>保证对于任意分片在同一时刻只能在一个 Broker 上存活</li></ul></li><li>写文件流程<ul><li><img src="https://img.lonesome.cn/blog/bytedance/W7HZJG5W7M3DZKY_M.webp"></li></ul></li><li>写文件 Failover<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@8IVRUSE9R8XTBVB9A.webp"></li><li>如果 DataNode 节点挂了或者是其他原因导致我们写文件失败，应该如何处理？</li></ul></li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p><img src="https://img.lonesome.cn/blog/bytedance/9KPFX3ETDHRXMJY96.webp"></p><h3 id="多机房部署"><a href="#多机房部署" class="headerlink" title="多机房部署"></a>多机房部署</h3><p><img src="https://img.lonesome.cn/blog/bytedance/VA6D5LMEPCUY7PI9_Y1.webp"></p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p><img src="https://img.lonesome.cn/blog/bytedance/@1NWYXAVF4H0S40S.webp"></p><h4 id="泳道消息"><a href="#泳道消息" class="headerlink" title="泳道消息"></a>泳道消息</h4><p><img src="https://img.lonesome.cn/blog/bytedance/JLXG@FNFN56X3P4WJ.webp"></p><ul><li>BOE：Bytedance Offline Environment，是一套完全独立的线下机房环境</li><li>PPE：Product Preview Environment，即产品预览环境</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/LASOSIY_2R0015B.webp"></p><p>多个人同时测试，需要等待上一个人测试完成</p><p><img src="https://img.lonesome.cn/blog/bytedance/Z@XGRL4Y0C93HO7LV.webp"></p><p>每多一个测试人员，都需要重新搭建一个相同配置的 Topic，造成人力和资源的浪费</p><p><img src="https://img.lonesome.cn/blog/bytedance/M37CES6P069SSVQ2S49.webp"></p><p>对于 PPE 的消费者来说，资源没有生产环境多，所以无法承受生产环境的流量</p><p><img src="https://img.lonesome.cn/blog/bytedance/2VNPY@_Z413FP_28VGZ9.webp"></p><p>解决主干泳道流量隔间问题以及泳道资源重复创建问题</p><h4 id="Databus"><a href="#Databus" class="headerlink" title="Databus"></a>Databus</h4><ul><li><img src="https://img.lonesome.cn/blog/bytedance/7R74X6ZCCAU@11RR76.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/I55_JIW_LGGLT3QHAG0.webp"></li><li>直接使用原生 SDK 会有什么问题？<ul><li>客户端配置较为复杂</li><li>不支持动态配置</li><li>对于 latency 不是很敏感的业务，batch 效率不佳</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/ABASXFFIB3RCQHA8B_D.webp"><ul><li>简化消息队列客户端复杂配置</li><li>解耦业务与 Topic</li><li>缓解集群压力，提高吞吐</li></ul></li></ul><h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p><img src="https://img.lonesome.cn/blog/bytedance/J_JD10LJ1FC4MRDRDJ.webp"></p><p>是否可以通过多机房部署的方式，解决跨 Region 读写的问题？</p><p><img src="https://img.lonesome.cn/blog/bytedance/XWO3_2YP755F1CJ.webp"></p><p>使用 Mirror 通过最终一致的方式，解决跨 Region 读写问题</p><h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><p><img src="https://img.lonesome.cn/blog/bytedance/@DWWONC1L_QQNA77ZR8D.webp"></p><p>如果希望通过写入的 LogId、UserId 或者其他的业务字段进行消费的查询，应该怎么做？</p><p><img src="https://img.lonesome.cn/blog/bytedance/LJJ59FDWF379YIIXOK7.webp"></p><p>直接在 BMQ 中将数据结构化，配置索引 DDL，异步构建索引后，通过 Index Query 服务读出数据</p><h4 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h4><p>Apache Parquet 是 Hadoop 生态圈中一钟<strong>新型列式存储格式</strong>，它可以兼容 Hadoop 生态圈中大多数计算框架（Hadoop、Spark 等），被多种查询引擎支持（Hive、Impala、Drill 等）</p><p><img src="https://img.lonesome.cn/blog/bytedance/OUULDVHM2Z1FWC5ZGPI.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/CK4@N2YJIFBZ2MPGM.webp"></p><p>直接在 BMQ 中将数据结构化，通过 Parquet Engine，可以使用不同的方式构建 Parquet 格式文件</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>BMQ 的架构模型（解决 Kafka 存在的问题）</li><li>BMQ 读写流程（Failover 机制，写入状态机）</li><li>BMQ 高级特性（泳道、Databus、Mirror、Index、Parquet）</li></ul><h2 id="消息队列-RocketMQ"><a href="#消息队列-RocketMQ" class="headerlink" title="消息队列-RocketMQ"></a>消息队列-RocketMQ</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>例如，针对电商业务线，其业务涉及广泛，如注册、订单、库存、物流等；同时，也会涉及许多业务峰值时刻，如秒杀活动、周年庆、定期特惠等</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ZHWCSJUGX9XVS2@WAOE.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/8P8TRU0I9XVJCZMAYA52E.webp"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/KPRO441WIKN160T0D.webp"></p><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p><img src="https://img.lonesome.cn/blog/bytedance/0E2QDIH1YRNIR@UYR2JX.webp"></p><h3 id="高级特性-1"><a href="#高级特性-1" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="事务场景"><a href="#事务场景" class="headerlink" title="事务场景"></a>事务场景</h4><p><img src="https://img.lonesome.cn/blog/bytedance/5U2YX97HQZ2XH_0J4.webp"></p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p><img src="https://img.lonesome.cn/blog/bytedance/3W_1D3JCQ9GWE6_26X.webp"></p><h4 id="延迟发送"><a href="#延迟发送" class="headerlink" title="延迟发送"></a>延迟发送</h4><p><img src="https://img.lonesome.cn/blog/bytedance/B51TNYQNU6DU77DGS.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/@DZB8W8FMY3SHQH4G6.webp"></p><h4 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h4><p><img src="https://img.lonesome.cn/blog/bytedance/HNYRRDHCLDM9_XUX4.webp"></p><h4 id="处理失败"><a href="#处理失败" class="headerlink" title="处理失败"></a>处理失败</h4><p><img src="https://img.lonesome.cn/blog/bytedance/7BWP4NK3CRUU51HX3.webp"></p><p>该如何处理失败的消息呢？</p><h4 id="消费重试和死信队列"><a href="#消费重试和死信队列" class="headerlink" title="消费重试和死信队列"></a>消费重试和死信队列</h4><p><img src="https://img.lonesome.cn/blog/bytedance/MKD1TP@4NWNWDQCKTBK.webp"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>RocketMQ 的基本概念（Queue、Tag）</li><li>RocketMQ 的底层原理（架构模型、存储模型）</li><li>RocketMQ 的高级特性（事务消息、重试和死信队列、延迟队列）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;案例一：系统崩溃&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="消息队列" scheme="https://lonesome.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式定时任务</title>
    <link href="https://lonesome.cn/posts/distributed-scheduled-tasks/"/>
    <id>https://lonesome.cn/posts/distributed-scheduled-tasks/</id>
    <published>2023-02-08T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:22.265Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.lonesome.cn/blog/bytedance/TA47SKRT9ATJC9J.webp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="春节集卡瓜分-20-亿"><a href="#春节集卡瓜分-20-亿" class="headerlink" title="春节集卡瓜分 20 亿"></a>春节集卡瓜分 20 亿</h3><p>作为后端开发同学，怎样设计最终开奖环节技术方案？</p><ul><li>业务流程<ul><li>定时扫描抖音用户集卡状态</li><li>汇总计算用户的瓜分金额</li><li>定时开奖</li><li><img src="https://img.lonesome.cn/blog/bytedance/MGBJSUYLQLJYPH9E.webp"></li></ul></li><li>技术体量<ul><li>亿级用户规模</li><li>十亿级资金规模</li><li>百万级读写 QPS</li></ul></li><li>方案引出<ul><li>自动化 + 定时执行 + 海量数据 + 高效稳定 &#x3D; 分布式定时任务</li></ul></li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><h4 id="Windows-批处理"><a href="#Windows-批处理" class="headerlink" title="Windows 批处理"></a>Windows 批处理</h4><ul><li>Case 1：10 分钟后 Windows 电脑自动关机<ul><li>Step1：桌面空白处右键单机-新建-文本文档</li><li>Step2：更改文件名和后缀为”自动关机.bat“</li><li>Step3：修改文件内容为”Shutdown -s -t 600“，代表 10 分钟后关机</li><li>Step4：双击运行该批处理文件，电脑将会在 10 分钟之后自动关机</li></ul></li></ul><h4 id="Windows-任务计划程序"><a href="#Windows-任务计划程序" class="headerlink" title="Windows 任务计划程序"></a>Windows 任务计划程序</h4><ul><li>Case 2：每天 12:00 自动疫情打卡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/SZ5YULJLKZ7E64FK2F.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/X3HAUS8LIBA8OISZTNBIBG.webp"></li></ul></li></ul><h4 id="Linux-命令-CronJob"><a href="#Linux-命令-CronJob" class="headerlink" title="Linux 命令-CronJob"></a>Linux 命令-CronJob</h4><ul><li>Case 3：每天 02:30 定时清理机器日志<ul><li><img src="https://img.lonesome.cn/blog/bytedance/JT2_IQ36M2M@ZHX69L0.webp"></li></ul></li><li>Linux 系统命令，使用简单，稳定可靠</li><li>只能控制单台机器，且无法适用于其他操作系统</li></ul><h4 id="单机定时任务-Timer、Ticker"><a href="#单机定时任务-Timer、Ticker" class="headerlink" title="单机定时任务-Timer、Ticker"></a>单机定时任务-Timer、Ticker</h4><ul><li>Case 4：每隔 5 分钟定时刷新本地缓存数据<ul><li><img src="https://img.lonesome.cn/blog/bytedance/ED3OX5C4ON7U617DKN.webp"></li></ul></li><li>跨平台</li><li>仅单机可用</li></ul><h4 id="单机定时任务-ScheduledExecutorService"><a href="#单机定时任务-ScheduledExecutorService" class="headerlink" title="单机定时任务-ScheduledExecutorService"></a>单机定时任务-ScheduledExecutorService</h4><ul><li>case 5：每隔 5 分钟定时执行多个任务<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WQ7PHSVWBK6KJ60.webp"></li></ul></li><li>拥有线程池功能</li><li>仅单机可用</li></ul><h4 id="任务调度-Quartz"><a href="#任务调度-Quartz" class="headerlink" title="任务调度-Quartz"></a>任务调度-Quartz</h4><ul><li><img src="https://img.lonesome.cn/blog/bytedance/R8GZNHFKH2NHC52O.webp"></li><li>单任务极致控制</li><li>没有负载均衡机制</li></ul><h4 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h4><ul><li><img src="https://img.lonesome.cn/blog/bytedance/QP9PWR4XGECU4HVOX9UTT.webp"></li><li>平台化管理</li><li>分布式部署</li><li>支持海量数据</li></ul><h3 id="分布式定时任务-1"><a href="#分布式定时任务-1" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h3><ul><li>定义<ul><li>定时任务是指系统为了<strong>自动</strong>完成特定任务，<strong>实时、延时、周期</strong>性完成任务调度的过程</li><li>分布式定时任务是把分散的、可靠性差的定时任务纳入统一的<strong>平台</strong>，并实现集群管理调度和<strong>分布式部署</strong>的一种定时任务的管理方式</li></ul></li><li>按触发时机分类<ul><li>定时任务：特定时间触发，比如今天 15:06 执行</li><li>延时任务：延时触发，比如 10s 后执行</li><li>周期任务：固定周期时间，或固定频率周期调度触发，比如每天 12 点或者每隔 5 秒执行</li></ul></li><li>特点<ul><li>自动化：全自动完成定时任务的调度和执行</li><li>平台化：基于平台化的思维管控一系列的分布式定时任务</li><li>分布式：在分布式系统环境下运行任务调度，突破单机定时任务的性能瓶颈</li><li>伸缩性：采用集群方式部署，可以随时按需扩容</li><li>高可用：单点故障不影响最终任务结果，可以做到故障转移</li></ul></li><li>执行方式<ul><li>单机任务：随机触发一台机器执行任务，适用于计算量小，并发度低的任务</li><li>广播任务：广播到所有机器上执行同一个任务，比如所有机器一起清理日志</li><li>Map 任务：一个任务可以分出多个子任务，每个子任务负责一部分的计算，适用于计算量大，单机无法满足要求的任务</li><li>MapReduce 任务：在 Map 任务的基础上，还可以对所有子任务的结果做汇总计算，适用于计算量大，并且需要对子任务结果做汇总的任务</li></ul></li><li>执行方式 vs 春节集卡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5R5MFKYTZ@K8ANYH59X.webp"></li><li>发奖金额计算：MapReduce 任务</li><li>定时开奖：Map 任务</li></ul></li></ul><h3 id="业内定时任务框架"><a href="#业内定时任务框架" class="headerlink" title="业内定时任务框架"></a>业内定时任务框架</h3><p><img src="https://img.lonesome.cn/blog/bytedance/64QFGN7MCCMJ1O1TOM.webp"></p><h3 id="知识面扩充"><a href="#知识面扩充" class="headerlink" title="知识面扩充"></a>知识面扩充</h3><ul><li>分布式定时任务 VS 单机定时任务<ul><li>关系：<ul><li>都可以实现自动化的定时、延时、周期任务调度</li></ul></li><li>差异：<ul><li>分布式定时任务可支撑更大的业务体量</li><li>分布式定时任务的性能、伸缩性、稳定性更高</li></ul></li></ul></li><li>分布式定时任务 VS 大数据处理引擎<ul><li>关系：<ul><li>都可以对海量数据做处理</li><li>性能、伸缩性、稳定性都很高</li></ul></li><li>差异：<ul><li>定时并不是大数据处理引擎要解决的核心问题</li><li>大数据引擎往往致力于将源数据处理成结果数据，分布式定时任务除了能做这个之外，还可以调用 HTTP 和 RPC 服务</li></ul></li></ul></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><ul><li>分布式定时任务核心要解决<strong>触发、调度、执行</strong>三个关键问题<ul><li>触发器：Trigger，解析任务，生成触发事件</li><li>调度器：Scheduler，分配任务，管理任务生命周期</li><li>执行器：Executor，获取执行任务单元，执行任务逻辑</li></ul></li><li>除此之外，还需要提供一个控制台（Admin），提供任务管理和干预的功能</li><li><img src="https://img.lonesome.cn/blog/bytedance/OLPVDY8PGYWJCCGKNJV.webp"></li></ul><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><img src="https://img.lonesome.cn/blog/bytedance/EX6TV723_J6_FPT6.webp"></p><h4 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h4><p><img src="https://img.lonesome.cn/blog/bytedance/6_VS9ICP60G339TSQ9A.webp"></p><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://img.lonesome.cn/blog/bytedance/LGVA7U787LTEVLN54.webp"></p><ul><li>任务：Job，任务元数据</li><li>任务实例：JobInstance，任务运行的实例</li><li>任务结果：JobResult，任务实例运行的结果</li><li>任务历史：JobHistory，用户可以修改任务信息，任务实例对应的任务元数据可以不同，因而使用任务历史存储</li></ul><h4 id="任务元数据"><a href="#任务元数据" class="headerlink" title="任务元数据"></a>任务元数据</h4><p>任务元数据（Job）是用户对任务属性定义，包括任务类型调度时机、执行行为等</p><p><img src="https://img.lonesome.cn/blog/bytedance/CVDXZGXR3E3W3YGAJZ4C.webp"></p><h4 id="任务实例"><a href="#任务实例" class="headerlink" title="任务实例"></a>任务实例</h4><p>任务实例（JobInstance）是一个确定的 Job 的一次运行实例</p><p><img src="https://img.lonesome.cn/blog/bytedance/KF1BI338ET_EB@FN5.webp"></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="核心职责"><a href="#核心职责" class="headerlink" title="核心职责"></a>核心职责</h4><ul><li>核心职责<ul><li>给定一系列任务，解析他们的触发规则，在规定的时间点触发任务的调度</li></ul></li><li>设计约束<ul><li>需支持大量任务</li><li>需支持秒级的调度</li><li>周期任务需要多次执行</li><li>需保证秒级扫描的高性能，并避免资源浪费</li></ul></li></ul><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h4><p>定期扫描+延时消息（腾讯、字节方案）</p><p><img src="https://img.lonesome.cn/blog/bytedance/D11EH7LT2CTL8F3Y3M.webp"></p><h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h4><ul><li>时间轮（Quartz 所用方案）<ul><li>时间轮是一种高效利用线程资源进行批量化调度的一种调度模型，时间轮是一个存储环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表</li><li><img src="https://img.lonesome.cn/blog/bytedance/A7@LBZU6LPHTC_T.webp"></li></ul></li><li>目标：遍历任务列表，从中找出当前时间点需触发的任务列表<ul><li><img src="https://img.lonesome.cn/blog/bytedance/9K64MWXYGAO3840A28.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/S1SBMGXBJ@RWMBB@GU.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/8GCFM9_WGQA7KA6Z9ZCYP.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/34O3J5MAAFV8UINROQ33.webp"></li></ul></li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul><li>核心问题<ul><li>不同业务之间，任务的调度相互影响怎么办</li><li>负责扫描和触发的机器挂了怎么办</li></ul></li><li>解法思路<ul><li>存储上，不同国别、业务做资源隔离</li><li>运行时，不同国别、业务分开执行</li><li>部署时，采用多机房集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只被触发一次</li></ul></li></ul><h5 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h5><ul><li>单 Trigger 模式：<ul><li>会有单点故障</li><li>机器故障时平台崩溃</li></ul></li><li>Trigger 集群模式<ul><li>可避免单点故障</li><li>需要避免同一任务被多次触发，导致业务紊乱</li></ul></li></ul><h5 id="数据库行锁模式"><a href="#数据库行锁模式" class="headerlink" title="数据库行锁模式"></a>数据库行锁模式</h5><p>在触发调度之前，更新数据库中 JobInstance 的状态，成功枪锁才会触发调度</p><p><img src="https://img.lonesome.cn/blog/bytedance/7VTLV50RVFNX0CJ5W.webp"></p><h5 id="分布式锁模式"><a href="#分布式锁模式" class="headerlink" title="分布式锁模式"></a>分布式锁模式</h5><p>在触发调度之前，尝试抢占分布式锁，可使用 Redis 锁或 Zookeeper 锁</p><p><img src="https://img.lonesome.cn/blog/bytedance/R4CR9NPF34OBG2I@5O.webp"></p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h4 id="资源来源"><a href="#资源来源" class="headerlink" title="资源来源"></a>资源来源</h4><ul><li>业务系统提供机器资源<ul><li>使用该方案的公司：<ul><li>阿里、美团、字节等</li></ul></li><li>优点：<ul><li>任务执行逻辑与业务系统共用同一份资源，利用率更高</li></ul></li><li>缺点：<ul><li>更容易发生定时任务脚本影响在线服务的事故</li><li>不能由定时任务平台控制扩缩容</li></ul></li></ul></li><li>定时任务平台提供机器资源<ul><li>使用该方案的公司：<ul><li>字节等</li></ul></li><li>优点：<ul><li>任务执行逻辑与业务系统提供的在线服务隔离，避免相互影响</li><li>可以支持优雅的扩缩容</li></ul></li><li>缺点：<ul><li>消耗更多机器资源</li><li>需要额外为定时任务平台申请接口调用权限，而不能直接继承业务系统的权限</li></ul></li></ul></li></ul><h4 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h4><h5 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h5><ul><li>随机节点执行：选择集群中一个可用的执行节点执行调度任务，使用场景：定时对账</li><li>广播执行：在集群中所有的执行节点发布调度任务并执行，使用场景：批量运维</li><li>分片执行：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率，使用场景：海量日志统计</li><li><img src="https://img.lonesome.cn/blog/bytedance/RSVLTIXK7ZX6I0TJ.webp"></li></ul><h5 id="任务分片"><a href="#任务分片" class="headerlink" title="任务分片"></a>任务分片</h5><p>通过任务分片来提高任务执行的效率和资源的利用率</p><p><img src="https://img.lonesome.cn/blog/bytedance/GCLAZMMRO9SNLP6HD.webp"></p><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="任务编排"><a href="#任务编排" class="headerlink" title="任务编排"></a>任务编排</h5><p>使用有向无环图 DAG（Directed Acyclic Graph）进行可视化任务编排</p><p><img src="https://img.lonesome.cn/blog/bytedance/FV@XQFCN@SGRI3BFN87.webp"></p><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>确保部分执行单元任务失败时，任务最终成功</p><p><img src="https://img.lonesome.cn/blog/bytedance/1AVE3LTALJUEW72LV.webp"></p><h4 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h4><p>调度器可以集群部署，做到完全的无状态，靠消息队列的重试机制保障任务一定会被调度</p><p><img src="https://img.lonesome.cn/blog/bytedance/RAA8KQGL2H6WOTDSF8D.webp"></p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p><img src="https://img.lonesome.cn/blog/bytedance/AVT7EV6H0HM2WCWMVUF.webp"></p><h2 id="业务应用"><a href="#业务应用" class="headerlink" title="业务应用"></a>业务应用</h2><p>所有需要定时、延时、周期性执行任务的业务场景，都可以考虑使用分布式定时任务</p><p><img src="https://img.lonesome.cn/blog/bytedance/QFXRMYKHS1K7MBBC2.webp"></p><ul><li>其他解决方案<ul><li>发货后超过 10 天未收货时系统自动确认收货<ul><li>使用分布式定时任务的延时任务</li><li>使用消息队列的延时消息或者定时消息</li></ul></li><li>春节集卡活动统计完成集卡的用户个数和总翻倍数<ul><li>使用分布式定时任务的 MapReduce 任务</li><li>使用大数据离线处理引擎 Hive 离线做统计</li><li>使用大数据实时处理引擎 Fink 实时做累计</li></ul></li></ul></li><li>其他解决方案对比<ul><li><img src="https://img.lonesome.cn/blog/bytedance/32P8O53OK29@RWQF.webp"></li></ul></li></ul><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p><img src="https://img.lonesome.cn/blog/bytedance/XX1QFS7QKKZKVDAAB62.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/bytedance/TA47SKRT9ATJC9J.webp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="分布式" scheme="https://lonesome.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>黑灰产监控与防御</title>
    <link href="https://lonesome.cn/posts/black-and-gray-production-monitoring-and-defense/"/>
    <id>https://lonesome.cn/posts/black-and-gray-production-monitoring-and-defense/</id>
    <published>2023-02-06T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:21.451Z</updated>
    
    <content type="html"><![CDATA[<p>了解一些国内黑灰产的调研报告，推荐<a href="https://search.freebuf.com/search/?search=%E9%BB%91%E9%95%9C%E8%B0%83%E6%9F%A5#article">Freebuf 黑镜调查系列</a></p><h2 id="国内黑产介绍"><a href="#国内黑产介绍" class="headerlink" title="国内黑产介绍"></a>国内黑产介绍</h2><ul><li>一些常见的黑产<ul><li><img src="https://img.lonesome.cn/blog/bytedance/PQF0UCBE4NHSZZSNUK.webp"></li></ul></li><li>黑色产业链规模<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0EHS05Q6BNFI1ADBPICW.webp"></li></ul></li><li>黑色产业链结构（部分）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/72BU@KJAZ76K6W2JD.webp"></li></ul></li><li>黑产团伙的发展趋势<ul><li>规模化<ul><li>借助脚本、软件来实现攻击的批量化</li><li>上游各类资源丰富，大大降低攻击成本，同时攻击成功率也比较高</li></ul></li><li>组织化<ul><li>多数以工作室的形式运作</li><li>团伙内多人分工明确，合作紧密</li><li>某些黑产甚至成立了公司</li></ul></li><li>平台化<ul><li>今年来出现了很多平台级的爬虫、群控、钓鱼、木马、网络攻击、DDOS 攻击工具，攻击成本大大降低，且难以追查</li><li>各类平台将黑产手中零散的资源进行整合</li></ul></li></ul></li></ul><h2 id="常见的黑产技术分析"><a href="#常见的黑产技术分析" class="headerlink" title="常见的黑产技术分析"></a>常见的黑产技术分析</h2><ul><li>2018 年某银行业务逻辑漏洞（已修复）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/8SWPQDLIM1BBQ8@E9.webp"></li></ul></li><li>人脸识别对抗<ul><li>从照片到 3D 人脸模型</li></ul></li><li>地理位置对抗<ul><li>定位打卡</li><li>摇一摇附近的人</li><li>出租车抢单</li><li>某些线下使用的优惠</li><li>……</li></ul></li></ul><h2 id="安全防护体系的建设"><a href="#安全防护体系的建设" class="headerlink" title="安全防护体系的建设"></a>安全防护体系的建设</h2><ul><li>事前<ul><li>情报监控<ul><li>暗网</li><li>贴吧</li><li>TG</li><li>破解论坛</li></ul></li><li>SDLC</li><li>漏洞扫描</li></ul></li><li>事中<ul><li>渗透测试</li><li>威胁感知<ul><li>用户行为异常</li><li>接口数据异常</li><li>恶意流量检测</li></ul></li><li>风控&#x2F;安全策略</li></ul></li><li>事后<ul><li>威胁建模</li><li>攻击溯源</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/W7RVP3SLEJH4Y7FKG.webp"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解一些国内黑灰产的调研报告，推荐&lt;a href=&quot;https://search.freebuf.com/search/?search=%E9%BB%91%E9%95%9C%E8%B0%83%E6%9F%A5#article&quot;&gt;Freebuf 黑镜调查系列&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="黑灰产" scheme="https://lonesome.cn/tags/%E9%BB%91%E7%81%B0%E4%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你做系统设计</title>
    <link href="https://lonesome.cn/posts/system-design/"/>
    <id>https://lonesome.cn/posts/system-design/</id>
    <published>2023-02-05T06:45:00.000Z</published>
    <updated>2024-08-11T12:53:21.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统设计方法论"><a href="#系统设计方法论" class="headerlink" title="系统设计方法论"></a>系统设计方法论</h2><ul><li>为什么要做系统设计<ul><li>个人<ul><li>For 面试</li><li>个人能力提升</li><li>拓展技术视野</li></ul></li><li>工作<ul><li>业务驱动</li><li>系统重构</li><li>突破和创新</li></ul></li></ul></li><li>如何评估一个系统<ul><li>可用性</li><li>安全性</li><li>扩展性</li><li>易用性</li><li>性能</li><li>耦合性</li><li>可维护性</li><li>伸缩性</li></ul></li><li>系统设计的定义：为了达成某种目的，通过个体组成整体的过程<ul><li>系统<ul><li>关联的个体</li><li>规则运作</li><li>组成工作的整体</li></ul></li><li>设计<ul><li>设想和计划</li><li>目的</li><li>过程安排</li></ul></li></ul></li><li>如何做系统设计：4S 分析法<ul><li>场景分析（Scenario）<ul><li>什么系统，需要哪些功能，多大的并发量</li></ul></li><li>存储设计（Storage）<ul><li>数据如何组织，Sql 存储，NoSql 存储</li></ul></li><li>服务设计（Service）<ul><li>业务功能实现和逻辑整合</li></ul></li><li>可扩展性（Scale）<ul><li>解决设计缺陷，提高鲁棒性、扩展性</li></ul></li></ul></li><li>如何发现系统的瓶颈<ul><li>火焰图分析</li><li>链路分析</li><li>性能测试</li></ul></li><li>如何保证可用性和稳定性<ul><li>链路梳理<ul><li>核心链路</li><li>流量漏斗</li><li>强弱依赖</li></ul></li><li>可观测性<ul><li>链路追踪</li><li>核心监控</li><li>业务报警</li></ul></li><li>全链路测试<ul><li>压力测试</li><li>负载测试</li><li>容量测试</li></ul></li><li>稳定性控制<ul><li>系统限流</li><li>业务兜底</li><li>熔断降级</li></ul></li><li>容灾演练<ul><li>混沌工程</li><li>应急手册</li><li>容灾预案</li></ul></li></ul></li></ul><h2 id="电商秒杀业务介绍"><a href="#电商秒杀业务介绍" class="headerlink" title="电商秒杀业务介绍"></a>电商秒杀业务介绍</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="电商介绍"><a href="#电商介绍" class="headerlink" title="电商介绍"></a>电商介绍</h4><p><img src="https://img.lonesome.cn/blog/bytedance/XKGUUOTKT8NA4A06N.webp"></p><ul><li>商品：具有交易价值和属性的信息载体<ul><li>SPU：Standard Product Unit</li><li>SKU：Stock Keeping Unit</li></ul></li></ul><h4 id="秒杀业务的特点"><a href="#秒杀业务的特点" class="headerlink" title="秒杀业务的特点"></a>秒杀业务的特点</h4><ul><li>瞬时流量高</li><li>读多写少</li><li>实时性要求高</li></ul><h4 id="秒杀的挑战"><a href="#秒杀的挑战" class="headerlink" title="秒杀的挑战"></a>秒杀的挑战</h4><ul><li>资源成本</li><li>反欺诈</li><li>高性能</li><li>防止超卖</li><li>流量管控</li><li>扩展性</li><li>鲁棒性</li></ul><h3 id="设计秒杀系统"><a href="#设计秒杀系统" class="headerlink" title="设计秒杀系统"></a>设计秒杀系统</h3><h4 id="场景（Scenario）"><a href="#场景（Scenario）" class="headerlink" title="场景（Scenario）"></a>场景（Scenario）</h4><ul><li>功能：<ul><li>秒杀活动发布</li><li>秒杀商品详情</li><li>秒杀下单</li></ul></li><li>并发：<ul><li>万人参与秒杀</li><li>QPS 1w+</li><li>TPS 1k+</li></ul></li></ul><h4 id="存储（Storage）"><a href="#存储（Storage）" class="headerlink" title="存储（Storage）"></a>存储（Storage）</h4><p><img src="https://img.lonesome.cn/blog/bytedance/0QX@JTYT8E5Z9TN5HN9.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/TKWSFL80BPXDG4_Y3.webp"></p><h4 id="服务（Service）"><a href="#服务（Service）" class="headerlink" title="服务（Service）"></a>服务（Service）</h4><ul><li>子服务：<ul><li>用户服务</li><li>风控服务</li><li>活动服务</li><li>订单服务</li></ul></li><li>基础组件：<ul><li>ID 生成器</li><li>缓存组件</li><li>MQ 组件</li><li>限流组件</li></ul></li></ul><h4 id="扩展（Scale）"><a href="#扩展（Scale）" class="headerlink" title="扩展（Scale）"></a>扩展（Scale）</h4><ul><li><p>流量隔离</p></li><li><p>CDN</p></li><li><p>缓存优化</p></li><li><p>流量管控</p></li><li><p>数据库扩展</p></li><li><p>MQ 扩展</p></li><li><p>Redis 扩展</p></li><li><p>服务水平扩展</p></li><li><p>服务垂直扩展</p></li></ul><h3 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h3><p><img src="https://img.lonesome.cn/blog/bytedance/37HT__8L5KBK0QNKM.webp"></p><h2 id="课程实践"><a href="#课程实践" class="headerlink" title="课程实践"></a>课程实践</h2><h3 id="秒杀流程图"><a href="#秒杀流程图" class="headerlink" title="秒杀流程图"></a>秒杀流程图</h3><p><img src="https://img.lonesome.cn/blog/bytedance/2HMS_D0G7GDQ4VMY1XY2L.webp"></p><h3 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a><a href="https://internal-api-lark-file.feishu.cn/download/messages/7196503700680114177/keys/file_v2_99ca82a6-d1fa-43e6-b932-4cd24725a6fg?chat_id=7184255753627238404">代码链接</a></h3><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p><img src="https://img.lonesome.cn/blog/bytedance/1ORP2EYUSZ5@SW0B2BT.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统设计方法论&quot;&gt;&lt;a href=&quot;#系统设计方法论&quot; class=&quot;headerlink&quot; title=&quot;系统设计方法论&quot;&gt;&lt;/a&gt;系统设计方法论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么要做系统设计&lt;ul&gt;
&lt;li&gt;个人&lt;ul&gt;
&lt;li&gt;For 面试&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="系统设计" scheme="https://lonesome.cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>微服务框架——不变的基建</title>
    <link href="https://lonesome.cn/posts/microservice-framework/"/>
    <id>https://lonesome.cn/posts/microservice-framework/</id>
    <published>2023-02-04T07:00:00.000Z</published>
    <updated>2024-08-11T12:53:22.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务架构介绍"><a href="#微服务架构介绍" class="headerlink" title="微服务架构介绍"></a>微服务架构介绍</h2><h3 id="系统架构演变历史"><a href="#系统架构演变历史" class="headerlink" title="系统架构演变历史"></a>系统架构演变历史</h3><ul><li>为什么系统架构需要演进？<ul><li>互联网的爆炸性发展</li><li>硬件设施的快速发展</li><li>需求复杂性的多样化</li><li>开发人员的急剧增加</li><li>计算机理论及技术的发展</li></ul></li><li>单体架构——all in one process<ul><li>优势：<ul><li>性能最高</li><li>冗余小</li></ul></li><li>劣势：<ul><li>debug 困难</li><li>模块相互影响</li><li>模块分工、开发流程</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/R6@2CVRSZT59ALDCOU.webp"></li></ul></li><li>垂直应用架构——按照业务线垂直划分<ul><li>优势：<ul><li>业务独立开发维护</li></ul></li><li>劣势：<ul><li>不同业务存在冗余</li><li>每个业务还是单体</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/U1RDLA5T2E_IRJ3O8F.webp"></li></ul></li><li>分布式架构——抽出与业务无关的公共模块<ul><li>优势：<ul><li>业务无关的独立服务</li></ul></li><li>劣势：<ul><li>服务模块 bug 可导致全站瘫痪</li><li>调用关系复杂</li><li>不同服务冗余</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/062KVW78B_VU5TLH6IRB.webp"></li></ul></li><li>SOA 架构——面向服务<ul><li>优势：<ul><li>服务注册</li></ul></li><li>劣势：<ul><li>整个系统设计是中心化的</li><li>需要从上至下设计</li><li>重构困难</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/3K0@80O6G4HN74D6P5QN.webp"></li></ul></li><li>微服务架构——彻底的服务化<ul><li>优势：<ul><li>开发效率</li><li>业务独立设计</li><li>自上而下</li><li>故障隔离</li></ul></li><li>劣势：<ul><li>治理、运维难度</li><li>观测挑战</li><li>安全性</li><li>分布式系统</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/FXDG@AA_N5XX1LC3AZPY.webp"></li></ul></li></ul><h3 id="微服务架构概览"><a href="#微服务架构概览" class="headerlink" title="微服务架构概览"></a>微服务架构概览</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ENRZA6M65BMDKURKZ9G.webp"></p><h3 id="微服务架构核心要素"><a href="#微服务架构核心要素" class="headerlink" title="微服务架构核心要素"></a>微服务架构核心要素</h3><ul><li>服务治理<ul><li>服务注册</li><li>服务发现</li><li>负载均衡</li><li>扩缩容</li><li>流量治理</li><li>稳定性治理</li></ul></li><li>可观测性<ul><li>日志采集</li><li>日志分析</li><li>监控打点</li><li>监控大盘</li><li>异常报警</li><li>链路追踪</li></ul></li><li>安全<ul><li>身份验证</li><li>认证授权</li><li>访问令牌</li><li>审计</li><li>传输加密</li><li>黑产攻击</li></ul></li></ul><h2 id="微服务架构原理及特征"><a href="#微服务架构原理及特征" class="headerlink" title="微服务架构原理及特征"></a>微服务架构原理及特征</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img.lonesome.cn/blog/bytedance/FR73N095CQK69CUP2KI2.webp"></p><ul><li><p>服务（service）</p><ul><li>一组具有相同逻辑的运行实体</li></ul></li><li><p>实例（instance）</p><ul><li>一个服务中，每个运行实体即为一个实例</li></ul></li><li><p>实例与进程的关系</p><ul><li>实例与进程之间没有必然对应关系，一个实例可以对应一个或多个进程（反之不常见）</li></ul></li><li><p>集群（cluster）</p><ul><li>通常指服务内部的逻辑划分，包含多个实例</li></ul></li><li><p>常见的实例承载形式</p><ul><li>进程、VM、k8s pod……</li></ul></li><li><p>有状态&#x2F;无状态服务</p><ul><li>服务的实例是否存储了可持久化的数据（例如磁盘文件）</li></ul></li><li><p>服务间通信</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/MCN5BDNTUQFNGBM0NJ.webp"></li><li>对于单体服务，不同模块通信只是简单的函数调用</li><li>对于微服务，服务间通信意味着网络传输</li></ul></li></ul><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ul><li>问题：在代码层面，如何指定调用一个目标服务的地址（ip:port）？<ul><li>直接指定 ip:port？<ul><li>没有任何动态能力</li><li>有多个实例下游实例怎么办？</li><li><img src="https://img.lonesome.cn/blog/bytedance/3V8VYAV9VWNAJZ7KCHQ3K.webp"></li></ul></li><li>使用 DNS？<ul><li>本地 DNS 存在缓存，导致延迟</li><li>负载均衡问题</li><li>不支持服务探活检查</li><li>域名无法配置端口</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/0XZJ8RXGPBJUTU1.webp"></li></ul></li><li>解决思路：新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@SGJW22462BDA0IYR.webp"></li></ul></li><li>服务实例上线及下线过程<ul><li>旧服务实例下线前，从服务注册中心删除该实例，下线流量<ul><li><img src="https://img.lonesome.cn/blog/bytedance/UD32_66BL0QVWZ532N.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/9QMFE_AYS8IUGFD94.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/ZVJ@QNMW12CBNIS7FG0.webp"></li></ul></li><li>新服务实例上线后，在服务注册中心注册该实例，上线流量<ul><li><img src="https://img.lonesome.cn/blog/bytedance/H_ABI@U0AUVMV9RIY.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/DAY68SDJE@@5XV0Z8TV6RD.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/ONAXOM4H1ZCKLPZNRT.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/GEJ6PLBJZYB_046ZY.webp"></li></ul></li></ul></li></ul><h3 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h3><p><img src="https://img.lonesome.cn/blog/bytedance/VDCHYBB2_LXFPIKGJW.webp"></p><ul><li>统一网关入口</li><li>内网通信多数采用 RPC（Thrift, gRPC）</li><li>网状调用链路</li></ul><h2 id="核心服务治理功能"><a href="#核心服务治理功能" class="headerlink" title="核心服务治理功能"></a>核心服务治理功能</h2><h3 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h3><ul><li>服务发布（deployment）<ul><li>让一个服务升级运行新的代码的过程</li></ul></li><li>服务发布的难点<ul><li>服务不可用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/PMUO0XF3M67EMMJVS8.webp"></li></ul></li><li>服务抖动<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0MCMI_DVFP81D_BQX8K_B.webp"></li></ul></li><li>服务回滚<ul><li><img src="https://img.lonesome.cn/blog/bytedance/54_SE96I__CPON_XE018.webp"></li></ul></li></ul></li><li>蓝绿部署<ul><li>将服务分成两个部分，分别先后发布</li><li>简单、稳定</li><li>但需要两倍资源</li><li><img src="https://img.lonesome.cn/blog/bytedance/MB848D_15@LEWOZ2MD0S.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/3VGWLFTYV6J_1KHS_QNA.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/VF5SY31LX1OVD4ZMT8.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/WB8IJA@2VA99A7DIC.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/2KFOQU67PR@05NIO7MD1.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/PHM6_QTXWPTRANNM.webp"></li></ul></li><li>灰度发布（金丝雀发布）<ul><li>先发布少部分实例，接着逐步增加发布比例</li><li>不需要增加资源</li><li>回滚难度大，基础设施要求高</li><li><img src="https://img.lonesome.cn/blog/bytedance/IS0E@XJR9I4C5H1YJ4W.webp"></li></ul></li></ul><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>在微服务架构中，可以基于地区、集群、实例、请求等维度，对端到端流量的路由路径进行精确控制</p><p><img src="https://img.lonesome.cn/blog/bytedance/SVBCLW1BA7HR_O_2QEE.webp"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>负载均衡（Load Balance）负责分配请求在每个下游实例上的分布<ul><li><img src="https://img.lonesome.cn/blog/bytedance/Q5YI_AIGKATKNAS4_BM.webp"></li></ul></li><li>常见的 LB 策略<ul><li>Round Robin</li><li>Random</li><li>Ring Hash</li><li>Least Request</li></ul></li></ul><h3 id="稳定性治理"><a href="#稳定性治理" class="headerlink" title="稳定性治理"></a>稳定性治理</h3><ul><li>线上服务总是会出问题的，这与程序的正确性无关<ul><li>网络攻击</li><li>流量突增</li><li>机房断电</li><li>光纤被挖</li><li>机器故障</li><li>网络故障</li><li>……</li></ul></li><li>微服务架构中典型的稳定性治理功能<ul><li>限流<ul><li>限制服务处理的最大 QPS，拒绝过多请求</li><li><img src="https://img.lonesome.cn/blog/bytedance/7P6U_HGS_24@5I07DDY.webp"></li></ul></li><li>熔断<ul><li>中断请求路径，增加冷却时间从而让故障实例尝试恢复</li><li><img src="https://img.lonesome.cn/blog/bytedance/EA0FK9MY6ZRY4PXP.webp"></li></ul></li><li>过载保护<ul><li>在负载高的实例中，主动拒绝一部分请求，防止实例被打挂</li><li><img src="https://img.lonesome.cn/blog/bytedance/6ANF_Z19_SQMWDZFI.webp"></li></ul></li><li>降级<ul><li>服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求</li><li><img src="https://img.lonesome.cn/blog/bytedance/SVBCLW1BA7HR_O_2QEE.webp"></li></ul></li></ul></li></ul><h2 id="字节跳动服务治理实践"><a href="#字节跳动服务治理实践" class="headerlink" title="字节跳动服务治理实践"></a>字节跳动服务治理实践</h2><h3 id="重试的意义"><a href="#重试的意义" class="headerlink" title="重试的意义"></a>重试的意义</h3><ul><li>本地函数调用——通常没有重试意义<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5JJBVHO2QAXVIBQI.webp"></li><li>可能有哪些异常？<ul><li>参数非法</li><li>OOM（Out Of Memory）</li><li>NPE（Null Pointer Expection）</li><li>边界 case</li><li>系统崩溃</li><li>死循环</li><li>程序异常退出</li></ul></li></ul></li><li>远程函数调用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/QCBPZYL5698S@BTMOX3.webp"></li><li>可能有哪些异常？<ul><li>网络抖动</li><li>下游负载高导致超时</li><li>下游机器宕机</li><li>本地机器负载高，调度超时</li><li>下游熔断、限流</li><li>……</li></ul></li></ul></li><li>重试的意义<ul><li>重试可以避免掉偶发的错误，提高 SLA（Service-Level Agreement）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/W_B@QGILNFUQ45CGZ4C.webp"></li></ul></li><li>降低错误率<ul><li>假设单次请求的错误概率为 0.01，那么连续两次错误概率则为 0.0001</li></ul></li><li>降低长尾延时<ul><li>对于偶尔耗时较长的请求，重试请求有机会提前返回</li></ul></li><li>容忍暂时性错误<ul><li>某些时候系统会有暂时性异常（例如网络抖动），重试可以尽量规避</li></ul></li><li>避开下游故障实例<ul><li>一个服务中可能会有少量实例故障（例如机器故障），重试其他实例可以成功</li></ul></li></ul></li></ul><h3 id="重试的难点"><a href="#重试的难点" class="headerlink" title="重试的难点"></a>重试的难点</h3><ul><li>幂等性<ul><li>多次请求可能会造成数据不一致</li></ul></li><li>重试风暴<ul><li>随着调用链路的增加，重试次数呈指数级上升</li><li><img src="https://img.lonesome.cn/blog/bytedance/5I50PCM0CUQPRH0X6V.webp"></li></ul></li><li>超时设置<ul><li>假设调用时间一共 1s，经过多少时间开始重试？</li></ul></li></ul><h3 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h3><ul><li>限制重试比例<ul><li>设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值</li><li>重试只有在大部分请求都成功，只有少量请求失败时才有必要</li><li>如果大部分请求都失败，重试只会加剧问题严重性</li><li><img src="https://img.lonesome.cn/blog/bytedance/H81CI6@B0XYDN1VB.webp"></li></ul></li><li>防止链路重试<ul><li>链路层面的防重试风暴的核心是限制每层都发生重试，理想情况下只有最下一层发生重试</li><li>可以返回特殊的 status code，表示“请求失败，但别重试”</li><li><img src="https://img.lonesome.cn/blog/bytedance/6EEG@MTM2FJGYA90YO8P1.webp"></li></ul></li><li>Hedged Requests<ul><li>对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应</li><li><img src="https://img.lonesome.cn/blog/bytedance/TF0AT16OROXQBT_7Q9.webp"></li></ul></li></ul><h3 id="重试效果验证"><a href="#重试效果验证" class="headerlink" title="重试效果验证"></a>重试效果验证</h3><p>实际验证经过上述重试策略后，在链路上发生的重试放大效应</p><p><img src="https://img.lonesome.cn/blog/bytedance/G@NPN661EEHQGO_8A7E.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微服务架构介绍&quot;&gt;&lt;a href=&quot;#微服务架构介绍&quot; class=&quot;headerlink&quot; title=&quot;微服务架构介绍&quot;&gt;&lt;/a&gt;微服务架构介绍&lt;/h2&gt;&lt;h3 id=&quot;系统架构演变历史&quot;&gt;&lt;a href=&quot;#系统架构演变历史&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="架构" scheme="https://lonesome.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://lonesome.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
