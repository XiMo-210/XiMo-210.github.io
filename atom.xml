<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惜寞的无人小间</title>
  
  
  <link href="https://lonesome.cn/atom.xml" rel="self"/>
  
  <link href="https://lonesome.cn/"/>
  <updated>2024-08-09T17:59:37.931Z</updated>
  <id>https://lonesome.cn/</id>
  
  <author>
    <name>惜寞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 安装 Redis</title>
    <link href="https://lonesome.cn/blog/record/docker-install-redis/"/>
    <id>https://lonesome.cn/blog/record/docker-install-redis/</id>
    <published>2023-12-01T05:08:31.000Z</published>
    <updated>2024-08-09T17:59:37.931Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先需要安装好 Docker，可以参考<a href="https://lonesome.cn/blog/record/ubuntu-install-docker/">Ubuntu 安装 Docker</a><ul><li>使用 Docker 需要 root 权限，推荐将用户加入 Docker 用户组（上文中有），这样使用就不需要加上<code>sudo</code>了（<del>但是我是 root，所以文中都没加</del>）</li></ul></li><li>Docker Hub 中的 Redis 官方镜像文档 <a href="https://hub.docker.com/_/redis">redis - Official Image | Docker Hub</a></li></ul><h2 id="1-寻找镜像"><a href="#1-寻找镜像" class="headerlink" title="1.寻找镜像"></a>1.寻找镜像</h2><p>在 Docker 仓库中查找 Redis 镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/0N1GWUN7S0A2FMOY.webp"><br>可以看到第一个就是我们需要的镜像</p><h2 id="2-拉取镜像"><a href="#2-拉取镜像" class="headerlink" title="2.拉取镜像"></a>2.拉取镜像</h2><p>在查找到 Redis 的镜像后，就可以进行拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/22D20QR093N6MFN.webp"><br>因为没有指定 Redis 的版本，所以默认拉取最新的版本（即 latest）<br>如果想要拉取指定的版本，可以在拉取时添加版本号（<code>redis:tag</code>），以 Redis 7.2.3 版本为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:7.2.3</span><br></pre></td></tr></table></figure><h2 id="3-查看镜像"><a href="#3-查看镜像" class="headerlink" title="3.查看镜像"></a>3.查看镜像</h2><p>拉取完毕后，检查镜像是否安装完成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看所有镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/3MUEAB1MG9ZX66B.webp"><br>可以看到已经有 Redis 的镜像了</p><h2 id="4-创建容器并启动"><a href="#4-创建容器并启动" class="headerlink" title="4.创建容器并启动"></a>4.创建容器并启动</h2><p>通过 Docker 安装 Redis 和直接安装 Redis 的一处不同在于通过 Docker 创建的 Redis 容器中是没有<code>redis.conf</code>配置文件的<br>Redis 可以在没有配置文件的情况下使用内置的默认配置启动，但是这种方法只建议在测试和开发的时候使用，当然 Redis 官方也给我们提供了使用配置文件启动 Redis 容器的方法，因此下面介绍两种方法</p><h3 id="一、无配置文件简易版"><a href="#一、无配置文件简易版" class="headerlink" title="一、无配置文件简易版"></a>一、无配置文件简易版</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 容器名称、端口、密码均可自行指定</span></span><br><span class="line">docker run \</span><br><span class="line">  --name redis \</span><br><span class="line">  -p 6379:6379 \</span><br><span class="line">  -- requirepass 123456 \</span><br><span class="line">  -d \</span><br><span class="line">  redis</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>--name redis</code>：指定容器的名称为 redis（可以自己指定）</li><li><code>-p 6379:6379</code>：将容器的 6379（右边的）端口映射到宿主机的 6379（左边的）端口（前提是不被占用）</li><li><code>-- requirepass 123456</code>：设置密码为 123456<ul><li>如果不想设置密码可以不使用该参数，但是需要注意为了便于容器外能够访问到该容器内的 Redis，其<code>protected mode</code>（保护模式）默认关闭，这意味着如果你将端口暴露在主机外部，它将在没有密码的情况下对所有人开放</li></ul></li><li><code>-d</code>：以后台的方式运行</li><li><code>redis:tag</code>：指定创建容器的镜像（<code>:tag</code>指定版本，不加默认最新版）<ul><li>建议创建容器时使用<code>:tag</code>指定版本，可以使用<code>docker images</code>查看镜像的版本，以免过段时间版本更新后导致现在拉取的镜像已经不是最新版本，又重新拉取一个最新版本的镜像进行容器创建</li></ul></li></ul><p>执行后返回的一长串是容器 id</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>该方式创建的容器适合在测试环境使用，简单方便，但是没法通过配置文件去自定义一些配置，而且数据容易丢失，一旦关机或者容器挂了数据就没了，因为是存在缓存里的</p><h3 id="二、-配置文件挂载版"><a href="#二、-配置文件挂载版" class="headerlink" title="二、 配置文件挂载版"></a>二、 配置文件挂载版</h3><h4 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h4><p>先准备一个目录用于存放配置文件（用于后面创建容器时挂载配置），目录可以自己选择，通常选择放在用户的主目录下的一个子目录中，好处是每个用户都有自己的挂载目录，可以隔离不同用户的数据<br>但是因为我的云服务器只有我一个人在玩，平常都是直接用的 root 用户，所以直接在根目录下创建了一个<code>/data</code>目录用来存放 Docker 容器的挂载配置和数据，因此我这边准备的目录在<code>/data/redis/</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建用于 Redis 容器配置文件挂载的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /data/redis/conf</span><br></pre></td></tr></table></figure><p>然后提前在该目录下新建一个<code>redis.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 新建 redis.conf 文件</span></span><br><span class="line"><span class="built_in">touch</span> /data/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>创建完配置文件后，直接去 Redis 的官网找对应版本的配置文件 <a href="https://redis.io/docs/management/config/">Redis configuration | Redis</a><br><img src="https://img.lonesome.cn/blog/record/Z458FP7J73FSLAUMY6.webp"><br>往下滑可以找到各个不同版本的配置文件<br>因为我拉取的是最新版本的镜像，所以这边选择第一个 7.2 版本（最新版本），根据拉取 Redis 的实际版本选择即可<br>点进去后就可以看到配置文件的内容，本文就不具体介绍了，可以自行了解<br><img src="https://img.lonesome.cn/blog/record/X6OHG8ONB4D5.webp"><br>直接<code>ctrl+a</code> + <code>ctrl+c</code>复制，然后用 vim 打开我们之前准备好的<code>redis.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式，<code>ctrl+v</code>粘贴，然后别急着保存退出，还需要修改一些配置</p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>修改配置主要是为了能在宿主机访问容器中的 Redis，因为配置文件中的<code>protected-mode</code>（保护模式）设置是开启的</p><ul><li>保护模式：如果符合下面两个条件（不是之一）则无法被外部访问<ol><li>没有明确使用 bind 绑定某个 ip 地址</li><li>没有设置密码</li></ol></li></ul><h5 id="取消本地绑定-绑定某个-ip-地址"><a href="#取消本地绑定-绑定某个-ip-地址" class="headerlink" title="取消本地绑定&#x2F;绑定某个 ip 地址"></a>取消本地绑定&#x2F;绑定某个 ip 地址</h5><p>定位到<code>bind 127.0.0.1 -::1</code>，将其注释<br><img src="https://img.lonesome.cn/blog/record/LQB00UBHFTPPQT.webp"><br><code>bind 127.0.0.1 -::1</code>的意思是限制只能本地访问（即只有该容器内部才可以访问，容器外的宿主机也访问不了），注释掉表示允许所有 ip 访问<br>当然也可以选择绑定指定 ip 允许其访问</p><h5 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h5><p>定位到<code>## requirepass foobared</code>，取消其注释，并将<code>foobared</code>修改为你想设置的密码<br><img src="https://img.lonesome.cn/blog/record/2Y7GCDARZGA8Q.webp"><br>比如我这边就将密码设置为了<code>123456</code><br>如果不想设置密码还想被外部宿主机访问，那就需要另外定位到<code>protected-mode yes</code>，将参数修改为<code>no</code>（解除保护模式的限制）</p><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 默认 no，表示不以守护进程启动，Docker 部署不需要改为 yes，因为 docker run -d 本身就是后台启动</span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line">## 开启持久化，根据需求选择是否开启，会将数据持久化到容器中的 /data 目录</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>更多其他配置根据自己需求修改，本文不多介绍</p><h4 id="以配置文件方式创建容器并启动"><a href="#以配置文件方式创建容器并启动" class="headerlink" title="以配置文件方式创建容器并启动"></a>以配置文件方式创建容器并启动</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 容器名称、端口、挂载目录均可自行指定</span></span><br><span class="line">docker run \</span><br><span class="line">  --name redis \</span><br><span class="line">  -p 6379:6379 \</span><br><span class="line">  -v /data/redis/conf:/usr/local/etc/redis \</span><br><span class="line">  <span class="comment">## 如果配置了 appendonly yes（持久化）可以选择挂载该目录</span></span><br><span class="line">  -v /data/redis/data:/data \</span><br><span class="line">  -d \</span><br><span class="line">  redis \</span><br><span class="line">  redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>简易版的参数就不再介绍了，说明一下新参数：</p><ul><li><code>-v</code>：数据卷挂载<ul><li><code>/data/redis/conf:/usr/local/etc/redis</code>：将容器中<code>/usr/local/etc/redis</code>目录挂载到宿主机的<code>/data/redis/conf</code>目录<ul><li><code>/data/redis/conf</code>目录即之前准备的存放<code>redis.conf</code>文件的目录，这里可以理解为 Docker 容器和宿主机共享该配置文件</li></ul></li><li><code>/data/redis/data:/data</code>：将容器中<code>/data</code>数据目录挂载到宿主机的<code>/data/redis/data</code>目录<ul><li>如果开启了持久化，进行挂载可以避免持久化的数据丢失，如果不挂载的话在删除容器后会丢失该容器中持久化的数据，即<strong>挂载后即使容器删除，只要宿主机目录中的数据还存在，使用该目录新创建的容器中依旧有原先容器中挂载的数据</strong></li><li>如果没有开启持久化也就不需要挂载<code>\data</code>数据目录了，因为 Redis 的数据都存在缓存里，不开启持久化也不会在该目录下存储数据</li><li>宿主机用于挂载的目录（比如我这边的<code>/data/redis/data</code>）可以自行选择，一般就放在配置目录旁边</li></ul></li></ul></li><li><code>redis-server /usr/local/etc/redis/redis.conf</code>：以配置文件启动容器，加载容器内的<code>redis.conf</code>文件，实际找到的是挂载在宿主机中配置目录下的<code>reids.conf</code></li></ul><p><img src="https://img.lonesome.cn/blog/record/6B2FV6HFAVVBI.webp"><br>返回的一长串是创建的容器 id</p><h2 id="6-查看容器"><a href="#6-查看容器" class="headerlink" title="6.查看容器"></a>6.查看容器</h2><p>检查容器是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看运行中的容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/DBVQBAM5ZQCT1NSFFQ.webp"><br>可以看到创建的 Redis 容器已经在运行中了<br>我们可以通过 Docker 命令进入 Redis 容器内部</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 redis 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">## 也可以使用容器 id（即上图中的 CONTANINER ID）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 7cd1552e2cf5 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/CML92T2X8JX0F.webp"><br>进入后就可以和在 linux 中一样使用 Redis 了<br>输入<code>redis-cli -a 123456</code>即可进入 Redis 命令行，<code>-a</code>后面的参数是你设置的密码<br><img src="https://img.lonesome.cn/blog/record/5ETPMRGIYCVMO1E.webp"><br>后续使用和正常 Redis 一样，想要退出 Redis 和容器使用<code>exit</code>命令即可</p><h2 id="7-删除容器"><a href="#7-删除容器" class="headerlink" title="7.删除容器"></a>7.删除容器</h2><p>不能直接删除运行中的容器，因此需要先停止容器再删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 redis 是创建容器时自行指定的容器名称</span></span><br><span class="line"><span class="comment">## 停止容器</span></span><br><span class="line">docker stop redis</span><br><span class="line"><span class="comment">## 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> redis</span><br></pre></td></tr></table></figure><p>但是可以加上<code>-f</code>参数来强制删除运行中的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 redis 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">rm</span> -f redis</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Docker 安装 Redis 记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Docker" scheme="https://lonesome.cn/tags/Docker/"/>
    
    <category term="Redis" scheme="https://lonesome.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Docker 安装 MySQL</title>
    <link href="https://lonesome.cn/blog/record/docker-install-mysql/"/>
    <id>https://lonesome.cn/blog/record/docker-install-mysql/</id>
    <published>2023-11-29T13:22:43.000Z</published>
    <updated>2024-08-09T17:58:59.800Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>首先需要安装好 Docker，可以参考<a href="https://lonesome.cn/blog/record/ubuntu-install-docker/">Ubuntu 安装 Docker</a><ul><li>使用 Docker 需要 root 权限，推荐将用户加入 Docker 用户组（上文中有），这样使用就不需要加上<code>sudo</code>了（<del>但是我是 root，所以文中都没加</del>）</li></ul></li><li>Docker Hub 中的 MySQL 官方镜像文档 <a href="https://hub.docker.com/_/mysql">mysql - Official Image | Docker Hub</a></li></ul><h2 id="1-寻找镜像"><a href="#1-寻找镜像" class="headerlink" title="1.寻找镜像"></a>1.寻找镜像</h2><p>在 Docker 仓库中查找 MySQL 镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/NQFHOZC2A6I0WCPBT.webp"><br>可以看到第一个就是我们需要的镜像</p><h2 id="2-拉取镜像"><a href="#2-拉取镜像" class="headerlink" title="2.拉取镜像"></a>2.拉取镜像</h2><p>在查找到 MySQL 的镜像后，就可以进行拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/G4016RJ0I0C39T6SPHF.webp"><br>因为没有指定 MySQL 的版本，所以默认拉取最新的版本（即 latest）<br>如果想要拉取指定的版本，可以在拉取时添加版本号（<code>mysql:tag</code>），以 MySQL 5.7 版本为例</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure><h2 id="3-查看镜像"><a href="#3-查看镜像" class="headerlink" title="3.查看镜像"></a>3.查看镜像</h2><p>拉取完毕后，检查镜像是否安装完成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看所有镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/4Z5AEPZEIYZHSED3Z4.webp"><br>可以看到已经有 MySQL 的镜像了（hello-world 是我在安装完 Docker 测试时拉取的镜像）</p><h2 id="4-创建容器并启动"><a href="#4-创建容器并启动" class="headerlink" title="4.创建容器并启动"></a>4.创建容器并启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 容器名称、端口、挂载目录、root 密码均可自行指定</span></span><br><span class="line">docker run \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -v /data/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v /data/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /data/mysql/log:/var/log/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">  -d \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>--name mysql</code>：指定容器的名称为 mysql（可以自己指定）</li><li><code>-p 3306:3306</code>：将容器的 3306（右边的）端口挂载到宿主机的 3306（左边的）端口（前提是不被占用）</li><li><code>-v</code>：将相关目录挂载到宿主机防止数据丢失，如果不挂载的话在删除容器后会丢失存储的数据，即<strong>挂载后即使容器删除，只要宿主机目录中的数据还存在，使用该目录新创建的容器中依旧有原先容器中挂载的数据</strong><ul><li>注：<ul><li><strong>实际宿主机中用于挂载的目录根据自己需求设置，如果只是开发测试环境可以选择不挂载（<del>用完就删不留痕迹，正合我意</del>），但是配置目录还是推荐挂载，方便修改配置</strong></li><li>挂载目录通常选择放在用户的主目录下的一个子目录中，好处是每个用户都有自己的挂载目录，可以隔离不同用户的数据，但是因为我的云服务器只有我一个人在玩，平常都是直接用的 root 用户，所以直接在根目录下创建了一个<code>/data</code>目录用来存放 Docker 容器的挂载配置和数据，MySQL 容器的就都挂载在<code>/data/mysql</code>目录下了</li></ul></li><li><code>/data/mysql/conf:/etc/mysql/conf.d</code>：将容器中<code>/etc/mysql/conf.d</code>配置目录挂载到宿主机的<code>/data/mysql/conf</code>目录<ul><li><strong>想要修改 MySQL 配置可以直接在宿主机的配置目录下添加一份自定义的<code>my.cnf</code>配置文件，该文件中的配置优先级高于 MySQL 的默认配置（容器中 MySQL 的配置文件路径位于<code>/etc/my.cnf）</code></strong></li><li><strong>也可以提前编辑好<code>my.cnf</code>文件，创建的容器会按你挂载目录中的自定义配置启动</strong></li></ul></li><li><code>/data/mysql/data:/var/lib/mysql</code>：将容器中<code>/var/lib/mysql</code>数据目录挂载到宿主机的<code>/data/mysql/data</code>目录</li><li><code>/data/mysql/log:/var/log/mysql</code>：将容器中<code>/var/log/mysql</code>日志目录挂载到宿主机的<code>/data/mysql/log</code>目录</li></ul></li><li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：初始化 MySQL root 用户的密码为 123456</li><li><code>-d</code>：以后台的方式运行</li><li><code>mysql:tag</code>：指定创建容器的镜像（<code>:tag</code>指定版本，不加默认最新版）<ul><li>建议创建容器时使用<code>:tag</code>指定版本，可以使用<code>docker images</code>查看镜像的版本，以免过段时间版本更新后导致现在拉取的镜像已经不是最新版本，又重新拉取一个最新版本的镜像进行容器创建</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/record/SC3AVHM4I293CD3J3.webp"><br>返回的一长串是创建的容器 id</p><h2 id="5-查看容器"><a href="#5-查看容器" class="headerlink" title="5.查看容器"></a>5.查看容器</h2><p>检查容器是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看运行中的容器</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/7T8FG5HKRT1H67A5.webp"><br>可以看到创建的 MySQL 容器已经在运行中了<br>我们可以通过 Docker 命令进入 MySQL 容器内部</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">## 也可以使用容器 id（即上图中的 CONTANINER ID）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 01c4a501d5c4 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/TEKF58YP3LHZNC.webp"><br>进入后就可以和在 linux 中一样使用 MySQL 了<br>查看 MySQL 版本号</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/EELM6A6ZY1UK8C4KDZ7.webp"><br>注：写本文时的最新版本为 8.2.0<br>输入<code>mysql -u root -p</code>后再输入密码即可进入 MySQL 命令行<br><img src="https://img.lonesome.cn/blog/record/0GHC27658X48D5XLLG.webp"><br>后续使用和正常 MySQL 一样，想要退出 MySQL 和容器使用<code>exit</code>命令即可</p><h2 id="6-删除容器"><a href="#6-删除容器" class="headerlink" title="6.删除容器"></a>6.删除容器</h2><p>不能直接删除运行中的容器，因此需要先停止容器再删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line"><span class="comment">## 停止容器</span></span><br><span class="line">docker stop mysql</span><br><span class="line"><span class="comment">## 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> mysql</span><br></pre></td></tr></table></figure><p>但是可以加上<code>-f</code>参数来强制删除运行中的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line">docker <span class="built_in">rm</span> -f mysql</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>进入 MySQL 命令行后使用下面命令查看当前时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select now();</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/43XOZIG33DMYUBUXV.webp"><br>会发现 MySQL 中时间比系统时间少了 8 个小时，因为 MySQL 的时区并不是我们所在的东八区（即北京时间）</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="一：命令行中修改"><a href="#一：命令行中修改" class="headerlink" title="一：命令行中修改"></a>一：命令行中修改</h5><p>MySQL 中的系统时区，分为全局时区和当前会话的时区，如果当前会话不指定时区，默认使用全局时区，可以使用下面的命令将全局时区修改为东八区（即北京时间）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global time_zone = &#x27;+8.00&#x27;;</span><br><span class="line"></span><br><span class="line">## 修改当前会话的时区（相当于临时修改）</span><br><span class="line">## set time_zone = &#x27;+8.00&#x27;;</span><br></pre></td></tr></table></figure><p>如果想要立即生效需要执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>再次<code>select now();</code>查看时间会发现已经是东八区的时间了</p><h5 id="二：修改-my-cnf-配置文件"><a href="#二：修改-my-cnf-配置文件" class="headerlink" title="二：修改 my.cnf 配置文件"></a>二：修改 my.cnf 配置文件</h5><h6 id="容器中修改"><a href="#容器中修改" class="headerlink" title="容器中修改"></a>容器中修改</h6><p>可以编辑容器中 MySQL 的<code>my.cnf</code>（位于<code>/etc/my.cnf</code>）配置文件<br>然后在 [mysqld] 区域加上<code>default-time_zone = &#39;+8:00&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">......</span><br><span class="line">default-time_zone = &#x27;+8:00&#x27;</span><br><span class="line">......</span><br><span class="line">[client]</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>然后重启 MySQL<br>注：MySQL 容器中没有 vim，如果想要编辑需要先安装 vim（<del>所以我没有演示</del>）</p><h6 id="通过挂载的配置文件修改"><a href="#通过挂载的配置文件修改" class="headerlink" title="通过挂载的配置文件修改"></a>通过挂载的配置文件修改</h6><p>如果在创建容器时<em>将容器中的配置目录挂载到了宿主机</em>，那就可以直接编辑宿主机中的配置文件进行修改了<br>首先在配置目录挂载的宿主机目录下新建一个<code>my.cnf</code>文件，然后使用 vim 编辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 进入你自己挂载的宿主机配置目录</span></span><br><span class="line"><span class="built_in">cd</span> /data/mysql/conf</span><br><span class="line"><span class="comment">## 新建一个 my.cnf 文件</span></span><br><span class="line"><span class="built_in">touch</span> my.cnf</span><br><span class="line"><span class="comment">## 使用 vim 编辑</span></span><br><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure><p>添加下面配置内容（<del>不会还有人不会 vim 吧</del>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">default-time-zone = &#x27;+08:00&#x27;</span><br></pre></td></tr></table></figure><p>保存退出后重启容器即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里的 mysql 是创建容器时自行指定的容器名称</span></span><br><span class="line"><span class="comment">## 重启重启</span></span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><p>之后再次进入容器中的 MySQL，通过<code>select now();</code>查看时间会发现已经是东八区的时间了</p><p><strong>注：想要修改其他配置也可以按照相同的方法在宿主机编辑配置文件，并且只要创建容器时挂载宿主机的配置目录不变，即使删除当前容器重开一个，修改的配置也依旧在</strong></p>]]></content>
    
    
    <summary type="html">Docker 安装 MySQL 记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Docker" scheme="https://lonesome.cn/tags/Docker/"/>
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Docker</title>
    <link href="https://lonesome.cn/blog/record/ubuntu-install-docker/"/>
    <id>https://lonesome.cn/blog/record/ubuntu-install-docker/</id>
    <published>2023-11-27T17:53:55.000Z</published>
    <updated>2024-08-09T18:00:59.457Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>云服务器：阿里云（不同厂商云服务器上的操作基本相同）</li><li>系统：Ubuntu 22.04</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><p>本文不具体介绍 Docker<br>下面步骤均根据写本文时最新的<a href="https://docs.docker.com/engine/install/ubuntu/">官方文档</a></p><h2 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h2><h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>首次在新的主机上安装 Docker Engine 之前，需要先设置 Docker 的软件源，之后就可以通过软件源安装和更新 Docker</p><h4 id="1-设置-Docker-的软件源"><a href="#1-设置-Docker-的软件源" class="headerlink" title="1.设置 Docker 的软件源"></a>1.设置 Docker 的软件源</h4><p>依次执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="comment">## 安装相关依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install ca-certificates curl gnupg</span><br><span class="line"><span class="comment">## 创建目录用于存放软件源的 GPG 密钥文件</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，建议使用国内源，官方源请在注释中查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 添加软件源的 GPG 密钥（阿里镜像源）</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment">## 官方源</span></span><br><span class="line"><span class="comment">## curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改 docker.gpg 的文件权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将 docker 软件源添加到 apt 源（阿里镜像源）</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment">## 官方源</span></span><br><span class="line"><span class="comment">## echo \</span></span><br><span class="line"><span class="comment">##   &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">##   $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \</span></span><br><span class="line"><span class="comment">##   sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重新更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure><h4 id="2-安装-Docker"><a href="#2-安装-Docker" class="headerlink" title="2.安装 Docker"></a>2.安装 Docker</h4><p>执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h3 id="使用脚本安装"><a href="#使用脚本安装" class="headerlink" title="使用脚本安装"></a>使用脚本安装</h3><p>Docker 在 <a href="https://get.docker.com/">https://get.docker.com/</a> 提供了一个方便的脚本，可以在开发环境中非交互式地安装 Docker，不推荐在生产环境使用，但对于创建适合自己需求的配置脚本非常有用，该脚本的源代码开源在 GitHub 上的 <a href="https://github.com/docker/docker-install">docker-install 仓库</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br></pre></td></tr></table></figure><p>这个示例会从 <a href="https://get.docker.com/">https://get.docker.com/</a> 下载脚本并运行，在 Linux 上安装最新稳定版本的 Docker</p><blockquote><p>可以使用<code>--dry-run</code>选项运行脚本，以了解脚本在调用时会运行哪些步骤</p><blockquote><p>curl -fsSL <a href="https://get.docker.com/">https://get.docker.com</a> -o get-docker.sh<br>sudo sh .&#x2F;get-docker.sh –dry-run</p></blockquote></blockquote><p>如果想安装最新的预发布版本，可以通过测试通道</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh test-docker.sh</span><br></pre></td></tr></table></figure><h2 id="查看-Docker-状态"><a href="#查看-Docker-状态" class="headerlink" title="查看 Docker 状态"></a>查看 Docker 状态</h2><p>安装完成后，Docker 服务将会自动启动，可以输入下面命令查看 Docker 服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status docker</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/5VPK0YXI65RDE0UQ.webp"><br>输出显示 Docker 正常运行</p><h2 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run hello-world</span><br></pre></td></tr></table></figure><p>若能正常输出以下信息，则说明安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">719385e32844: Pull complete</span><br><span class="line">Digest: sha256:c79d06dfdfd3d3eb04cafd0dc2bacab0992ebc243e083cabe208bac4dd7759e0</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><h2 id="停止-Docker-服务"><a href="#停止-Docker-服务" class="headerlink" title="停止 Docker 服务"></a>停止 Docker 服务</h2><p>希望通过执行以下命令停止 Docker 服务时</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure><p>会提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Stopping docker.service, but it can still be activated by:</span><br><span class="line">  docker.socket</span><br></pre></td></tr></table></figure><p>此时再次查看 Docker 状态<br><img src="https://img.lonesome.cn/blog/record/MKINO4IMJ5NSICC.webp"><br>会发现有一个<code>TriggeredBy: docker.socket</code>依旧在运行<br>实际上是 Docker 在关闭状态下被访问的自动唤醒机制，即在执行任意 Docker 命令时会自动启动<br>如果不希望 Docker 被自动唤醒，在停止 Docker 服务时应该依次执行下面两条命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop docker.socket</span><br><span class="line"><span class="built_in">sudo</span> systemctl stop docker</span><br></pre></td></tr></table></figure><p>附上启动的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><p>注：<code>docker.socket</code>也会一起跟着重启</p><h2 id="卸载-Docker"><a href="#卸载-Docker" class="headerlink" title="卸载 Docker"></a>卸载 Docker</h2><ol><li>卸载 Docker Engine, CLI, containerd 和 Docker Compose 软件包</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras</span><br></pre></td></tr></table></figure><ol start="2"><li>主机上的镜像、容器、卷或自定义配置文件不会自动删除，因此要手动删除所有的镜像、容器和卷</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><p>以及相关编辑过的配置文件</p><h2 id="非-root-用户管理-Docker"><a href="#非-root-用户管理-Docker" class="headerlink" title="非 root 用户管理 Docker"></a>非 root 用户管理 Docker</h2><p>Docker 守护进程绑定<code>Unix socket</code>而不是 TCP 端口，默认情况下，<code>Unix socket</code>的所有者是 root 用户，其他用户想要访问只能使用 sudo，Docker 守护进程始终以 root 用户身份运行<br>出于安全考虑，一般 Linux 系统上不会直接使用 root 用户，如果希望非 root 用户能够不通过 sudo 访问，可以创建一个名为<code>docker</code>的 Unix 组，并将需要使用 Docker 的用户添加进用户组</p><h3 id="创建docker组"><a href="#创建docker组" class="headerlink" title="创建docker组"></a>创建<code>docker</code>组</h3><p>注：Ubuntu 在使用 apt 安装 Docker 时会自动创建该组</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br></pre></td></tr></table></figure><h3 id="将用户添加到docker组"><a href="#将用户添加到docker组" class="headerlink" title="将用户添加到docker组"></a>将用户添加到<code>docker</code>组</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 将 $USER 修改为你要添加的用户名</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h3 id="刷新组成员权限"><a href="#刷新组成员权限" class="headerlink" title="刷新组成员权限"></a>刷新组成员权限</h3><p>重新登陆或运行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>不使用 sudo 运行以下命令（使用添加到<code>docker</code>用户组的用户）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>正常输出以下信息，则说明添加成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>注：如果没有在<strong>测试 Docker 是否安装正确</strong>时运行过该命令，则会多出拉取镜像的信息</p><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Error loading config file: /home/user/.docker/config.json -</span><br><span class="line">stat /home/user/.docker/config.json: permission denied</span><br></pre></td></tr></table></figure><p>原因：当前用户没有加入<code>docker</code>用户组<br>解决方法：按上述流程将该用户加入用户组，并依次执行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 将 $USER 修改为当前用户的用户名</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> <span class="string">&quot;<span class="variable">$USER</span>&quot;</span>:<span class="string">&quot;<span class="variable">$USER</span>&quot;</span> /home/<span class="string">&quot;<span class="variable">$USER</span>&quot;</span>/.docker -R</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> g+rwx <span class="string">&quot;<span class="variable">$HOME</span>/.docker&quot;</span> -R</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Ubuntu 安装 Docker 记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Docker" scheme="https://lonesome.cn/tags/Docker/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 部署 Gin+Vue 前后端分离项目</title>
    <link href="https://lonesome.cn/blog/record/ubuntu-deploy-gin-and-vue-project/"/>
    <id>https://lonesome.cn/blog/record/ubuntu-deploy-gin-and-vue-project/</id>
    <published>2023-08-31T08:33:56.000Z</published>
    <updated>2024-08-09T18:00:22.717Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04 LTS</li><li>MySQL 版本：8.0.34</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>如果后端服务需要服务器上的数据库，需要提前准备好<br>附上 MySQL 和 Redis 的安装配置<br><a href="https://lonesome.cn/Ubuntu/Ubuntu%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%20MySQL%EF%BC%88%E5%90%AB%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%EF%BC%89/">Ubuntu 安装和配置 MySQL（含远程连接）</a><br><a href="https://lonesome.cn/Ubuntu/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis%EF%BC%88%E5%90%AB%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE%EF%BC%89/">Ubuntu 安装 Redis（含远程连接配置）</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="Go-项目打包"><a href="#Go-项目打包" class="headerlink" title="Go 项目打包"></a>Go 项目打包</h4><p>Go 支持跨平台编译，因此我们可以很轻松的将当前平台的 Go 项目打包成能够在 Linux 运行的文件<br>进入到 main.go 的文件目录下，执行以下命令（打包前记得将环境或者配置修改为服务器的）</p><h5 id="Windows-系统下"><a href="#Windows-系统下" class="headerlink" title="Windows 系统下"></a>Windows 系统下</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLE=0</span><br><span class="line">SET GOOS=linux</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build main.go</span><br></pre></td></tr></table></figure><p>注：在 cmd 中执行，PowerShell 中不知道为什么不起作用（编译出来还是 Windows 下的 .exe 文件）</p><h5 id="Mac-系统下"><a href="#Mac-系统下" class="headerlink" title="Mac 系统下"></a>Mac 系统下</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><h5 id="Linux-系统下"><a href="#Linux-系统下" class="headerlink" title="Linux 系统下"></a>Linux 系统下</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLE 是否开启 CGO，默认为 1 开启 CGO（不支持交叉编译），0 表示关闭</span><br><span class="line">GOARCH 表示目标平台的体系架构</span><br><span class="line">GOOS 表示目标平台的操作系统 Linux、Windows、Darwin（Mac）</span><br></pre></td></tr></table></figure><p>等待编译完成后就可以得到一个<strong>不带后缀</strong>的二进制文件，默认名为<code>main</code><br>如果想要指定输出的文件名，可以在 go build 时加上 <code>-o</code> 参数，如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o cms main.go</span><br></pre></td></tr></table></figure><p><code>cms</code>就是我指定输出的文件名，也是我本次部署使用的打包文件</p><h4 id="将打包文件上传到服务器"><a href="#将打包文件上传到服务器" class="headerlink" title="将打包文件上传到服务器"></a>将打包文件上传到服务器</h4><p>可以使用 xftp 上传打包文件至服务器，也可以使用对应云服务器厂商自带的 WebShell（我使用的是腾讯云的 OrcaTerm）<br>这边将打包好的 cms 文件上传到<code>/opt/go/cms</code>文件夹下（文件路径可以自己选择）<br><strong>注：如果有配置文件也需要一起上传</strong><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829160053.webp"></p><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>橙色方框中可以看到当前的权限是 640<br><img src="https://img.lonesome.cn/blog/record/R0KEPUI6PCRJ4HV7BUXX.webp"><br>也可以<code>cd /opt/go/cms</code>通过<code>ls -l</code>命令查看<br><img src="https://img.lonesome.cn/blog/record/ZUZGSO3470CLH071FY.webp"><br>想要运行该文件，我们至少需要拥有执行该文件的权利，执行下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 740 cms</span><br></pre></td></tr></table></figure><p>将执行权限赋予 root 用户（实际根据自己需求赋予不同用户组权限）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829164029.webp"><br>这时候我们其实已经可以运行了，输入<code>./cms</code>去运行我们编译好的文件<br><img src="https://img.lonesome.cn/blog/record/PLH14SNT45FW174FEOH.webp"><br>没有报错说明已经启动成功了<br>没有别的信息显示是因为部署在正式环境中，设置了<code>gin.SetMode(gin.ReleaseMode)</code>（Gin 的生产环境模式）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829174041.webp"></p><h4 id="云服务器放行端口"><a href="#云服务器放行端口" class="headerlink" title="云服务器放行端口"></a>云服务器放行端口</h4><p>想要访问后端服务，需要将服务对应运行的端口（比如我这边就是默认跑在<code>8080</code>端口）放开，不然在外部是访问不到服务器上的后端服务的<br>在云服务器厂商找到对应云服务器的防火墙，并放行 8080 端口（对应你自己后端服务的运行端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/NRFVBX4UISVNODVWBKSF.webp"><br><img src="https://img.lonesome.cn/blog/record/Z9PFY5ZLSGX0TDV8A.webp"><br>有这样一条记录就说明 8080 端口已经放行了</p><h4 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h4><p>可以通过 Apifox 测试能否正常访问<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829180656.webp"><br>可以看到能够正常访问并响应<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230829180912.webp"><br>也可以看到 Gin 自己 Logger 中间件的日志</p><h4 id="使用-Systemd-守护进程"><a href="#使用-Systemd-守护进程" class="headerlink" title="使用 Systemd 守护进程"></a>使用 Systemd 守护进程</h4><p>现在我们希望我们的后端服务能在后台运行，并且不会随着我们终端的关闭而退出，这里就需要用到守护进程，守护进程是一个在后台运行并且不受任何终端控制的进程，这里我们选择使用 systemd 守护进程<br><strong>注：本文不详细讲解 systemd，建议自行查阅相关知识</strong></p><h5 id="创建-service-文件"><a href="#创建-service-文件" class="headerlink" title="创建 service 文件"></a>创建 service 文件</h5><p>先<code>CTRL+C</code>结束启动的服务回到 linux 命令行<br>在<code>/etc/systemd/system</code>路径下新建一个<code>cms.service</code>文件，文件名可以自己取，<strong>文件后缀<code>.service</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/systemd/system/cms.service</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/NL0112OBHO5LAN1.webp"></p><h5 id="编辑-service-文件"><a href="#编辑-service-文件" class="headerlink" title="编辑 service 文件"></a>编辑 service 文件</h5><p>使用 vim 打开编辑该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/cms.service</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=cms（contact manager system）backend server daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/opt/go/cms/cms</span><br><span class="line">WorkingDirectory=/opt/go/cms</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=10s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>参数解释（想要了解更多参数和配置可以参考这篇 <a href="https://blog.cnpatrickstar.com/all/systemd/">利用 Systemd 守护进程 | 派大星的石头屋</a>）</p><ul><li>Unit<ul><li><code>Description</code>：简短描述</li></ul></li><li>Service<ul><li><code>Type</code>：启动类型，<code>simple</code>表示<code>ExecStart</code>字段启动的进程为主进程</li><li><code>ExecStart</code>：启动当前服务的命令，即打包文件的具体路径</li><li><code>WorkingDirectory</code>：指定服务运行目录，即打包文件所在的文件夹</li><li><code>Restart</code>：定义何种情况 Systemd 会自动重启当前服务，<code>always</code>表示总是重启</li><li><code>RestartSec</code>：自动重启当前服务间隔的秒数</li></ul></li><li>Install<ul><li><code>WantedBy</code>：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入<code>/etc/systemd/system</code>目录下面以 Target 名 + <code>.wants</code>后缀构成的子目录中</li></ul></li></ul><p>将<code>Description</code>、<code>ExecStart</code>和<code>WorkingDirectory</code>修改为自己的即可<br>然后将修改完的代码粘贴到我们正在编辑的文件中<br><img src="https://img.lonesome.cn/blog/record/G436JSFBJZEUK89SIT.webp"><br>按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h5 id="启动-service"><a href="#启动-service" class="headerlink" title="启动 service"></a>启动 service</h5><p>输入下面命令即可启动后端服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start cms <span class="comment">## cms 对应修改为你之前创建的 service 文件名</span></span><br></pre></td></tr></table></figure><p>然后可以通过下面命令查看服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status cms <span class="comment">## cms 对应修改为你之前创建的 service 文件名</span></span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/HQKISXD165OZKZL6FBE.webp"><br><code>active (running)</code>说明服务已经成功启动，即我们的后端服务已经在后台运行了<br>附上其他相关命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 停止</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop cms <span class="comment">## cms 对应修改为你之前创建的 service 文件名</span></span><br><span class="line"><span class="comment">## 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart cms <span class="comment">## cms 对应修改为你之前创建的 service 文件名</span></span><br><span class="line"><span class="comment">## 设置开机自启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> cms <span class="comment">## cms 对应修改为你之前创建的 service 文件名</span></span><br><span class="line"><span class="comment">## 取消开机自启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> cms <span class="comment">## cms 对应修改为你之前创建的 service 文件名</span></span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理，将域名映射到-ip-port（可选）"><a href="#Nginx-反向代理，将域名映射到-ip-port（可选）" class="headerlink" title="Nginx 反向代理，将域名映射到 ip:port（可选）"></a>Nginx 反向代理，将域名映射到 ip:port（可选）</h3><p>完成部署后后端服务已经可以通过服务器的 ip 地址和端口进行访问<br>如果想实现将某个域名映射到 ip:port，即通过访问域名实现对后端服务的访问，我们需要用 Nginx 进行一个反代（因为域名只能绑定 ip）<br><strong>注：本文不详细讲解 Nginx，建议自行查阅相关知识</strong></p><h4 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h4><p>需要有一个解析到该服务器的域名，可以创建一个子域名</p><h4 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><p>Ubuntu 下输入下面命令即可安装 Nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure><p>中间会询问是否继续安装，输入<code>y</code>回车即可<br>等待安装完成，可以输入下面命令查看 Nginx 服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/EDV35FALEFZGZLWM.webp"><br>安装完成后，Nginx 服务会自己启动，可以看到 Nginx 服务已经正常运行</p><h4 id="配置文件部分说明"><a href="#配置文件部分说明" class="headerlink" title="配置文件部分说明"></a>配置文件部分说明</h4><p>Nginx 配置文件路径默认在<code>/etc/nginx</code><br>可以输入下面命令查看 Nginx 配置文件位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830191656.webp"><br>红框中即 Nginx 主要配置文件所在的位置<br><code>cd /etc/nginx</code>到 Nginx 目录下，<code>ls</code>查看结构<br><img src="https://img.lonesome.cn/blog/record/2Y439YQRU5BRIX1.webp"></p><ul><li>nginx.conf 即 Nginx 的主要配置文件，可以直接在该文件中进行修改（大多数教程也是这么做的），但是如果以后部署的服务多起来，都放在一个配置文件中会显得混乱和臃肿</li><li>新版本的 Nginx 允许我们在 nginx.conf 中导入其他文件夹中的 .conf 文件，因此我们可以针对不同的服务，建立不同的 conf 配置文件，方便管理</li><li>而 Nginx 已经为我们建好了一个文件夹，并且导入到了配置文件中，即 conf.d 文件夹，我们可以直接在该文件夹下新建和添加配置文件</li><li>注：nginx.conf 中有关于 Nginx 整体的相关配置，但这里不多介绍，我们也不去修改</li></ul><h4 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h4><p>在<code>/etc/nginx/conf.d</code>路径下新建一个<code>cms.conf</code>文件，文件名可以自己取，<strong>文件后缀<code>.conf</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/3B0GRKG2UGO5K0RW71FL.webp"></p><h4 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>使用 vim 打开编辑该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    ## 服务端绑定的域名</span><br><span class="line">    server_name cms-back.ximo210.top;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        ## 需要映射到的端口</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在<code>server_name</code>填入你要绑定的域名，比如我这边就是<code>cms-back.ximo210.top</code></li><li>在<code>proxy_pass</code>填入你需要映射到的端口，比如我需要的是 8080 端口</li><li><code>listen 80</code>表示的是监听的端口，因为 http 请求默认访问的是 80 端口，举例来说当我们在访问<code>www.baidu.com</code>的时候其实访问的是<code>www.baidu.com:80</code>，不过 80 可以省略</li></ul><p>将上面的代码理解一下就是当我直接访问<code>cms-back.ximo210.top</code>时，Nginx 会监听到 80 端口有请求，然后做一个反向代理将这个请求发送到 8080 端口，实现将对域名的请求映射到 ip:port<br>将修改完的代码粘贴进配置文件<br><img src="https://img.lonesome.cn/blog/record/1P96O59EALYVEC5.webp"><br>按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h4 id="重启-Nginx"><a href="#重启-Nginx" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h4><p>输入下面命令重启 Nginx 以应用修改后的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/SNNUYZC36G3SNMJXYKL.webp"></p><h4 id="测试访问-1"><a href="#测试访问-1" class="headerlink" title="测试访问"></a>测试访问</h4><p><strong>注：需要确保云服务器 80 端口放开</strong><br>依旧是利用 Apifox 进行测试<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830204519.webp"><br>可以看到能够直接用域名进行访问了</p><h4 id="配置-SSL-证书（可选）"><a href="#配置-SSL-证书（可选）" class="headerlink" title="配置 SSL 证书（可选）"></a>配置 SSL 证书（可选）</h4><p>前面只能用 http 进行访问，现在我想要用 https 进行访问，并且在使用 http 访问时强制跳转 https</p><h5 id="前提-2"><a href="#前提-2" class="headerlink" title="前提"></a>前提</h5><ul><li>有对应域名的 SSL 证书，可以去申请免费的 SSL 证书</li><li>转换 SSL 证书，主要需要<code>.crt</code>和<code>.key</code>文件，具体可以自行搜索</li></ul><h5 id="上传证书文件"><a href="#上传证书文件" class="headerlink" title="上传证书文件"></a>上传证书文件</h5><p>在<code>/etc/nginx</code>目录下新建一个 cert 文件夹存放证书</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在 /etc/nginx 路径下执行</span></span><br><span class="line"><span class="built_in">mkdir</span> cert</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/D3SOC1P7WHA5EB6.webp"><br>将转换得到的<code>.crt</code>和<code>.key</code>文件上传到服务器的<code>/etc/nginx/cert</code>文件夹下<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831014907.webp"></p><h5 id="编辑配置文件-1"><a href="#编辑配置文件-1" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>依旧是编辑<code>/etc/nginx/conf.d/cms.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    ## 服务端绑定的域名</span><br><span class="line">    server_name cms-back.ximo210.top;</span><br><span class="line">    ## 强制跳转https</span><br><span class="line">    rewrite ^/(.*) https://$server_name$request_uri? permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ## SSL 默认访问端口号为 443</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ## 请填写绑定证书的域名</span><br><span class="line">    server_name cms-back.ximo210.top;</span><br><span class="line">    ## 请填写证书文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate /etc/nginx/cert/cms-back.crt;</span><br><span class="line">    ## 请填写私钥文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate_key /etc/nginx/cert/cms-back.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ## 请按照以下协议配置</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ## 请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        ## 请填写后端运行的端口</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用上述代码覆盖原先的配置<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830211400.webp"><br>并将红框部分修改为你自己的配置<br>然后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h5 id="重启-Nginx-1"><a href="#重启-Nginx-1" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h5><p>先检查配置有无问题</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/NGQMR0DB8C7C23IWP7.webp"><br>没有问题则<code>sudo nginx -s reload</code>重启 Nginx 以应用修改</p><h5 id="测试访问-2"><a href="#测试访问-2" class="headerlink" title="测试访问"></a>测试访问</h5><p><strong>注：需要确保云服务器 80 和 443 端口放开</strong><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830212807.webp"><br>实际在访问 http 时也会强制跳转到 https，这里就不做演示了</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="前提-3"><a href="#前提-3" class="headerlink" title="前提"></a>前提</h3><p>已经部署完后端并且能够正常访问</p><h3 id="Vue-项目打包"><a href="#Vue-项目打包" class="headerlink" title="Vue 项目打包"></a>Vue 项目打包</h3><p>在 Vue 项目的根目录执行下面的命令，打包成 dist 目录（打包前记得将环境或者配置修改为服务器的）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>将 dist 目录重命名为 cms（名字自取）</p><h3 id="将打包文件上传到服务器-1"><a href="#将打包文件上传到服务器-1" class="headerlink" title="将打包文件上传到服务器"></a>将打包文件上传到服务器</h3><p>可以使用 xftp 上传打包文件至服务器，也可以使用对应云服务器厂商自带的 WebShell（我使用的是腾讯云的 OrcaTerm）<br>这边将打包好的 cms 文件上传到<code>/var/www</code>文件夹下（文件路径可以自己选择）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830214131.webp"></p><h3 id="修改文件权限-1"><a href="#修改文件权限-1" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>将 cms 目录的权限修改为 755，确保 Nginx 对该文件有访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www</span><br><span class="line">chmod -R 755 cms</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/QMRBFNNL5RU2DR59D.webp"></p><h3 id="安装-Nginx-1"><a href="#安装-Nginx-1" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><p><strong>注：如果是从后端 Nginx 部分看过来的，可以直接跳到编辑配置文件，将内容添加到原有配置的后面即可</strong><br>Ubuntu 下输入下面命令即可安装 Nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure><p>中间会询问是否继续安装，输入<code>y</code>回车即可<br>等待安装完成，可以输入下面命令查看 Nginx 服务状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status nginx</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/EDV35FALEFZGZLWM.webp"><br>安装完成后，Nginx 服务会自己启动，可以看到 Nginx 服务已经正常运行</p><h3 id="配置文件部分说明-1"><a href="#配置文件部分说明-1" class="headerlink" title="配置文件部分说明"></a>配置文件部分说明</h3><p>Nginx 配置文件路径默认在<code>/etc/nginx</code><br>可以输入下面命令查看 Nginx 配置文件位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230830191656.webp"><br>红框中即 Nginx 主要配置文件所在的位置<br><code>cd /etc/nginx</code>到 Nginx 目录下，<code>ls</code>查看结构<br><img src="https://img.lonesome.cn/blog/record/2Y439YQRU5BRIX1.webp"></p><ul><li>nginx.conf 即 Nginx 的主要配置文件，可以直接在该文件中进行修改（大多数教程也是这么做的），但是如果以后部署的服务多起来，都放在一个配置文件中则会显得混乱和臃肿</li><li>新版本的 Nginx 允许我们在 nginx.conf 中导入其他文件夹中的 .conf 文件，因此我们可以针对不同的服务，建立不同的 conf 配置文件，方便管理</li><li>而 Nginx 已经为我们建好了一个文件夹，并且导入到了配置文件中，即 conf.d 文件夹，我们可以直接在该文件夹下新建和添加配置文件</li><li>注：nginx.conf 中有关于 Nginx 整体的相关配置，但这里不多介绍，我们也不去修改</li></ul><h3 id="新建配置文件-1"><a href="#新建配置文件-1" class="headerlink" title="新建配置文件"></a>新建配置文件</h3><p>在<code>/etc/nginx/conf.d</code>路径下新建一个<code>cms.conf</code>文件，文件名可以自己取，<strong>文件后缀<code>.conf</code></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/3B0GRKG2UGO5K0RW71FL.webp"></p><h3 id="编辑配置文件-2"><a href="#编辑配置文件-2" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>使用 vim 打开编辑该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ## 监听的端口号（即想要访问的前端服务的端口）</span><br><span class="line">    listen 5173;</span><br><span class="line">    server_name localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        ## 打包文件的路径</span><br><span class="line">        root /var/www/cms;</span><br><span class="line">        index index.html;</span><br><span class="line">        ## 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ## 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    ## 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">        rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ## 将所有 ip:port/api 的请求转发到对应的后端地址（根据自己实际情况修改）</span><br><span class="line">    location /api &#123;</span><br><span class="line">    ## 填写后端服务的端口（如果不是同一台服务器则填写对应服务器的地址）</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将红框部分的代码修改为你自己的配置后写进配置文件<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831001719.webp"><br>按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h3 id="重启-Nginx-2"><a href="#重启-Nginx-2" class="headerlink" title="重启 Nginx"></a>重启 Nginx</h3><p>输入下面命令重启 Nginx 以应用修改后的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/SNNUYZC36G3SNMJXYKL.webp"></p><h3 id="云服务器放行端口-1"><a href="#云服务器放行端口-1" class="headerlink" title="云服务器放行端口"></a>云服务器放行端口</h3><p>想要访问前端页面，需要将服务对应运行的端口（比如我这边就是在<code>5173</code>端口）放开，不然直接访问是访问不到的<br>在云服务器厂商找到对应云服务器的防火墙，并放行 5173 端口（对应你自己前端的运行端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/MRGQM5CQONK6SS7OPMX.webp"><br><img src="https://img.lonesome.cn/blog/record/OS54NJCTVKLJ9Y8G8YY.webp"><br>有这样一条记录就说明 5173 端口已经放行了</p><h3 id="测试访问-3"><a href="#测试访问-3" class="headerlink" title="测试访问"></a>测试访问</h3><p>在浏览器输入<code>ip:5173</code>（对应你自己的<code>ip:port</code>）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831002111.webp"><br>可以看到能正常访问</p><h3 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h3><p>前面是直接使用 ip:port 去访问前端，现在我想要通过域名去访问</p><h4 id="前提-4"><a href="#前提-4" class="headerlink" title="前提"></a>前提</h4><p>需要有一个解析到该服务器的域名（可以创建一个子域名）</p><h4 id="编辑配置文件-3"><a href="#编辑配置文件-3" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h4><p>依旧是编辑<code>/etc/nginx/conf.d/cms.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    ## 前端绑定的域名</span><br><span class="line">    server_name cms.ximo210.top;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        ## 打包文件的路径</span><br><span class="line">        root /var/www/cms;</span><br><span class="line">        index index.html;</span><br><span class="line">        ## 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ## 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    ## 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">        rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ## 将所有 ip:port/api 的请求转发到对应的后端地址（根据自己实际情况修改）</span><br><span class="line">    location /api &#123;</span><br><span class="line">    ## 填写后端服务的端口（如果不是同一台服务器则填写对应服务器的地址）</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原先的基础上修改</p><ul><li><code>listen</code>修改为 80，表示的是监听的端口，因为 http 请求默认访问的是 80 端口，举例来说当我们在访问<code>www.baidu.com</code>的时候其实访问的是<code>www.baidu.com:80</code>，不过 80 可以省略</li><li>在<code>server_name</code>填入你要绑定的域名，比如我这边就是<code>cms.ximo210.top</code></li></ul><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831003615.webp"><br>修改完后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h4 id="测试访问-4"><a href="#测试访问-4" class="headerlink" title="测试访问"></a>测试访问</h4><p><code>sudo nginx -s reload</code>重启 Nginx 以应用修改<br><strong>注：需要确保云服务器 80 端口放开</strong><br>在浏览器输入<code>http://cms.ximo210.top</code>（对应你自己的域名）<br><img src="https://img.lonesome.cn/blog/record/NBLC7GWHT2GO7WJ0T9.webp"><br>可以看到能正常访问</p><h4 id="配置-SSL-证书（可选）-1"><a href="#配置-SSL-证书（可选）-1" class="headerlink" title="配置 SSL 证书（可选）"></a>配置 SSL 证书（可选）</h4><p>前面只能用 http 进行访问，现在我想要用 https 进行访问，并且在使用 http 访问时强制跳转 https</p><h5 id="前提-5"><a href="#前提-5" class="headerlink" title="前提"></a>前提</h5><ul><li>有对应域名的 SSL 证书，可以去申请免费的 SSL 证书</li><li>转换 SSL 证书，主要需要<code>.crt</code>和<code>.key</code>文件，具体可以自行搜索</li><li><strong>注：如果配置了后端域名的 SSL 证书，需要另外再申请一个给当前前端的域名</strong></li></ul><h5 id="上传证书文件-1"><a href="#上传证书文件-1" class="headerlink" title="上传证书文件"></a>上传证书文件</h5><p>在<code>/etc/nginx</code>目录下新建一个 cert 文件夹存放证书</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在 /etc/nginx 路径下执行</span></span><br><span class="line"><span class="built_in">mkdir</span> cert</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/D3SOC1P7WHA5EB6.webp"><br>将转换得到的<code>.crt</code>和<code>.key</code>文件上传到服务器的<code>/etc/nginx/cert</code>文件下<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831014843.webp"></p><h5 id="编辑配置文件-4"><a href="#编辑配置文件-4" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h5><p>依旧是编辑<code>/etc/nginx/conf.d/cms.conf</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/cms.conf</span><br></pre></td></tr></table></figure><p>输入<code>i</code>进入编辑模式（在英文输入法下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    ## 前端绑定的域名</span><br><span class="line">    server_name cms.ximo210.top;</span><br><span class="line">    ## 强制跳转https</span><br><span class="line">    rewrite ^/(.*) https://$server_name$request_uri? permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ## SSL 默认访问端口号为 443</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ## 请填写绑定证书的域名</span><br><span class="line">    server_name cms.ximo210.top;</span><br><span class="line">    ## 请填写证书文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate /etc/nginx/cert/cms.crt;</span><br><span class="line">    ## 请填写私钥文件的相对路径或绝对路径</span><br><span class="line">    ssl_certificate_key /etc/nginx/cert/cms.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ## 请按照以下协议配置</span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ## 请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        ## 打包文件的路径</span><br><span class="line">        root /var/www/cms;</span><br><span class="line">        index index.html;</span><br><span class="line">        ## 此处的 @router 实际上是引用下面的转发，否则在 Vue 路由刷新时可能会抛出 404</span><br><span class="line">        try_files $uri $uri/ @router;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ## 由于路由的资源不一定是真实的路径，无法找到具体文件</span><br><span class="line">    ## 所以需要将请求重写到 index.html 中，然后交给真正的 Vue 路由处理请求资源</span><br><span class="line">    location @router &#123;</span><br><span class="line">        rewrite ^.*$ /index.html last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ## 将所有 ip:port/api 的请求转发到对应的后端地址（根据自己实际情况修改）</span><br><span class="line">    location /api &#123;</span><br><span class="line">    ## 填写后端服务的端口（如果不是同一台服务器则填写对应服务器的地址）</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用上述代码覆盖原先的配置<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831014400.webp"><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831021043.webp"><br>并将红框部分修改为你自己的配置<br>然后按<code>Esc</code>退出编辑模式，输入<code>:wq</code>（包括<code>:</code>，在英文输入法下）后回车即保存退出</p><h5 id="测试访问-5"><a href="#测试访问-5" class="headerlink" title="测试访问"></a>测试访问</h5><p><code>sudo nginx -s reload</code>重启 Nginx 以应用修改<br><strong>注：需要确保云服务器 80 和 443 端口放开</strong><br>在浏览器输入<code>https://cms.ximo210.top</code>（对应你自己的域名）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230831021358.webp"><br>可以看到能正常访问<br>实际在访问 http 时也会强制跳转到 https，这里就不做演示了</p>]]></content>
    
    
    <summary type="html">Ubuntu 部署 Gin+Vue 前后端分离项目记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Gin" scheme="https://lonesome.cn/tags/Gin/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
    <category term="Vue" scheme="https://lonesome.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 Redis 并配置远程连接</title>
    <link href="https://lonesome.cn/blog/record/ubuntu-install-redis-and-configure-remote-connection/"/>
    <id>https://lonesome.cn/blog/record/ubuntu-install-redis-and-configure-remote-connection/</id>
    <published>2023-08-28T10:03:00.000Z</published>
    <updated>2024-08-09T18:01:40.037Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>系统：Ubuntu 22.04 LTS</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><h2 id="一、安装-Redis"><a href="#一、安装-Redis" class="headerlink" title="一、安装 Redis"></a>一、安装 Redis</h2><h3 id="1-更新软件包列表"><a href="#1-更新软件包列表" class="headerlink" title="1.更新软件包列表"></a>1.更新软件包列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%7D$R%5D2DXU1%29SN_%28AG%5D5B90W7.webp"></p><h3 id="2-查看是否安装-Redis"><a href="#2-查看是否安装-Redis" class="headerlink" title="2.查看是否安装 Redis"></a>2.查看是否安装 Redis</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/C$1LTE%7DH8RVR%7DZZG9H%60G8%7D6.webp"><br>如果输入上述命令后没有任何的输出（如上图），则说明没有安装 Redis</p><h3 id="3-安装-Redis"><a href="#3-安装-Redis" class="headerlink" title="3.安装 Redis"></a>3.安装 Redis</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install redis-server</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827165945.webp"><br>这里列出了软件包的相关信息并询问你是否继续安装<br>输入<code>y</code>后回车确定继续安装<br>等待安装完后再输入第 2 步的命令查看 Redis 是否已经安装<br><img src="https://img.lonesome.cn/blog/record/LuSOlUCZ.webp"><br>输出如上图，说明 Redis 已经安装成功  <br>安装的 Redis 版本默认为当前 apt 源中最新的稳定版本，可以输入下面的命令查看 Redis 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server -v</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%5B@R%5D%60D4U%7DC%7BIIVA%7D_5@1EHX.webp"><br>注：写本文时的版本为 6.0.16</p><h3 id="4-查看-Redis-状态"><a href="#4-查看-Redis-状态" class="headerlink" title="4.查看 Redis 状态"></a>4.查看 Redis 状态</h3><p>一旦安装完成，Redis 服务将会自动启动，想要查看 Redis 服务运行状态可以输入下面命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827172654.webp"><br>输出显示 Redis 服务已经被启动，并且正在运行</p><h3 id="5-启动、重启、停止-Redis-服务的命令"><a href="#5-启动、重启、停止-Redis-服务的命令" class="headerlink" title="5.启动、重启、停止 Redis 服务的命令"></a>5.启动、重启、停止 Redis 服务的命令</h3><p>上一步的命令可以用来查看 Redis 服务的运行状态，下面是启动、重启、停止命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start redis</span><br><span class="line"><span class="comment">## 停止</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop redis</span><br><span class="line"><span class="comment">## 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure><p>停止和启动命令的演示<br><img src="https://img.lonesome.cn/blog/record/AzWn6nmz.webp"><br><img src="https://img.lonesome.cn/blog/record/ExoxlCnJ.webp"></p><h3 id="6-测试-Redis"><a href="#6-测试-Redis" class="headerlink" title="6.测试 Redis"></a>6.测试 Redis</h3><p>输入下面命令连接到 Redis 服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/OZ166RP970H7XNCEK.webp"><br>使用<code>乒乓</code>来测试连通性，输入<code>ping</code><br><img src="https://img.lonesome.cn/blog/record/NA4P5OMQ6T7TQ7ZUO.webp"><br>返回<code>pong</code>说明成功！<br>退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h2 id="二、配置-Redis-远程连接"><a href="#二、配置-Redis-远程连接" class="headerlink" title="二、配置 Redis 远程连接"></a>二、配置 Redis 远程连接</h2><p>配置 Redis 主要是对配置文件 redis.conf 进行修改，默认位置在 &#x2F;etc&#x2F;redis&#x2F;redis.conf</p><h3 id="1-查找-Redis-配置文件"><a href="#1-查找-Redis-配置文件" class="headerlink" title="1.查找 Redis 配置文件"></a>1.查找 Redis 配置文件</h3><p>使用之前的<code>sudo systemctl status redis</code>命令查看 Redis 服务的状态<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827210532.webp"><br>可以找到这样一个文件<br>然后使用下面的命令查看该文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /lib/systemd/system/redis-server.service</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230827224128.webp"><br>就可以找到我们 redis.conf 文件所在的位置</p><h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="2.编辑配置文件"></a>2.编辑配置文件</h3><p>使用 vim 编辑 redis.conf 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/FVFBYWHUN8A0GGTN52.webp"></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Redis 默认开启保护模式，并且绑定了本地，也就是只有云服务器本地才能连接并操作 Redis</p><ul><li>保护模式：如果符合下面两个条件（不是之一）则无法被远程连接<ol><li>没有明确使用 bind 绑定某个 ip 地址</li><li>没有设置密码</li></ol></li><li>想要实现远程连接主要有三种方案<ol><li>取消本地绑定（可以被任何 ip 访问），设置密码</li><li>明确绑定某个 ip 地址，设置密码（可选）</li><li>取消本地绑定（可以被任何 ip 访问），关闭保护模式</li></ol></li></ul><h4 id="取消本地绑定-绑定某个-ip-地址"><a href="#取消本地绑定-绑定某个-ip-地址" class="headerlink" title="取消本地绑定&#x2F;绑定某个 ip 地址"></a>取消本地绑定&#x2F;绑定某个 ip 地址</h4><p>移动光标定位到<code>bind 127.0.0.1 ::1</code><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020231014230542.webp"><br>输入<code>i</code>进入编辑模式（在英文输入法下）<br><code>bind 127.0.0.1 ::1</code>的意思是只接受本机的访问请求</p><ul><li>如果想取消本地绑定（可以被任何 ip 访问）<ul><li>将该行注释掉（在前面加<code>#</code>，即<code>## bind 127.0.0.1 ::1</code>），表示接受任何 ip 地址的访问</li></ul></li><li>如果想明确绑定某个 ip 地址<ul><li>将<code>127.0.0.1</code>替换为指定的 ip 地址即可</li></ul></li></ul><h4 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h4><p>移动光标定位到<code>## requirepass foobared</code><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828000035.webp"><br>取消该行注释（删除<code>#</code>），并将<code>foobared</code>修改为你想要设置的密码<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828000310.webp"><br>如 123456 就是我设置的密码<br>配置修改生效后再进入 Redis 命令行时需要输入密码登录<br>即使用<code>redis-cli -a your_password</code>命令登录，<code>your_password</code>是你自己设置的密码<br>示例：<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828113506.webp"><br>如果不输入密码进入则会报错未授权<br><img src="https://img.lonesome.cn/blog/record/B6YLQTNK3SY033I8RQ.webp"></p><h4 id="关闭保护模式"><a href="#关闭保护模式" class="headerlink" title="关闭保护模式"></a>关闭保护模式</h4><p>移动光标定位到<code>protected-mode yes</code><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020231014210256.webp"><br>将<code>yes</code>修改为<code>no</code>即表示关闭保护模式</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>一般在上线部署时（只在云服务器本地运行），不需要修改配置文件</li><li>线下调试时，希望开发环境也可以连接到 Redis（方案一）<ul><li><code>## bind 127.0.0.1 ::1</code>，取消本地绑定（可以被任何 ip 访问）</li><li><code>protected-mode yes</code>，保护模式默认开启即可</li><li><code>requirepass your_password</code>，设置密码</li></ul></li></ul><p>以上仅作为参考，具体可以自行选择</p><h3 id="3-重启-Redis-服务"><a href="#3-重启-Redis-服务" class="headerlink" title="3.重启 Redis 服务"></a>3.重启 Redis 服务</h3><p>按<code>Esc</code>退出编辑模式，然后输入<code>:wq</code>后回车保存文件并退出（在英文输入法下）<br>输入下面命令重启 Redis 服务以应用修改后的配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure><p>输入以下命令查看 Redis 服务所监听的 ip 和端口（以方案一设置为例）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlpn | grep redis</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/ECFUWVWTNV92UG54.webp"><br>可以看到 Redis 绑定的 ip 已经变成了 0.0.0.0，即接受任何 ip 地址的访问</p><h3 id="4-云服务器放行-6379-端口"><a href="#4-云服务器放行-6379-端口" class="headerlink" title="4.云服务器放行 6379 端口"></a>4.云服务器放行 6379 端口</h3><p>在云服务器厂商找到对应云服务器的防火墙，并放行 6379 端口（Redis 的默认端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/I5OJRTPQ8PURYVHS.webp"><br><img src="https://img.lonesome.cn/blog/record/TXMS8UF3QGJLKNKM4VBD.webp"><br>有这样一条记录就说明 6379 端口已经放行了</p><h3 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5.测试连接"></a>5.测试连接</h3><p>本文使用 Another Redis Desktop Manager 测试连接云服务器上的 Redis<br><img src="https://img.lonesome.cn/blog/record/20230828005651.webp"><br>地址填你云服务器的 ip 地址<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230828005841.webp"><br>连接成功！</p>]]></content>
    
    
    <summary type="html">Ubuntu 安装 Redis 并配置远程连接记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="Redis" scheme="https://lonesome.cn/tags/Redis/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 安装 MySQL 并配置远程连接</title>
    <link href="https://lonesome.cn/blog/record/ubuntu-install-mysql-and-configure-remote-connection/"/>
    <id>https://lonesome.cn/blog/record/ubuntu-install-mysql-and-configure-remote-connection/</id>
    <published>2023-08-25T20:56:07.000Z</published>
    <updated>2024-08-09T18:01:21.664Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文环境<ul><li>云服务器：腾讯云（不同厂商云服务器上的操作基本相同）</li><li>系统：Ubuntu 22.04 LTS</li><li>终端：<a href="https://orcaterm.cloud.tencent.com/terminal">腾讯云 OrcaTerm</a>（可使用 Xshell+Xftp 代替）</li></ul></li><li>本文全部 shell 终端指令均执行在 <strong>root</strong>  用户下（命令前的<code>sudo</code>可不加），如果是非 root 用户也许本文中某些没加<code>sudo</code>命令也要加上<code>sudo</code></li></ul><h2 id="一、安装-MySQL"><a href="#一、安装-MySQL" class="headerlink" title="一、安装 MySQL"></a>一、安装 MySQL</h2><h3 id="1-更新软件包列表"><a href="#1-更新软件包列表" class="headerlink" title="1.更新软件包列表"></a>1.更新软件包列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%7D$R%5D2DXU1%29SN_%28AG%5D5B90W7.webp"></p><h3 id="2-查看是否安装-MySQL"><a href="#2-查看是否安装-MySQL" class="headerlink" title="2.查看是否安装 MySQL"></a>2.查看是否安装 MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/url-SIeWkuuv8c6ERv3r.webp"><br>如果输入上述命令后没有任何的输出（如上图），则说明没有安装 MySQL</p><h3 id="3-安装-MySQL"><a href="#3-安装-MySQL" class="headerlink" title="3.安装 MySQL"></a>3.安装 MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mysql-server</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825152339.webp"><br>这里列出了软件包的相关信息并询问你是否继续安装<br>输入<code>y</code>后回车确定继续安装<br>等待安装完后再输入第 2 步的命令查看 MySQL 是否已经安装<br><img src="https://img.lonesome.cn/blog/record/H9nCE8Yq.webp"><br>输出如上图，说明 MySQL 已经安装成功<br>安装的 MySQL 版本默认为当前 apt 源中最新的稳定版本，可以输入下面的命令查看 MySQL 版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --version</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/url-IDI7IQUlrPQnNw09.webp"><br>注：写本文时的版本为 8.0.34</p><h3 id="4-查看-MySQL-状态"><a href="#4-查看-MySQL-状态" class="headerlink" title="4.查看 MySQL 状态"></a>4.查看 MySQL 状态</h3><p>一旦安装完成，MySQL 服务将会自动启动，想要查看 MySQL 服务运行状态可以输入下面命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825153214.webp"><br>输出显示 MySQL 服务已经被启动，并且正在运行</p><h3 id="5-启动、重启、停止-MySQL-服务的命令"><a href="#5-启动、重启、停止-MySQL-服务的命令" class="headerlink" title="5.启动、重启、停止 MySQL 服务的命令"></a>5.启动、重启、停止 MySQL 服务的命令</h3><p>上一步的命令可以用来查看 MySQL 服务的运行状态，下面是启动、重启、停止命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start mysql</span><br><span class="line"><span class="comment">## 停止</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl stop mysql</span><br><span class="line"><span class="comment">## 重启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br></pre></td></tr></table></figure><p>停止和启动命令的演示<br><img src="https://img.lonesome.cn/blog/record/s5yRX0ih.webp"><br><img src="https://img.lonesome.cn/blog/record/5duzWs8r.webp"></p><h3 id="6-开机自启动设置（可选）"><a href="#6-开机自启动设置（可选）" class="headerlink" title="6.开机自启动设置（可选）"></a>6.开机自启动设置（可选）</h3><p>注：使用<code>systemd</code>管理服务，前提是使用 apt 安装的 MySQL<br>当前新版本的 MySQL 服务默认是开机自启动，可以通过前面的<code>sudo systemctl status mysql</code>命令查看<br><img src="https://img.lonesome.cn/blog/record/CcyP3qLl.webp"><br>该处的参数为<code>enabled</code>，说明当前 MySQL 服务是开机自启动<br>可以用下面命令关闭开机自启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">disable</span> mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/V7INkdDD.webp"><br>查看状态可以发现原本的<code>enabled</code>参数变成了<code>disabled</code>，说明 MySQL 服务不再是开机自启动<br><img src="https://img.lonesome.cn/blog/record/P8A9j8Aa.webp"><br>附上开启开机自启动的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl enabled mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/ShgYmSAY.webp"><br>再次查看状态就可以发现又变回了<code>enabled</code></p><h2 id="二、MySQL-安全配置向导"><a href="#二、MySQL-安全配置向导" class="headerlink" title="二、MySQL 安全配置向导"></a>二、MySQL 安全配置向导</h2><p>MySQL 安装文件时会附带一个名为<code>mysql_secure_installation</code>的脚本，我们可以通过运行该脚本提高 MySQL 的安全性</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825155820.webp"><br>这里有一个插件<code>VALIDATE PASSWORD PLUGIN</code>，它可以测试 MySQL 用户密码的强度，并且提高安全性，如果你想设置验证密码插件，按<code>y</code>回车后移动到下一个步骤<br><strong>注：如果不想设置复杂密码（比如想设置密码是 123456）的建议选择输入<code>n</code>不设置验证密码的插件，因为即使是下面的 LOW 策略也要求密码长度至少为 8 位（<del>安全性哪有方便重要</del>）</strong><br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825160155.webp"><br>这里给出了低级，中级，高级三个级别的密码验证策略</p><ul><li>低级 长度 &gt;&#x3D; 8</li><li>中级 在低级的基础上，需要同时包含数字，大小写字母和特殊字符</li><li>高级 在中级的基础上，要求密码不能存在字典文件中</li></ul><p>可以输入对应级别前的数字进行选择，这边选择了 STRONG（即 2）<br><img src="https://img.lonesome.cn/blog/record/J_T8D9BD%60HFXU5E5LQHE0%7B4.webp"></p><blockquote><p>注：这里是输入 2 后回车，显示的上半部分内容，我在写本文时从网上找到的教程在这里都会有要你设置密码的一步，但是在新版本的 MySQL 是没有的，被上面这段话代替了，翻译过来的意思是：</p><blockquote><p>默认情况下，使用 auth_socket 进行身份验证，因此跳过为 root 用户设置密码。<br>如果你想改用密码身份验证，可以使用”ALTER_USER”命令进行设置。<br>请参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/alter-user.html#alter-user-password-management">https://dev.mysql.com/doc/refman/8.0/en/alter-user.html#alter-user-password-management</a> 获取更多信息。</p></blockquote><p>这边仅做一个补充，为 root 用户设置密码的操作在第三部分会提到</p></blockquote><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825175750.webp"><br>询问是否删除匿名用户，建议输入<code>y</code>删除</p><ul><li>在 MySQL 中，默认情况下会存在一个匿名用户（没有用户名和密码就可以登录），该用户具有一些基本的权限</li><li>如果每个用户都有明确的身份和权限，可以更容易地追踪和监视数据库的活动，识别潜在的安全问题</li><li>为了确保数据库仅允许经过授权的用户进行访问和操作，减少潜在的安全风险，建议删除匿名用户</li></ul><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825180256.webp"><br>询问是否禁止 root 远程登录，根据自己需求选择，如果你想要使用 root 用户远程连接 MySQL 数据库，可以输入任意键跳过该设置<br>出于安全考虑，建议输入<code>y</code>禁止</p><ul><li>root 是 MySQL 数据库的超级管理员，拥有最高权限，一旦泄露后果非常严重，禁止 root 用户远程登录可以降低潜在的风险</li><li>更推荐的做法是创建一个普通用户，并为其授予适当的权限，以便远程访问数据库，这样做可以限制对数据库的访问权限，并提供额外的安全层</li><li>禁止 root 用户远程登录还可以防止意外的操作或误操作</li></ul><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825182358.webp"><br>询问是否删除 test 数据库，输入<code>y</code>删除<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230825183859.webp"><br>询问是否重新加载权限表，输入<code>y</code>重新加载<br><img src="https://img.lonesome.cn/blog/record/%29%7D4J%5DMV405BP3QLORYL_A_W.webp"><br>Success.<br>All done!</p><h2 id="三、修改-root-用户验证方式（可选）"><a href="#三、修改-root-用户验证方式（可选）" class="headerlink" title="三、修改 root 用户验证方式（可选）"></a>三、修改 root 用户验证方式（可选）</h2><p>在 MySQL 5.7（及更高版本）的 Ubuntu 系统中，root 用户默认使用 auth_socket 插件授权，而不是通过密码进行身份验证（即使输入了密码也不会验证），但这并不意味着安全性降低，因为他有两个限制：</p><ul><li>只能用 UNIX 的 socket 方式登陆，这就保证了只能本地登陆，用户在使用这种登陆方式时已经通过了操作系统的安全验证</li><li>操作系统的用户和 MySQL 数据库的用户名必须一致，如果你要登陆 MySQL 的 root 用户，必须使用操作系统的 root 用户</li></ul><p>在多数情况下，这可以获得更高的安全性和可用性，但也会阻碍你使用外部程序（如 phpMyAdmin）访问数据库，或者是想使用 root 用户远程连接数据库等<br>对此有两种解决方案：</p><ul><li>将身份验证方式从 auth_socket 修改为 caching_sha2_password（即使用密码验证 root 用户）<ul><li>我在写本文时从网上找到的教程都是修改为 mysql_native_password，主要原因是因为 caching_sha2_password 在 MySQL 8.0.3 才开始引入，并且由老版本升级为新版本时会出现一些问题</li><li>但相比于 mysql_native_password，caching_sha2_password 的安全性更高，从 MySQL 8.0.4 开始，此插件成为 MySQL 服务器的新默认身份验证插件</li><li>因为我们安装的是新版的 MySQL，所以我更建议使用 caching_sha2_password</li></ul></li><li>创建一个新的管理用户，拥有所有数据库的访问权限</li></ul><h3 id="1-使用-root-身份登录-MySQL"><a href="#1-使用-root-身份登录-MySQL" class="headerlink" title="1.使用 root 身份登录 MySQL"></a>1.使用 root 身份登录 MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%7BS03JJH24BI47W_DJ%7B2OB_L.webp"><br>登入成功后输出如上图</p><h3 id="2-查看不同用户使用的身份验证方法"><a href="#2-查看不同用户使用的身份验证方法" class="headerlink" title="2.查看不同用户使用的身份验证方法"></a>2.查看不同用户使用的身份验证方法</h3><p>输入下面的命令查看数据库对不同用户使用的身份验证方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/lkdnflwelqfl.webp"><br>可以看到 root 用户确实是使用的 auth_socket 插件进行身份验证，并且密码为空</p><h3 id="方案一：修改身份验证方式"><a href="#方案一：修改身份验证方式" class="headerlink" title="方案一：修改身份验证方式"></a>方案一：修改身份验证方式</h3><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>输入下面命令将 root 用户的身份验证方式 auth_socket 修改成 caching_sha2_password，并设置登录的密码（包含在单引号之间）<br>注：需要满足在安全配置向导中选择的密码强度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;your_password&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826014853.webp"><br>如果设置的密码不满足之前选择的强度则会报下图的错误<br><img src="https://img.lonesome.cn/blog/record/G9C%29K50NNSME3D%5BN%7BLJ_OUG.webp"><br>最后输入下面命令，重新加载授权表并将更改更新到 MySQL 数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/hsu6Q8hz.webp"><br>完成后，再次运行以下命令确认 root 用户不再使用 auth_socket 进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/mANsO1EA.webp"><br>从上图中，我们可以看到 root 身份验证方式已经修改为 caching_sha2_password，即 root 用户可以使用密码作为验证方式登陆了</p><h4 id="修改后登录"><a href="#修改后登录" class="headerlink" title="修改后登录"></a>修改后登录</h4><p>输入<code>exit</code>退出 MySQL<br><img src="https://img.lonesome.cn/blog/record/dsydG4lP.webp"><br>由于我们更改了 root 的身份验证方法，因此我们不能再使用之前的命令（即<code>sudo mysql</code>）登录 MySQL<br><img src="https://img.lonesome.cn/blog/record/OaEP42tR.webp"><br>我们在登陆时需要加上用户名和密码参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>-u 表示 user，-p 表示 password，当你按下回车后，服务器会要求你输入密码<br><img src="https://img.lonesome.cn/blog/record/A_BV%7DRX%28UR$VGJB1N%2808Y66.webp"><br>考虑到安全性，输入的密码不会在屏幕上显示出来，输入正确的密码后回车即可<br><img src="https://img.lonesome.cn/blog/record/AgPmCexJ.webp"><br>登录成功</p><h3 id="方案二：创建新的管理用户（推荐）"><a href="#方案二：创建新的管理用户（推荐）" class="headerlink" title="方案二：创建新的管理用户（推荐）"></a>方案二：创建新的管理用户（推荐）</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建一个新的管理用户，并赋予所有数据库的访问权限<br>注：需要满足在安全配置向导中选择的密码强度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 创建用户并设置密码</span><br><span class="line">CREATE USER &#x27;new_root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;your_password&#x27;;</span><br><span class="line">## 赋予用户所有权限</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;new_root&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/@$H$@06%28B%5D%60ZCZ@$N4%7D9R$V.webp"><br>输入下面命令，重新加载授权表并将更改更新到 MySQL 数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/hsu6Q8hz.webp"><br>查看创建用户的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for new_root@localhost;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/%5DTKB3%7B6I9W%60%60FD@J_0A1BYV.webp"><br><del>输出格式怪怪的，可能是终端的问题，但是问题不大</del><br>可以看到所有权限都被赋予了我们新创建的 new_root 用户，之后我们就能将该用户当作 root 用户使用</p><h4 id="登录创建用户"><a href="#登录创建用户" class="headerlink" title="登录创建用户"></a>登录创建用户</h4><p>我们依旧可以使用<code>sudo mysql</code>命令登录 root 用户，但是现在我们想要登录新创建的 new_root 用户<br>输入<code>exit</code>退出 MySQL<br><img src="https://img.lonesome.cn/blog/record/dsydG4lP.webp"><br>我们在登陆时需要加上用户名和密码参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u new_root -p</span><br></pre></td></tr></table></figure><p>-u 表示 user，-p 表示 password，当你按下回车后，服务器会要求你输入密码<br><img src="https://img.lonesome.cn/blog/record/b5WrDFE0.webp"><br>考虑到安全性，输入的密码不会在屏幕上显示出来，输入正确的密码后回车即可<br><img src="https://img.lonesome.cn/blog/record/eyTXwCw1.webp"><br>登录成功</p><h2 id="四、配置远程连接"><a href="#四、配置远程连接" class="headerlink" title="四、配置远程连接"></a>四、配置远程连接</h2><p>先使用 root 身份登录 MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 没修改过 root 用户身份验证方式</span><br><span class="line">sudo mysql</span><br><span class="line">## 修改过 root 用户身份验证方式</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>推荐的做法是创建一个普通用户，并为其授予适当的权限，用来远程访问数据库<ul><li>该部分可以参考本文 <strong>修改 root 用户验证方式（可选）</strong> 中的 <strong>方案二：创建新的管理用户</strong> 部分</li><li>不同的地方在于可以根据自己的实际情况赋予创建的用户权限，相关命令可以自行百度，<del>懒得写了</del></li><li>如果暂时不清楚需要给什么权限，可以先赋予所有权限（跟着方案二即可），后续再修改</li></ul></li><li>如果想要<strong>使用 root 用户进行远程连接</strong>，请先确保已经跟着方案一<strong>修改好了 root 用户的验证方式</strong></li><li><strong>root 用户或者是自己新创建的用户，后续配置远程连接的操作都是一样的</strong>，这里用 root 用户进行演示，如果选择创建一个新的用户进行远程连接，将带有 root 用户名的部分都替换成新创建用户的用户名即可</li></ul><h3 id="1-修改-host"><a href="#1-修改-host" class="headerlink" title="1.修改 host"></a>1.修改 host</h3><p>查看 root 用户的 host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT user,host FROM mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/7G15spb7.webp"><br>如果 root 用户的 host 为<code>localhost</code>，表示只能在本地（该服务器内）登录 root 用户<br>修改  root  用户的 host  为<code>%</code><br>注：host 为<code>%</code>表示所有 ip 都有连接权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 使用名为 mysql 的数据库</span><br><span class="line">use mysql</span><br><span class="line">## 修改 host</span><br><span class="line">update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br><span class="line">## 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/9E2DV_AXTXM4HC9X%7DYNV759.webp"><br>再次查看 root 用户的 host，确认已经修改为<code>%</code><br><img src="https://img.lonesome.cn/blog/record/X%60LWJI@_%5BCCR@94K%291N0A%28P.webp"></p><h3 id="2-注释掉-bind-address"><a href="#2-注释掉-bind-address" class="headerlink" title="2.注释掉 bind-address"></a>2.注释掉 bind-address</h3><p>输入<code>exit</code>退出 MySQL，回到 Ubuntu 终端<br>使用 vim 查看编辑 MySQL 配置文件，输入下面命令后回车</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826035630.webp"><br>移动光标找到下图中标记的位置<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826035754.webp"><br>按下<code>i</code>进入 vim 的编辑模式（在英文输入法下）<br><img src="https://img.lonesome.cn/blog/record/Pasted%20image%2020230826040253.webp"><br>将该行（意思是只允许本地访问）注释掉（在前面加<code>#</code><br>然后按下<code>Esc</code>键退出编辑模式<br>再输入<code>:wq</code>（包括<code>:</code>号，在英文输入法下）后回车即保存退出</p><h3 id="3-重启-mysql-服务"><a href="#3-重启-mysql-服务" class="headerlink" title="3.重启 mysql 服务"></a>3.重启 mysql 服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart mysql</span><br></pre></td></tr></table></figure><p><img src="https://img.lonesome.cn/blog/record/ky1POFqj.webp"></p><h3 id="4-云服务器放行-3306-端口"><a href="#4-云服务器放行-3306-端口" class="headerlink" title="4.云服务器放行 3306 端口"></a>4.云服务器放行 3306 端口</h3><p>在云服务器厂商找到对应云服务器的防火墙，并放行 3306 端口（MySQL 的默认端口）<br>这里以腾讯云为例，不同厂商基本都大同小异<br><img src="https://img.lonesome.cn/blog/record/vGyI9iT3.webp"><br><img src="https://img.lonesome.cn/blog/record/JISJICEU.webp"><br>有这样一条记录就说明 3306 端口已经放行了</p><h3 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5.测试连接"></a>5.测试连接</h3><p>本文使用 Navicat 测试连接云服务器上的 MySQL<br><img src="https://img.lonesome.cn/blog/record/R14YCN%29F%5DMK%2997@GX%7DF%601%60T.webp"><br>主机填你云服务器的 ip 地址<br>用户名填你用来进行远程连接的 MySQL 用户名<br><img src="https://img.lonesome.cn/blog/record/TYVWZ7KR1EX%60L%5BM7EA_EI%280.webp"><br>结束！</p>]]></content>
    
    
    <summary type="html">Ubuntu 安装 MySQL 并配置远程连接记录</summary>
    
    
    
    <category term="日常记录" scheme="https://lonesome.cn/categories/record/"/>
    
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
    <category term="Ubuntu" scheme="https://lonesome.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Gorm 简易教程</title>
    <link href="https://lonesome.cn/blog/go-web/gorm-simple-tutorial/"/>
    <id>https://lonesome.cn/blog/go-web/gorm-simple-tutorial/</id>
    <published>2023-08-15T01:30:00.000Z</published>
    <updated>2024-08-09T14:42:12.353Z</updated>
    
    <content type="html"><![CDATA[<p>精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gorm（MySQL）<br><a href="https://www.bilibili.com/video/BV1dj411z7pW/?share_source=copy_web&vd_source=220eb9848825e3e6c13414db26a32f45">B 站授课链接点击此处</a></p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><h4 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h4><ul><li>ORM 是 Object Relational Mapping 的缩写，译为 ”对象关系映射“，他解决了对象和关系型数据库之间的数据交互问题</li><li>将<em>程序中的对象&#x2F;实例</em>与<em>关系型数据库</em>映射起来</li><li>三个映射关系<ul><li>数据表对应结构体</li><li>数据行对应结构体实例</li><li>字段对应结构体字段</li></ul></li><li>以 Go 为例：</li><li><img src="https://img.lonesome.cn/blog/go-web/84878fff-e7ef-4ab6-b6ae-3b9a52a5ff3a.webp"></li></ul><h4 id="为什么使用-ORM"><a href="#为什么使用-ORM" class="headerlink" title="为什么使用 ORM"></a>为什么使用 ORM</h4><ul><li>提高开发效率</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">    Sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := UserInfo&#123;<span class="number">1</span>, <span class="string">&quot;XiMo&quot;</span>, <span class="number">3</span>, <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 将 user 存入数据库</span></span><br><span class="line">    <span class="comment">// SQL 语句</span></span><br><span class="line">    <span class="comment">// insert into userinfo values(1,&quot;XiMo&quot;,3,&quot;male&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// orm 语句</span></span><br><span class="line"><span class="comment">// orm.Create(&amp;user)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点<ul><li>自动生成 SQL 语句，会牺牲一定的性能</li><li>对于复杂的数据库操作，ORM 通常难以处理，即使能够处理，也不如直接手写原生 SQL 语句灵活</li><li>弱化 SQL 能力</li></ul></li></ul><h3 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h3><ul><li><a href="https://gorm.io/zh_CN/">GORM</a> 是 Go 语言目前比较热门的数据库 ORM 操作库，对开发者也比较友好，使用非常简单</li></ul><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>在使用 gorm 之前我们需要下载 gorm 以及对应数据库 mysql 的驱动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get -u gorm.io/gorm</span><br><span class="line">$ <span class="keyword">go</span> get -u gorm.io/driver/mysql</span><br></pre></td></tr></table></figure><h5 id="简单连接"><a href="#简单连接" class="headerlink" title="简单连接"></a>简单连接</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局变量</span></span><br><span class="line"><span class="keyword">var</span> DB *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user := <span class="string">&quot;root&quot;</span></span><br><span class="line">    pass := <span class="string">&quot;123456&quot;</span></span><br><span class="line">    host := <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    port := <span class="string">&quot;3306&quot;</span></span><br><span class="line">    DBname := <span class="string">&quot;gorm_learn&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dsn data-source-name 告知数据库所在的位置以及数据库相关的属性</span></span><br><span class="line">    <span class="comment">// user:pass@tcp(host:port)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local</span></span><br><span class="line">    dsn := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class="line">        user, pass, host, port, DBname)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库，获得 DB 类型实例，用于后面对数据库进行的操作</span></span><br><span class="line">    db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database, error = &quot;</span> + err.Error())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值给全局变量</span></span><br><span class="line">    DB = db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 做一层简单的封装，后续操作可以直接利用全局变量 DB 进行</span></span><br><span class="line">    Init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a>模型定义</h2><h3 id="模型定义-1"><a href="#模型定义-1" class="headerlink" title="模型定义"></a>模型定义</h3><p>在使用 ORM 工具时，通常我们需要在代码中定义模型（Model）与数据库中的数据表进行映射，在 GORM 中模型（Model）通常是正常定义的结构体、由 Go 的基本数据类型、实现了  <a href="https://pkg.go.dev/database/sql/?tab=doc#Scanner">Scanner</a>  和  <a href="https://pkg.go.dev/database/sql/driver#Valuer">Valuer</a>  接口的自定义类型及其指针或别名组成<br>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID           <span class="type">uint</span></span><br><span class="line">    Name         <span class="type">string</span></span><br><span class="line">    Email        *<span class="type">string</span></span><br><span class="line">    Age          <span class="type">uint8</span></span><br><span class="line">    Birthday     *time.Time</span><br><span class="line">    MemberNumber sql.NullString</span><br><span class="line">    ActivatedAt  sql.NullTime</span><br><span class="line">    CreatedAt    time.Time</span><br><span class="line">    UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动迁移建表"><a href="#自动迁移建表" class="headerlink" title="自动迁移建表"></a>自动迁移建表</h3><p><code>AutoMigrate</code> 会根据结构体帮我们自动创建一个表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB.AutoMigrate(&amp;User)</span><br></pre></td></tr></table></figure><p><code>AutoMigrate</code> 的逻辑是只新增，不删除，不修改（可以修改大小）<br>例如 User 结构体中将 Name 改成 Username，对应的表中会多出一个 username 的字段，但是原本的 name 字段不会删除</p><h3 id="Gorm-约定"><a href="#Gorm-约定" class="headerlink" title="Gorm 约定"></a>Gorm 约定</h3><p>GORM 倾向于约定优于配置 默认情况下</p><ul><li><code>Gorm</code> 使用名为 <code>ID</code> 的字段作为主键</li><li>如果没有 <code>TableName</code> 函数，使用结构体的蛇形复数作为表名</li><li>字段名的蛇形作为列名</li><li>使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建更新时间</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体的蛇形复数作为表名（UserInfo --&gt; user_infos）</span></span><br><span class="line"><span class="comment">// 默认列名是字段名的蛇形小写（CreatedAt --&gt; created_at）</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">uint</span> <span class="comment">// 默认为主键</span></span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    Age       <span class="type">int</span></span><br><span class="line">    CreatedAt time.Time <span class="comment">// 创建记录时，如果该字段值为零值，则将该字段的值设为当前时间</span></span><br><span class="line">    UpdatedAt time.Time <span class="comment">// 更新记录时，将该字段的值设为当前时间，创建记录时，如果该字段值为零值，则将该字段的值设为当前时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果遵循 GORM 的约定，就可以少写一些配置、代码。 当然，如果约定不符合你的实际要求，<a href="https://gorm.io/zh_CN/docs/conventions.html">GORM 允许你配置它们</a></p><h4 id="主键（Primary-Key）"><a href="#主键（Primary-Key）" class="headerlink" title="主键（Primary Key）"></a>主键（Primary Key）</h4><p>GORM 默认会使用名为 ID 的字段作为表的主键，你可以通过标签  <code>primaryKey</code>  将其它字段设为主键</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 UUID 作为主键</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">uint</span></span><br><span class="line">    UUID <span class="type">int64</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复数表名（Table-Name）"><a href="#复数表名（Table-Name）" class="headerlink" title="复数表名（Table Name）"></a>复数表名（Table Name）</h4><p>表名默认就是结构体的蛇形复数，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `user_infos`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 UserInfo 的表名设置为 `user`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UserInfo)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了这种方式外还有别的方法，比如临时修改表名、修改 Gorm 的命名策略等，这边不多做涉及，可以自行查阅文档</span></span><br></pre></td></tr></table></figure><h4 id="列名"><a href="#列名" class="headerlink" title="列名"></a>列名</h4><p>数据表的列名使用的是 struct 字段名的蛇形命名<br>可以使用  <code>column</code>  标签来覆盖列名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID       <span class="type">uint</span>   <span class="string">`gorm:&quot;column:user_id&quot;`</span>  <span class="comment">// 将列名设为 `user_id`</span></span><br><span class="line">    UserName <span class="type">string</span> <span class="string">`gorm:&quot;column:name&quot;`</span>     <span class="comment">// 将列名设为 `name`</span></span><br><span class="line">    Age      <span class="type">int64</span>  <span class="string">`gorm:&quot;column:user_age&quot;`</span> <span class="comment">// 将列名设为 `user_age`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间戳追踪"><a href="#时间戳追踪" class="headerlink" title="时间戳追踪"></a>时间戳追踪</h4><h5 id="CreatedAt"><a href="#CreatedAt" class="headerlink" title="CreatedAt"></a>CreatedAt</h5><p>对于有  <code>CreatedAt</code>  字段的模型，创建记录时，如果该字段值为零值，则将该字段的值设为当前时间<br>可以通过将  <code>autoCreateTime</code>  标签置为  <code>false</code>  来禁用时间戳追踪</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    CreatedAt time.Time <span class="string">`gorm:&quot;autoCreateTime:false&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UpdatedAt"><a href="#UpdatedAt" class="headerlink" title="UpdatedAt"></a>UpdatedAt</h5><p>对于有  <code>UpdatedAt</code>  字段的模型，更新记录时，将该字段的值设为当前时间。创建记录时，如果该字段值为零值，则将该字段的值设为当前时间<br>可以通过将  <code>autoUpdateTime</code>  标签置为  <code>false</code>  来禁用时间戳追踪</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    UpdatedAt time.Time <span class="string">`gorm:&quot;autoUpdateTime:false&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体标记（tag）"><a href="#结构体标记（tag）" class="headerlink" title="结构体标记（tag）"></a>结构体标记（tag）</h3><p>声明 model 时，tag 是可选的，GORM 支持以下 tag：tag 名大小写不敏感，但建议使用  <code>camelCase</code>  风格，多个 tag 之间用 <code>;</code> 分格</p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>column</td><td>指定 db 列名</td></tr><tr><td>type</td><td>列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像  <code>varbinary(8)</code>  这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td>serializer</td><td>指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td>size</td><td>定义列数据类型的大小或长度，例如  <code>size: 256</code></td></tr><tr><td>primaryKey</td><td>将列定义为主键</td></tr><tr><td>unique</td><td>将列定义为唯一键</td></tr><tr><td>default</td><td>定义列的默认值</td></tr><tr><td>precision</td><td>指定列的精度</td></tr><tr><td>scale</td><td>指定列大小</td></tr><tr><td>not null</td><td>指定列为 NOT NULL</td></tr><tr><td>autoIncrement</td><td>指定列为自动增长</td></tr><tr><td>autoIncrementIncrement</td><td>自动步长，控制连续记录之间的间隔</td></tr><tr><td>embedded</td><td>嵌套字段</td></tr><tr><td>embeddedPrefix</td><td>嵌入字段的列名前缀</td></tr><tr><td>autoCreateTime</td><td>创建时追踪当前时间，对于  <code>int</code>  字段，它会追踪时间戳秒数，您可以使用  <code>nano</code>&#x2F;<code>milli</code>  来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td>autoUpdateTime</td><td>创建&#x2F;更新时追踪当前时间，对于  <code>int</code>  字段，它会追踪时间戳秒数，您可以使用  <code>nano</code>&#x2F;<code>milli</code>  来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td>index</td><td>根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看  <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a>  获取详情</td></tr><tr><td>uniqueIndex</td><td>与  <code>index</code>  相同，但创建的是唯一索引</td></tr><tr><td>check</td><td>创建检查约束，例如  <code>check:age &gt; 13</code>，查看  <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a>  获取详情</td></tr><tr><td>&lt;-</td><td>设置字段写入的权限， <code>&lt;-:create</code>  只创建、<code>&lt;-:update</code>  只更新、<code>&lt;-:false</code>  无写入权限、<code>&lt;-</code>  创建和更新权限</td></tr><tr><td>-&gt;</td><td>设置字段读的权限，<code>-&gt;:false</code>  无读权限</td></tr><tr><td>-</td><td>忽略该字段，<code>-</code>  表示无读写，<code>-:migration</code>  表示无迁移权限，<code>-:all</code>  表示无读写迁移权限</td></tr><tr><td>comment</td><td>迁移时为字段添加注释</td></tr></tbody></table><p>tag 使用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID       <span class="type">uint</span>   <span class="string">`gorm:&quot;autoIncrement&quot;`</span>                    <span class="comment">// 自增主键</span></span><br><span class="line">    Name     <span class="type">string</span> <span class="string">`gorm:&quot;size:10&quot;`</span>                          <span class="comment">// 大小为 10 个字符</span></span><br><span class="line">    Age      <span class="type">int</span>    <span class="string">`gorm:&quot;size:3; check:age &gt; 0&quot;`</span>            <span class="comment">// 大小为 3 位数，并且值要 &gt; 0</span></span><br><span class="line">    Email    <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(25); unique;&quot;`</span>        <span class="comment">// 类型为 varchar(25)，唯一</span></span><br><span class="line">    Password <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); default:123456&quot;`</span> <span class="comment">// 类型为 varchar(20)，默认值为 123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h3><p>对于一张数据表的每一条数据来说，都有自增主键，创建、更新与删除时间等比较通用的字段，因此 GORM 将其抽出来并定义了 gorm.Model，包含 <code>ID</code>, <code>CreatedAt</code>, <code>UpdatedAt</code>, <code>DeletedAt</code> 四个字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">uint</span> <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">    UpdatedAt time.Time</span><br><span class="line">    DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将它嵌入到你自己的模型中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    Age       <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于  </span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span>  </span><br><span class="line">  CreatedAt time.Time  </span><br><span class="line">  UpdatedAt time.Time  </span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span>  </span><br><span class="line">  Name      <span class="type">string</span>  </span><br><span class="line">  Age       <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">uint</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">    Sex  <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建记录-1"><a href="#创建记录-1" class="headerlink" title="创建记录"></a>创建记录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;XiMo&quot;</span>, Age: <span class="number">3</span>, Sex: <span class="string">&quot;male&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br><span class="line"></span><br><span class="line">user.ID             <span class="comment">// 返回插入数据的主键</span></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><ul><li>注：Create 传入的参数是指针而不是值</li><li>由于传递的是一个指针，执行完 Create 函数后 user 中就有了该记录相关的信息，比如创建的 ID</li></ul><p>我们还可以使用  <code>Create()</code>  创建多项记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">users := []User&#123;</span><br><span class="line">        &#123;Name: <span class="string">&quot;惜寞&quot;</span>, Age: <span class="number">3</span>, Sex: <span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">        &#123;Name: <span class="string">&quot;青鸟&quot;</span>, Age: <span class="number">18</span>, Sex: <span class="string">&quot;male&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result := db.Create(&amp;users) <span class="comment">// 传入切片的指针</span></span><br><span class="line"></span><br><span class="line">result.Error        <span class="comment">// 返回 error</span></span><br><span class="line">result.RowsAffected <span class="comment">// 返回插入记录的条数</span></span><br></pre></td></tr></table></figure><h3 id="用指定的字段创建记录"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录</h3><p>创建记录并为指定的字段分配值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Create(&amp;user)</span><br></pre></td></tr></table></figure><p>创建记录并忽略要省略的传递字段的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Create(&amp;user)</span><br></pre></td></tr></table></figure><h3 id="根据-Map-创建（不常用）"><a href="#根据-Map-创建（不常用）" class="headerlink" title="根据 Map 创建（不常用）"></a>根据 Map 创建（不常用）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;竹林&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">19</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 []map[string]interface&#123;&#125;&#123;&#125; 批量插入</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Create([]<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;知更鸟&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;桑葚&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">19</span>&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/create.html">更多</a></h3><h2 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h2><h3 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h3><ul><li>GORM 提供了  <code>First</code>、<code>Take</code>、<code>Last</code>  方法，以便从数据库中检索单个对象</li><li>提供了 <code>Find</code> 方法，以便从数据库中检索全部对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user User</span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询第一条记录</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键查询最后一条记录</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有的记录</span></span><br><span class="line">db.Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// 返回错误</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>当目标对象有一个主键值时，将使用主键构建查询条件</li><li>使用 <code>First</code> 等方法查询单个记录时，如果查询不到数据会返回 <code>ErrRecordNotFound</code> 错误</li><li>使用 <code>Find</code> 查询时，查询不到数据不会返回错误</li></ul></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="string-条件"><a href="#string-条件" class="headerlink" title="string 条件"></a>string 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有匹配的记录</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br></pre></td></tr></table></figure><h4 id="struct-Map-条件"><a href="#struct-Map-条件" class="headerlink" title="struct &amp; Map 条件"></a>struct &amp; Map 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice of primary keys</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><p>注意：使用 struct 查询时，GORM 将仅使用非零字段进行查询，这意味着如果你的字段的值为 <code>0</code> <code>&#39;&#39;</code> <code>false</code> 或其他零值时，将不会用于构建查询条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><p>要在查询条件中包含零值，可以使用 map，它会将所有键值作为查询条件包含在内，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="指定结构体查询字段"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a>指定结构体查询字段</h4><p>在使用 struct 进行搜索时，指定在查询条件中要使用结构体中的哪些特定值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br><span class="line"></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get by primary key if it were a non-integer type</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="Not-条件"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE NOT name = &quot;jinzhu&quot; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">18</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &lt;&gt; 18 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1;</span></span><br></pre></td></tr></table></figure><h4 id="Or-条件"><a href="#Or-条件" class="headerlink" title="Or 条件"></a>Or 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>, Age: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br></pre></td></tr></table></figure><h3 id="选择特定字段"><a href="#选择特定字段" class="headerlink" title="选择特定字段"></a>选择特定字段</h3><p><code>Select</code> 允许指定要从数据库中检索的字段，没有 <code>Select</code> GORM 将默认选择所有字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple orders</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br></pre></td></tr></table></figure><h3 id="Limit-Offset"><a href="#Limit-Offset" class="headerlink" title="Limit &amp; Offset"></a>Limit &amp; Offset</h3><p><code>Limit</code> 指定要检索的最大记录数，<code>Offset</code> 指定在开始返回记录之前要跳过的记录数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 表示检索所有记录</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br><span class="line"></span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span></span><br></pre></td></tr></table></figure><p>注意：<code>Offset</code> 不能单独使用，要和 <code>Limit</code> 要一起使用</p><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/query.html">更多</a></h3><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><ul><li>以查询到记录为基础</li><li>更新的记录不存在不会报 error</li></ul><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><p><code>Save</code>  会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><ul><li>如果保存值不包含主键（或者主键值在数据库中不存在），它将执行 Create 创建</li><li>主键存在则会执行更新保存所有字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Save(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;)</span></span><br><span class="line"></span><br><span class="line">db.Save(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</span></span><br></pre></td></tr></table></figure><h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><ul><li>需要通过 <code>Model</code> 函数来传入要更新的模型，主要是用来确定表名</li><li>当使用该方法并且其值具有主值时，主键将用于构建条件</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据条件更新</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据主键更新</span></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据条件和主键更新</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><h3 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h3><ul><li>如果要更新多个字段的话，可以使用 <code>Updates</code> 函数，该函数需要传入一个结构体或 map</li><li>在使用结构体时，不会更新零值，如果要更新的话，需要使用 map 或者更新选定字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用结构体更新</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 map 更新</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><p>如果要在更新时更新所选字段或忽略某些字段，可以使用 <code>select</code> 和 <code>omit</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select with Map</span></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select with Struct (select zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;new_name&#x27;, age=0 WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields but omit Role (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Omit(<span class="string">&quot;Role&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>如果我们没有指定主键值，GORM 将执行批量更新 <code>Model</code>，更新所有符合条件的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update with struct</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE role = &#x27;admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with map</span></span><br><span class="line">db.Model(User&#123;&#125;).Where(<span class="string">&quot;id IN ?&quot;</span>, []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>&#125;).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br></pre></td></tr></table></figure><h3 id="更多-2"><a href="#更多-2" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/update.html">更多</a></h3><h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><ul><li>以查询到记录为基础</li><li>删除的记录不存在不会报 error</li></ul><h3 id="删除一条记录"><a href="#删除一条记录" class="headerlink" title="删除一条记录"></a>删除一条记录</h3><p>删除一条记录时，删除对象需要指定主键，否则会触发批量删除<br><strong>注</strong>：删除的记录不存在不会报 error</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">// DELETE from users where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;user)</span><br><span class="line"><span class="comment">// DELETE from users where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><p>GORM 允许通过主键和内联条件来删除对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联条件</span></span><br><span class="line">db.Delete(&amp;user&#123;&#125;, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE from users where name LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE from users where name LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure><h4 id="阻止全局删除"><a href="#阻止全局删除" class="headerlink" title="阻止全局删除"></a>阻止全局删除</h4><p>当你试图执行不带任何条件的批量删除时，GORM 将不会运行并返回<code>ErrMissingWhereClause</code>  错误<br>如果一定要这么做，你必须添加一些条件，或者使用原生 SQL，或者开启<code>AllowGlobalUpdate</code>  模式，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;).Error</span><br><span class="line"><span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要主键值</span></span><br><span class="line">db.Delete(&amp;[]User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;&#125;).Error</span><br><span class="line"><span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;1 = 1&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE 1=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">db.Exec(<span class="string">&quot;DELETE FROM users&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br><span class="line"></span><br><span class="line">db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="literal">true</span>&#125;).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果你的模型包含了  <code>gorm.DeletedAt</code> 字段（该字段也被包含在 <code>gorm.Model</code> 中），那么该模型将会自动获得软删除的能力<br>当调用 <code>Delete</code> 时，GORM 并不会从数据库中删除该记录，而是将该记录的 <code>DeleteAt</code> 设置为当前时间，而后的一般查询方法将无法查找到此条记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user&#x27;s ID is `111`</span></span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软删除的记录在查询时会被忽略</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br></pre></td></tr></table></figure><p>如果你并不想嵌套 <code>gorm.Model</code>，你也可以像下方例子那样开启软删除特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Deleted gorm.DeletedAt</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找被软删除的记录"><a href="#查找被软删除的记录" class="headerlink" title="查找被软删除的记录"></a>查找被软删除的记录</h4><p>你可以使用 <code>Unscoped</code> 来查询到被软删除的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h4><p>你可以使用  <code>Unscoped</code> 来永久删除匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user&#x27;s ID is `10`</span></span><br><span class="line">db.Unscoped().Delete(&amp;user)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id=10;</span></span><br></pre></td></tr></table></figure><h3 id="更多-3"><a href="#更多-3" class="headerlink" title="更多"></a><a href="https://gorm.io/zh_CN/docs/delete.html">更多</a></h3>]]></content>
    
    
    <summary type="html">精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gorm（MySQL）</summary>
    
    
    
    <category term="Go Web" scheme="https://lonesome.cn/categories/go-web/"/>
    
    
    <category term="Go" scheme="https://lonesome.cn/tags/Go/"/>
    
    <category term="Gorm" scheme="https://lonesome.cn/tags/Gorm/"/>
    
  </entry>
  
  <entry>
    <title>Gin 简易教程</title>
    <link href="https://lonesome.cn/blog/go-web/gin-simple-tutorial/"/>
    <id>https://lonesome.cn/blog/go-web/gin-simple-tutorial/</id>
    <published>2023-08-13T01:30:00.000Z</published>
    <updated>2024-08-09T14:42:24.378Z</updated>
    
    <content type="html"><![CDATA[<p>精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gin 框架<br><a href="https://www.bilibili.com/video/BV1o841197jX/?share_source=copy_web&vd_source=220eb9848825e3e6c13414db26a32f45">B 站授课链接点击此处</a></p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="Go-内置的-net-http-包"><a href="#Go-内置的-net-http-包" class="headerlink" title="Go 内置的 net&#x2F;http 包"></a>Go 内置的 net&#x2F;http 包</h3><ul><li>Go 语言内置的 net&#x2F;http 包十分优秀，提供了 HTTP 客户端和服务端的实现</li><li>这里使用 Go 语言中的 net&#x2F;http 包来编写一个简单的接收 HTTP 请求的服务端（后端）示例，具体的代码如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 函数是需要我们自己实现的一个函数，它有两个规定的参数</span></span><br><span class="line"><span class="comment">// 第一个参数用于给前端的响应（Response）写入数据，响应想要返回什么，就往这个参数里面写什么</span></span><br><span class="line"><span class="comment">// 第二个参数用于获取前端发送的请求（Request）</span></span><br><span class="line"><span class="comment">// Web 开发的本质就是一个请求对应一个响应的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// fmt 包中的 Fprintln 函数是一个简单的可以往 w 里写东西的函数</span></span><br><span class="line">    <span class="comment">// 使用 Fprintln 函数将 &quot;Hello 精弘!&quot; 这句话以纯文本的形式写进 w 后返回给前端</span></span><br><span class="line">    fmt.Fprintln(w, <span class="string">&quot;Hello 精弘!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// HandleFunc 函数接受两个参数，第一个是路径，即前端请求的 URL，另一个是回调函数，用于处理前端发送的请求</span></span><br><span class="line">    <span class="comment">// HandleFunc 函数是一个设置路由的函数，它的作用是将前端对 /hello 路径的请求映射到 SayHello 函数</span></span><br><span class="line">    <span class="comment">// 当前端访问 /hello 路径的时候，就去执行 SayHello 的函数，往响应写入 &quot;Hello 精弘!&quot; 后返回给前端</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, SayHello)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListenAndServe 函数用于启动服务（Serve）并监听（Listen），接收两个参数</span></span><br><span class="line">    <span class="comment">// 第一个参数是 ip:port 格式的 string 参数，给 /hello 路径确定访问它的 ip 地址和端口号</span></span><br><span class="line">    <span class="comment">// 第二个参数指的是处理 HTTP 请求的处理器，填入nil表示使用默认的处理器</span></span><br><span class="line">    <span class="comment">// &quot;:8080&quot; 是简写，省略了 ip，默认为本机的所有 ip 如 127.0.0.1 就是其中一个，端口号指定为 8080</span></span><br><span class="line">    <span class="comment">// 在浏览器（前端）访问 127.0.0.1:8080/hello 就可以看到 SayHello 函数做出的响应了</span></span><br><span class="line">    <span class="comment">// 另外有一个 err 参数，如果端口被占用或者启动失败会返回错误，正常启动则返回 nil，即空（没有错误）</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理，如果错误不为 nil 则在终端打印错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;http server failed, err:%v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译运行后，在浏览器的地址栏中输入<code>127.0.0.1:8080/hello</code>后回车，就能够看到如下页面：<br><img src="https://img.lonesome.cn/blog/go-web/Nyw4d2eA.webp"></p><h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><ul><li>什么是 Web 框架<ul><li>用于进行 Web 开发的一套软件架构</li><li>为 Web 应用程序提供了基础的功能</li></ul></li><li>优点<ul><li>可以利用它更容易、方便、快速的做一些事情</li></ul></li><li>缺点<ul><li>作为一套体系，它会有一些自己的规定或约束，不可能百分百的满足你的需求</li></ul></li><li>为什么要用 Web 框架<ul><li>如果从零开始，利用 Go 的基础库去搭建，过程会很繁琐</li></ul></li><li>主要作用<ul><li>简化应用开发</li><li>在 Web 框架的基础上实现自己的业务逻辑</li><li>框架提供基础功能</li><li>只需要专注应用的业务逻辑</li></ul></li></ul><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Gin 是 Go 世界里最流行的一个 Web 框架，Github 上有 69K+ star，封装比较优雅，API 友好，源码注释比较明确，  是一个简单易用的轻量级框架，并且<a href="https://gin-gonic.com/zh-cn/">中文文档</a>齐全。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、先初始化当前文件夹（如果没有初始化）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init `name`</span><br></pre></td></tr></table></figure><p>2、下载并安装 Gin<br>go get 是 go 安装软件包的下载命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>将上节课的代码用 Gin 框架来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 gin 引入到代码中</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 函数是一个处理 HTTP 请求的回调函数</span></span><br><span class="line"><span class="comment">// 接受一个 gin 封装过的规定参数，即上下文对象 Context，它是所有请求处理器（处理请求的函数或方法）的入口参数</span></span><br><span class="line"><span class="comment">// Context 包含了 Request 和 ResponseWriter 两个参数，用于获取前端请求信息和返回响应</span></span><br><span class="line"><span class="comment">// 本质上是对于 Request 和 Response 的封装，提供了丰富的方法用于获取当前请求的上下文信息以及返回响应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHello</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 200 表示 HTTP 响应状态码（&lt;=&gt; http.StatusOK）</span></span><br><span class="line">    <span class="comment">// 使用 Context 的 String 函数将 &quot;Hello 精弘!&quot; 这句话以纯文本（字符串）的形式返回给前端</span></span><br><span class="line">    <span class="comment">// 实际上是对返回响应的封装</span></span><br><span class="line">    c.String(<span class="number">200</span>, <span class="string">&quot;Hello 精弘!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// gin.Default 函数会生成一个默认的 Engine（路由引擎）对象（集成了 Logger 和 Recovery 两个中间件，中间件后面的课会讲）</span></span><br><span class="line">    <span class="comment">// 变量名 r 是 router（路由）的一个简写</span></span><br><span class="line">    <span class="comment">// Engine 是 Gin 框架最重要的数据结构，它是 Gin 框架的入口，本质上是一个 Http Handler</span></span><br><span class="line">    <span class="comment">// 它是一个用于处理 HTTP 请求的对象，维护了一张路由表，将不同的 HTTP 请求路径映射到不同的处理函数上</span></span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r.GET 函数接受两个参数，一个是路径，即前端请求的 URL，另一个是回调函数，用于处理前端发送的请求</span></span><br><span class="line">    <span class="comment">// r.GET 函数将 /hello 路径添加到了 r 的路由表中，将对 /hello 路径的 GET 请求映射到 SayHello 函数上</span></span><br><span class="line">    <span class="comment">// 表示前端给后端的 /hello 路由发送一个 HTTP 的 GET 请求时</span></span><br><span class="line">    <span class="comment">// 后端会执行后面的 SayHello 函数，对前端的请求做出一个响应，给前端返回一个 &quot;Hello 精弘!&quot; 的字符串</span></span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, SayHello)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务并监听,只接受一个 ip:port 格式的 string 参数，表示服务运行的 ip 地址和端口号</span></span><br><span class="line">    <span class="comment">// &quot;:8080&quot; 是简写，省略了 ip，表示监听本地所有 ip （如 127.0.0.1）的 8080 端口，接收并处理 HTTP 请求</span></span><br><span class="line">    <span class="comment">// 在浏览器（前端）访问 127.0.0.1:8080/hello 就可以看到 SayHello 函数做出的响应</span></span><br><span class="line">    <span class="comment">// 等价于 r.Run()，将 port 端口也省略，默认为 8080 端口</span></span><br><span class="line">    err := r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误处理，如果错误不为 nil 则在终端打印错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;http server failed, err:%v\n&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码编译运行后，在浏览器的地址栏中输入<code>127.0.0.1:8080/hello</code>后回车，就能够看到和上节一样的页面：<br><img src="https://img.lonesome.cn/blog/go-web/Nyw4d2eA.webp"></p><ul><li><a href="https://www.runoob.com/http/http-status-codes.html">HTTP 状态码</a><ul><li>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求，当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含 HTTP 状态码的信息头（server header）用以响应浏览器的请求</li><li>常见的 HTTP 状态码<ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它 URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul></li></ul></li></ul><h2 id="响应返回-JSON"><a href="#响应返回-JSON" class="headerlink" title="响应返回 JSON"></a>响应返回 JSON</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.String(<span class="number">200</span>, <span class="string">&quot;Hello 精弘!&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>上节课我们讲的是 c.String 给前端返回一个字符串，但在实际的前后端分离的开发过程中，直接使用 string 进行前后端数据传输并不便利，所以我们往往会选择使用 JSON 的数据格式进行前后端的数据传输</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul><li>JSON 数据类型<ul><li>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式，用它可以来表示各种各样复杂的数据，如对象，数组，集合，以及集合的集合等数据</li><li>JSON 实际上就是一串字符串，只不过元素会使用特定的符号标注。 {} 双括号表示对象，[] 中括号表示数组，”” 双引号内是属性或值，: 冒号表示后者是前者的值(这个值可以是字符串、数字、也可以是另一个数组或对象)。</li></ul></li><li>一些常见的 JSON 格式<ul><li>一个 JSON 对象——JSONObject<ul><li><code>&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3&#125;</code></li><li><code>&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3，&quot;address&quot;:&#123;&quot;city&quot;:HangZhou&quot;, &quot;country&quot;:&quot;China&quot;&#125;&#125;</code></li></ul></li><li>一个 JSON 数组——JSONArray<ul><li><code>[&quot;XiMo&quot;, &quot;惜寞&quot;]</code></li><li><code>[&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3&#125;, &#123;&quot;name&quot;:&quot;惜寞&quot;, &quot;age&quot;:4&#125;]</code></li><li><code>[&#123;&quot;name&quot;:&quot;XiMo&quot;, &quot;age&quot;:3, &quot;address&quot;:&#123;&quot;city&quot;:&quot;HangZhou&quot;, &quot;country&quot;:&quot;China&quot;&#125;&#125;, &#123;&quot;name&quot;:&quot;惜寞&quot;, &quot;age&quot;: 4, &quot;address&quot;:&#123;&quot;city&quot;:&quot;JiaXing&quot;, &quot;country&quot;:&quot;China&quot;&#125;&#125;]</code></li></ul></li><li>可以通过<a href="http://www.esjson.com/jsonviewer.html">可视化</a>将 JSON 数据类型格式化来查看，结构清晰，并且内容相同，字符串形式只是将空格回车给去掉了而已</li><li>当然，数组可以包含对象，在对象中也可以包含数组</li></ul></li><li>为什么普遍选择 JSON 用于前后端数据的传输<ul><li>采用完全独立于任何程序语言的文本格式，使 JSON 成为理想的数据交换语言</li><li>易于人阅读和编写，键值对类型的数据结构具有良好的可读性</li><li>数据格式比较简单, 格式都是压缩的，占用带宽小，能有效地提升网络传输效率</li><li>易于解析，前端可以很方便的进行 JSON 数据的读取</li><li>JSON 格式能够直接为后端代码使用，大大简化了前后端的代码开发量，但是完成的任务不变，且易于维护</li></ul></li></ul><p>和返回 string 一样，Gin 在 Context 里面也给我们封装了返回 JSON 的方法，下面是一个简单的 Gin 返回 JSON 的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Json</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.使用结构体，可以灵活利用 tag 对字段进行&quot;换名&quot;</span></span><br><span class="line">    <span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name     <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">        Age      <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">        Password <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 忽略该字段</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user := UserInfo&#123;</span><br><span class="line">        Name:     <span class="string">&quot;XiMo&quot;</span>,</span><br><span class="line">        Age:      <span class="number">3</span>,</span><br><span class="line">        Password: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.JSON 实际上是将结构体和 map 类型的变量进行序列化（将对象转换为JSON格式的字符串的过程）</span></span><br><span class="line">    <span class="comment">// 注意 UserInfo.Name 在序列化中变成了 &quot;username&quot;，UserInfo.Age 变成了 &quot;age&quot;</span></span><br><span class="line">    <span class="comment">// &quot;-&quot; 表示忽略该字段，所以 UserInfo.Password 在序列化的时候会被忽略</span></span><br><span class="line">    <span class="comment">// 响应将返回：&#123;&quot;username&quot;: &quot;XiMo&quot;, &quot;age&quot;: 3&#125;</span></span><br><span class="line">    c.JSON(<span class="number">200</span>, user)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2.使用 map</span></span><br><span class="line">    <span class="comment">// userMap := map[string]any&#123;</span></span><br><span class="line">    <span class="comment">//     &quot;name&quot;: &quot;XiMo&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;age&quot;:  3,</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.JSON(200, userMap)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 3.使用 gin.H</span></span><br><span class="line">    <span class="comment">// // gin.H 实际上是 map[string]any 的一种快捷方式</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//     &quot;name&quot;: &quot;XiMo&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;age&quot;:  3,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/json&quot;</span>, Json)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实除了 JSON 和 string 类型的返回，Gin 还给我们提供了响应 XML、YAML、HTML 等的方式，但由于使用较少，所以这里不多涉及，感兴趣的可以自行查阅</p><h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><h3 id="Query-查询参数"><a href="#Query-查询参数" class="headerlink" title="Query 查询参数"></a>Query 查询参数</h3><ul><li>Query 参数是在 URL 中的一部分，用于向服务器发送额外的数据，由键值对组成，以 <code>?</code> 为起始符号，键值对之间使用 <code>&amp;</code> 分隔，例如：<code>/user/search?name=XiMo&amp;age=3</code></li><li>Query 参数常用于 HTTP GET 请求</li><li>常见的地方有搜索（浏览器等等）<br><img src="https://img.lonesome.cn/blog/go-web/fksrMZry.webp"></li></ul><p>Gin 里面给我们封装的 Context 参数提供了丰富的方法帮我们获取 Query 参数</p><table><thead><tr><th>Query 方法</th><th>说明</th></tr></thead><tbody><tr><td>Query</td><td>获取 key 对应的值，不存在返回空字符串</td></tr><tr><td>DefaultQuery</td><td>key 不存在时返回一个默认值</td></tr><tr><td>GetQuery</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryArray</td><td>获取 key 对应的值，值是一个字符串数组，不存在返回空字符串数组</td></tr><tr><td>GetQueryArray</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，不存在返回空</td></tr><tr><td>GetQueryMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，并且返回 bool 标识，标识成功或者失败</td></tr></tbody></table><p>需要注意的是通过 Query 获取到的参数都是 string 类型</p><p>下面是一些代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 访问 /query?name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// Query 获取key对应的值，不存在返回空字符串</span></span><br><span class="line">    nameQuery := c.Query(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    ageQuery := c.Query(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    sexQuery := c.Query(<span class="string">&quot;sex&quot;</span>)</span><br><span class="line">    organizationQuery := c.Query(<span class="string">&quot;organization&quot;</span>)</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;nameQuery&quot;</span>:         nameQuery,</span><br><span class="line">        <span class="string">&quot;ageQuery&quot;</span>:          ageQuery,</span><br><span class="line">        <span class="string">&quot;sexQuery&quot;</span>:          sexQuery,</span><br><span class="line">        <span class="string">&quot;organizationQuery&quot;</span>: organizationQuery,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// // DefaultQuery key不存在时返回一个默认值</span></span><br><span class="line">    <span class="comment">// organizationDefaultQuery := c.DefaultQuery(&quot;organization&quot;, &quot;精弘网络&quot;)</span></span><br><span class="line">    <span class="comment">// sexDefaultQuery := c.DefaultQuery(&quot;sex&quot;, &quot;male&quot;)</span></span><br><span class="line">    <span class="comment">// nameDefaultQuery := c.DefaultQuery(&quot;name&quot;, &quot;惜寞&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;organizationDefaultQuery&quot;: organizationDefaultQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;sexDefaultQuery&quot;:          sexDefaultQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;nameDefaultQuery&quot;:         nameDefaultQuery,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// // GetQuery 获取key对应的值，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// nameGetQuery, nameExist := c.GetQuery(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetQuery, sexExist := c.GetQuery(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetQuery, orgaorganizationExist := c.GetQuery(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetQuery&quot;:          nameGetQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:             nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetQuery&quot;:           sexGetQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:              sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetQuery&quot;:  organizationGetQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;: orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// // QueryArray</span></span><br><span class="line">    <span class="comment">// hobbyQuery := c.Query(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// hobbyQueryArray := c.QueryArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// nameQueryArray := c.QueryArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexQueryArray := c.QueryArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationQueryArray := c.QueryArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyQuery&quot;:             hobbyQuery,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyQueryArray&quot;:        hobbyQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;nameQueryArray&quot;:         nameQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexQueryArray&quot;:          sexQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationQueryArray&quot;: organizationQueryArray,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// // GetQueryArray</span></span><br><span class="line">    <span class="comment">// hobbyGetQueryArray, hobbyExist := c.GetQueryArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// nameGetQueryArray, nameExist := c.GetQueryArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetQueryArray, sexExist := c.GetQueryArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetQueryArray, orgaorganizationExist := c.GetQueryArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyGetQueryArray&quot;:        hobbyGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyExist&quot;:                hobbyExist,</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetQueryArray: &quot;:       nameGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:                 nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetQueryArray&quot;:          sexGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:                  sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetQueryArray&quot;: organizationGetQueryArray,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;:     orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// // QueryMap</span></span><br><span class="line">    <span class="comment">// userQueryMap := c.QueryMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminQueryMap := c.QueryMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userQueryMap&quot;:  userQueryMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminQueryMap&quot;: adminQueryMap,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 访问 /query?user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// // GetQueryMap</span></span><br><span class="line">    <span class="comment">// userGetQueryMap, userExist := c.GetQueryMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminGetQueryMap, adminExist := c.GetQueryMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userGetQueryMap&quot;:  userGetQueryMap,</span></span><br><span class="line">    <span class="comment">//  &quot;userExist&quot;:        userExist,</span></span><br><span class="line">    <span class="comment">//  &quot;adminGetQueryMap&quot;: adminGetQueryMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminExist&quot;:       adminExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/query&quot;</span>, Query)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Param-动态参数"><a href="#Param-动态参数" class="headerlink" title="Param 动态参数"></a>Param 动态参数</h3><ul><li>Param 参数获取到的数据类型也是 string 类型</li><li>路由形式一般写成 <code>/user/:name/:age</code>，这里的 <code>:</code> 表示后面的参数是一个占位符</li><li>请求的参数可以通过 URL 路径传递，<code>name</code> 和 <code>age</code> 可以通过访问 <code>/user/XiMo/3</code> 这个路由去获取 <code>XiMo</code> 和 <code>3</code> ，访问 <code>/user/惜寞/4</code> 可以获取 <code>惜寞</code> 和 <code>4</code></li></ul><p>Gin 给我们提供了 Param 方法去获取这些参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意会匹配 /param/XiMo 但不会匹配 /param/ 或者 /param</span></span><br><span class="line">    r.GET(<span class="string">&quot;/param/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 访问 /param/XiMo</span></span><br><span class="line">        name := c.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在会返回空字符串</span></span><br><span class="line">        age := c.Param(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: name,</span><br><span class="line">            <span class="string">&quot;age&quot;</span>:  age,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostForm-表单参数"><a href="#PostForm-表单参数" class="headerlink" title="PostForm 表单参数"></a>PostForm 表单参数</h3><ul><li>和 Query 很像，不同之处在于数据不通过 URL 来传递，而是处于请求的主体当中</li><li>表单参数常用于 POST 请求中</li></ul><p>Gin 提供的 PostForm 函数与 Query 基本上一一对应的，具体情况见下表：</p><table><thead><tr><th>Query 方法</th><th>PostForm 方法</th><th>说明</th></tr></thead><tbody><tr><td>Query</td><td>PostForm</td><td>获取 key 对应的值，不存在返回空字符串</td></tr><tr><td>DefaultQuery</td><td>DefaultPostForm</td><td>key 不存在时返回一个默认值</td></tr><tr><td>GetQuery</td><td>GetPostForm</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryArray</td><td>PostFormArray</td><td>获取 key 对应的值，值是一个字符串数组，不存在返回空字符串数组</td></tr><tr><td>GetQueryArray</td><td>GetPostFormArray</td><td>获取 key 对应的值，并且返回 bool 标识，标识成功或者失败</td></tr><tr><td>QueryMap</td><td>PostFormMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，不存在返回空</td></tr><tr><td>GetQueryMap</td><td>GetPostFomMap</td><td>获取 key 对应的值，值是一个字符串 map[string]string，并且返回 bool 标识，标识成功或者失败</td></tr></tbody></table><p>下面是一些代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostForm</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// PostForm 获取key对应的值，不存在返回空字符串</span></span><br><span class="line">    <span class="comment">// name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    namePostForm := c.PostForm(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    agePostForm := c.PostForm(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    sexPostForm := c.PostForm(<span class="string">&quot;sex&quot;</span>)</span><br><span class="line">    organizationPostForm := c.PostForm(<span class="string">&quot;organization&quot;</span>)</span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;namePostForm&quot;</span>:         namePostForm,</span><br><span class="line">        <span class="string">&quot;agePostForm&quot;</span>:          agePostForm,</span><br><span class="line">        <span class="string">&quot;sexPostForm&quot;</span>:          sexPostForm,</span><br><span class="line">        <span class="string">&quot;organizationPostForm&quot;</span>: organizationPostForm,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // DefaultPostForm key不存在时返回一个默认值</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// organizationDefaultPostForm := c.DefaultPostForm(&quot;organization&quot;, &quot;精弘网络&quot;)</span></span><br><span class="line">    <span class="comment">// sexDefaultPostForm := c.DefaultPostForm(&quot;sex&quot;, &quot;male&quot;)</span></span><br><span class="line">    <span class="comment">// nameDefaultPostForm := c.DefaultPostForm(&quot;name&quot;, &quot;惜寞&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;organizationPostForm&quot;:        organizationPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationDefaultPostForm&quot;: organizationDefaultPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;sexPostForm&quot;:                 sexPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;sexDefaultPostForm&quot;:          sexDefaultPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;namePostForm&quot;:                namePostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;nameDefaultPostForm&quot;:         nameDefaultPostForm,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // GetPostForm 获取key对应的值，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=</span></span><br><span class="line">    <span class="comment">// nameGetPostForm, nameExist := c.GetPostForm(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetPostForm, sexExist := c.GetPostForm(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetPostForm, orgaorganizationExist := c.GetPostForm(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetPostForm&quot;:         nameGetPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:               nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetPostForm&quot;:          sexGetPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:                sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetPostForm&quot;: organizationGetPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;:   orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // PostFormArray 获取key对应的值，值是一个字符串数组，不存在返回空字符串数组</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// hobbyPostForm := c.PostForm(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// hobbyPostFormArray := c.PostFormArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// namePostFormArray := c.PostFormArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexPostFormArray := c.PostFormArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationPostFormArray := c.PostFormArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyPostForm&quot;:             hobbyPostForm,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyPostFormArray&quot;:        hobbyPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;namePostFormArray&quot;:         namePostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexPostFormArray&quot;:          sexPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationPostFormArray&quot;: organizationPostFormArray,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // GetPostFormArray 获取key对应的值，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// // name=ximo&amp;age=3&amp;sex=&amp;hobby=code&amp;hobby=sleep&amp;hobby=</span></span><br><span class="line">    <span class="comment">// hobbyGetPostFormArray, hobbyExist := c.GetPostFormArray(&quot;hobby&quot;)</span></span><br><span class="line">    <span class="comment">// nameGetPostFormArray, nameExist := c.GetPostFormArray(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">// sexGetPostFormArray, sexExist := c.GetPostFormArray(&quot;sex&quot;)</span></span><br><span class="line">    <span class="comment">// organizationGetPostFormArray, orgaorganizationExist := c.GetPostFormArray(&quot;organization&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyGetPostFormArray&quot;:        hobbyGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;hobbyExist&quot;:                   hobbyExist,</span></span><br><span class="line">    <span class="comment">//  &quot;nameGetPostFormArray: &quot;:       nameGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;nameExist&quot;:                    nameExist,</span></span><br><span class="line">    <span class="comment">//  &quot;sexGetPostFormArray&quot;:          sexGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;sexExist&quot;:                     sexExist,</span></span><br><span class="line">    <span class="comment">//  &quot;organizationGetPostFormArray&quot;: organizationGetPostFormArray,</span></span><br><span class="line">    <span class="comment">//  &quot;orgaorganizationExist&quot;:        orgaorganizationExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // PostFormMap 获取key对应的值，值是一个字符串map[string]string，不存在返回空</span></span><br><span class="line">    <span class="comment">// // user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// userPostFormMap := c.PostFormMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminPostFormMap := c.PostFormMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userPostFormMap&quot;:  userPostFormMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminPostFormMap&quot;: adminPostFormMap,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // GetPostFormMap 获取key对应的值，值是一个字符串map[string]string，并且返回bool标识，标识成功或者失败</span></span><br><span class="line">    <span class="comment">// // user[name]=ximo&amp;user[age]=3&amp;user[sex]=&amp;user[hobby]=code&amp;user[hobby]=sleep</span></span><br><span class="line">    <span class="comment">// userGetPostFormMap, userExist := c.GetPostFormMap(&quot;user&quot;)</span></span><br><span class="line">    <span class="comment">// adminGetPostFormMap, adminExist := c.GetPostFormMap(&quot;admin&quot;)</span></span><br><span class="line">    <span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line">    <span class="comment">//  &quot;userGetPostFormMap&quot;:  userGetPostFormMap,</span></span><br><span class="line">    <span class="comment">//  &quot;userExist&quot;:           userExist,</span></span><br><span class="line">    <span class="comment">//  &quot;adminGetPostFormMap&quot;: adminGetPostFormMap,</span></span><br><span class="line">    <span class="comment">//  &quot;adminExist&quot;:          adminExist,</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/post-form&quot;</span>, PostForm)</span><br><span class="line"></span><br><span class="line">    r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GetRawData-原始参数"><a href="#GetRawData-原始参数" class="headerlink" title="GetRawData 原始参数"></a>GetRawData 原始参数</h3><p>我们如果想去获取前端传来的 JSON 数据类型就需要用到这个方法，但是实际上 Gin 帮我们封装了一种更简便的方式（参数绑定里的 ShouldBindJSON 方法），所以这个方法我们很少会用到，因此不专门去讲，有兴趣了解的可以看看</p><p>利用 GetRawData 方法可以获取请求体中 body 的内容，我们也是通过这种方式来获取前端给我们传来的 JSON 数据，但实际上通过这个方法我们不仅仅是可以获取 JSON ，还可以获取很多别的一些数据类型像是 xml、html 等等，这里我们仅仅是用获取 JSON 数据为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Raw</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// GetRawData 实际上是去获取 request.body 中的内容</span></span><br><span class="line">    <span class="comment">// 它返回两个参数，一个是获取到的 []byte 类型的 body 数据，另一个是 error 类型</span></span><br><span class="line">    <span class="comment">// 这里忽略了 error 的处理</span></span><br><span class="line">    data, _ := c.GetRawData()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印 data 可以看到传过来的原始数据</span></span><br><span class="line">    fmt.Println(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 []byte 转成 string 类型可以看它实际传过来的内容</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：下面是对 JSON 数据类型的处理</span></span><br><span class="line">    <span class="comment">// 我们可以通过 json 包里的 Unmarshal 来对 JSON 数据类型进行反序列化</span></span><br><span class="line">    <span class="comment">// 就是我前几节课所说的用 JSON 中的数据去给结构体和 map 类型变量赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.结构体，tag 在反序列化的时候依旧可用，会根据 tag 将对应的值赋给对应的键</span></span><br><span class="line">    <span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">        Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">        Sex  <span class="type">string</span> <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> userStruct UserInfo</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 反序列化，会返回一个 error，这里忽略了对其的处理</span></span><br><span class="line">    _ = json.Unmarshal(data, &amp;userStruct)</span><br><span class="line"></span><br><span class="line">    c.JSON(<span class="number">200</span>, userStruct)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 2.map</span></span><br><span class="line">    <span class="comment">// var userMap map[string]interface&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _ = json.Unmarshal(data, &amp;userMap)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //获取 JSON 中的 key，注意使用 [&quot;key&quot;] 获取</span></span><br><span class="line">    <span class="comment">// // name := userMap[&quot;name&quot;]</span></span><br><span class="line">    <span class="comment">// // age := userMap[&quot;age&quot;]</span></span><br><span class="line">    <span class="comment">// // sex := userMap[&quot;sex&quot;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c.JSON(200, userMap)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/raw&quot;</span>, Raw)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的代码运行起来，然后可以利用 apifox 新建一个快捷请求去查看效果：<br><img src="https://img.lonesome.cn/blog/go-web/IsmjGIUz.webp"></p><p>发送请求后的结果如下：<br><img src="https://img.lonesome.cn/blog/go-web/1yu5vlul.webp"></p><p>说明我们成功的收到了前端传来的 JSON 参数并且解析到了我们的结构体和 map 上，并将其响应返回给了前端</p><h3 id="Bind-参数绑定"><a href="#Bind-参数绑定" class="headerlink" title="Bind 参数绑定"></a>Bind 参数绑定</h3><p>下面是 Gin 的官方文档给出的介绍：<br>Gin 提供了两类绑定方法：</p><ul><li><strong>Type</strong> - Must bind<ul><li><strong>Methods</strong> - <code>Bind</code>, <code>BindJSON</code>, <code>BindXML</code>, <code>BindQuery</code>, <code>BindYAML</code></li><li><strong>Behavior</strong> - 这些方法属于  <code>MustBindWith</code>  的具体调用。 如果发生绑定错误，则请求终止，并触发  <code>c.AbortWithError(400, err).SetType(ErrorTypeBind)</code>。响应状态码被设置为 400 并且  <code>Content-Type</code>  被设置为  <code>text/plain; charset=utf-8</code>。 如果您在此之后尝试设置响应状态码，Gin 会输出日志  <code>[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422</code>。 如果您希望更好地控制绑定，考虑使用  <code>ShouldBind</code>  等效方法。</li></ul></li><li><strong>Type</strong> - Should bind<ul><li><strong>Methods</strong> - <code>ShouldBind</code>, <code>ShouldBindJSON</code>, <code>ShouldBindXML</code>, <code>ShouldBindQuery</code>, <code>ShouldBindYAML</code></li><li><strong>Behavior</strong> - 这些方法属于  <code>ShouldBindWith</code>  的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。</li></ul></li></ul><p>使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用  <code>MustBindWith</code>  或  <code>ShouldBindWith</code>。</p><p>你也可以指定必须绑定的字段。 如果一个字段的 tag 加上了  <code>binding:&quot;required&quot;</code>，但绑定时是空值, Gin 会报错。</p><ul><li>我们一般不会使用 Must Bind 相关的绑定方法，因为绑定一旦发生错误，就会修改你的响应状态码，不便于你对绑定状态的控制</li><li>通常使用 Should Bind 方法，发生绑定错误可以自由进行处理</li></ul><p>简单来说：<br>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的 <code>Content-Type</code> 识别请求数据类型并利用反射机制自动提取请求中 <code>Query</code>、<code>Param</code>、<code>Form</code>、<code>JSON</code> 等参数到结构体中。 下面的示例代码演示了 <code>ShouldBind()</code> 强大的功能，它能够基于请求自动提取相应类型的数据，并把值绑定到指定的结构体对象中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`form:&quot;name_form&quot; uri:&quot;name_uri&quot; json:&quot;name_form&quot; binding:&quot;required&quot;`</span> <span class="comment">// binding:&quot;required&quot; tag 表示该属性值不能为空</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`form:&quot;age_form&quot; uri:&quot;age_uri&quot; json:&quot;age_form&quot;`</span></span><br><span class="line">    Sex  <span class="type">string</span> <span class="string">`form:&quot;sex_form&quot; uri:&quot;sex&quot; json:&quot;sex_form&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag form</span></span><br><span class="line">    <span class="comment">// 绑定 Query 示例</span></span><br><span class="line">    <span class="comment">// 1. /query?name_form=ximo&amp;age_form=3&amp;sex_form=male 正常响应</span></span><br><span class="line">    <span class="comment">// 2. /query?name_form=ximo&amp;age_form=3&amp;sex_form= 或 /query?name_form=ximo&amp;age_form=3 正常响应</span></span><br><span class="line">    <span class="comment">// 3. /query?age_form=3&amp;sex_form=male 或 /query?name_form=&amp;age_form=3&amp;sex_form=male 返回 error，binding:&quot;required&quot; tag 表示 Name 属性值不能为空</span></span><br><span class="line">    r.GET(<span class="string">&quot;/query&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据请求的 Content-type 自动识别请求数据类型并利用反射机制自动提取请求中的参数到结构体中</span></span><br><span class="line">        <span class="comment">// 会返回一个 error 参数</span></span><br><span class="line">        err := c.ShouldBind(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag uri</span></span><br><span class="line">    <span class="comment">// 绑定 Param 的示例 /param/ximo/3/male</span></span><br><span class="line">    r.POST(<span class="string">&quot;/param/:name_uri/:age_uri/:sex_uri&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Param 比较特殊，不能直接通过 ShouldBind 绑定</span></span><br><span class="line">        err := c.ShouldBindUri(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag json</span></span><br><span class="line">    <span class="comment">// 绑定 JSON 的示例</span></span><br><span class="line">    <span class="comment">// 1. &#123;&quot;user_json&quot;: &quot;ximo&quot;, &quot;age_json&quot;: 3, &quot;sex_json&quot;: male&#125; 正常响应</span></span><br><span class="line">    <span class="comment">// 2. &#123;&quot;user_json&quot;: &quot;ximo&quot;, &quot;age_json&quot;: 3&#125; 或 &#123;&quot;user_json&quot;: &quot;ximo&quot;, &quot;age_json&quot;: 3, &quot;sex_json&quot;:&quot;&quot;&#125; 正常响应</span></span><br><span class="line">    <span class="comment">// 3. &#123;&quot;age_json&quot;: 3, &quot;sex_json&quot;: male&#125; 或 &#123;&quot;user_json&quot;: &quot;&quot;, &quot;age_json&quot;: 3, &quot;sex_json&quot;: male&#125;返回 error，binding:&quot;required&quot; tag 表示 Name 属性值不能为空</span></span><br><span class="line">    r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        err := c.ShouldBind(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应反射 tag form（和 Query 相同）</span></span><br><span class="line">    <span class="comment">// 绑定 form 表单示例</span></span><br><span class="line">    <span class="comment">// 1. name_form=ximo&amp;age_form=3&amp;sex_form=male 正常响应</span></span><br><span class="line">    <span class="comment">// 2. name_form=ximo&amp;age_form=3&amp;sex_form= 或 name_form=ximo&amp;age_form=3 正常响应</span></span><br><span class="line">    <span class="comment">// 3. age_form=3&amp;sex_form=male 或 name_form=&amp;age_form=3&amp;sex_form=male 返回 error，binding:&quot;required&quot; tag 表示 Name 属性值不能为空</span></span><br><span class="line">    r.POST(<span class="string">&quot;/post-form&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        err := c.ShouldBind(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>Should Bind</code> 会按照下面的顺序解析请求中的数据完成绑定：</p><ul><li><ol><li>如果是  <code>GET</code>  请求，只使用  <code>Form</code>  绑定（<code>query</code>）</li></ol></li><li><ol start="2"><li>其他请求，根据  <code>Content-Type</code>  自动识别对应类型，匹配不上会默认使用  <code>Form</code>（<code>form-data</code>）</li></ol></li></ul></li><li><p>如果你明确知道要绑定什么数据类型，推荐直接使用 <code>ShouldBindWith</code></p></li><li><p>比如你明确接收到的是一个 JSON 数据，就可以使用</p><ul><li><code>ShouldBindWith(&amp;user, binding.JSON)</code></li><li>或者 <code>ShouldBindJSON(&amp;user)</code> （实际上是上面方法的缩写，通常写这个）</li></ul></li></ul><p>我们主要知道如何用 ShouldBindJSON 去获取前端发送过来的 JSON 数据就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot; binding:&quot;required&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    Sex  <span class="type">string</span> <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> user UserInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定 JSON，接收前端发送过来的 JSON 数据</span></span><br><span class="line">        err := c.ShouldBindJSON(&amp;user)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            c.JSON(http.StatusBadRequest, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;error&quot;</span>: err.Error(),</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>在 Gin 中，路由是指将 HTTP 请求映射到相应的处理函数的机制</p><h3 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br><span class="line">r.PUT(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br><span class="line">r.DELETE(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>Any</code> 方法<ul><li>可以匹配所有 HTTP 请求</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.Any(<span class="string">&quot;/path&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>NoRoute</code>  方法<ul><li>用于处理找不到路由的情况，即当没有匹配到任何定义的路由时执行的处理函数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>NoMethod</code> 方法<ul><li>用于处理请求的 HTTP 方法不被允许的情况，即当请求的 HTTP 方法与路由定义的方法不匹配时执行的处理函数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.NoMethod(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><h3 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/path/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;) <span class="comment">// 匹配带有 id 参数的GET请求</span></span><br><span class="line">r.GET(<span class="string">&quot;/path/*action&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;) <span class="comment">// 匹配任意路径的 GET 请求，只要是以 /path 开头</span></span><br></pre></td></tr></table></figure><p>通过参数路由，可以根据不同的参数值生成不同的 URL，实现对不同资源的访问。</p><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>我们可以将拥有共同 URL 前缀的路由划分为一个路由组，习惯性一对 <code>&#123;&#125;</code> 包裹同组的路由，这只是为了看着清晰，用不用 <code>&#123;&#125;</code> 包裹功能上没什么区别<br>通常将路由分组用在划分业务逻辑或划分 API 版本时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        user.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">admin := r.Group(<span class="string">&quot;/admin&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        admin.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        admin.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        admin.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>路由组支持嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 路由组嵌套</span></span><br><span class="line">        login := user.Group(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            login.POST(<span class="string">&quot;/email&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">            login.POST(<span class="string">&quot;/phone&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">            login.POST(<span class="string">&quot;/password&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实可以类比成文件夹</p><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>REST 与技术无关，代表的是一种软件架构风格，REST 是 Representational State Transfer 的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p><p>简单来说，REST 的含义就是客户端（前端）与 Web 服务器（后端）之间进行交互的时候，使用 HTTP 协议中的 4 个请求方法代表不同的动作。</p><ul><li><code>GET</code> 用来获取资源</li><li><code>POST</code> 用来新建资源</li><li><code>PUT</code> 用来更新资源</li><li><code>DELETE</code> 用来删除资源</li></ul><p>只要 API 程序遵循了 REST 风格，那就可以称其为 RESTful API。目前在前后端分离的架构中，前后端基本都是通过 RESTful API 来进行交互。</p><p>例如，我们现在要编写一个管理外卖订单的系统，对一个订单进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们 Web 服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;order</td><td>查询订单信息</td></tr><tr><td>POST</td><td>&#x2F;create_order</td><td>创建订单</td></tr><tr><td>POST</td><td>&#x2F;update_order</td><td>更新订单信息</td></tr><tr><td>POST</td><td>&#x2F;delete_order</td><td>删除订单</td></tr></tbody></table><p>同样的需求我们按照 RESTful API 设计如下：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>&#x2F;order</td><td>查询订单信息</td></tr><tr><td>POST</td><td>&#x2F;order</td><td>创建订单</td></tr><tr><td>PUT</td><td>&#x2F;order</td><td>更新订单信息</td></tr><tr><td>DELETE</td><td>&#x2F;order</td><td>删除订单</td></tr></tbody></table><p>Gin 框架支持开发 RESTful API 的开发。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 对订单进行增删改查的操作</span></span><br><span class="line">    <span class="comment">// 可能的写法</span></span><br><span class="line">    r.GET(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/create_order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/update_order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/delete_order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// RESRful API 风格</span></span><br><span class="line">    r.GET(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    r.POST(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    r.PUT(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    r.DELETE(<span class="string">&quot;/order&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Gin 框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如<strong>登录认证、权限校验、数据分页、记录日志、耗时统计</strong>等。<br>中间件本质上是一个 handler，可以作用在单路由、路由组和全局的 Engine。</p><h3 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h3><ul><li>Gin 中的中间件必须是一个 <code>gin.HandlerFunc</code> 类型，其实和我们的处理函数是同样的类型。</li><li>下面其实就是一个中间件，只不过没有什么实际的作用：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;这是一个中间件&quot;</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 中间件也可以返回响应</span></span><br><span class="line">    c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;中间件&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以把它注册到我们的路由当中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 m1 作为一个中间件注册到该路由</span></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, m1, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;这是处理函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;处理函数&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实际上访问 127.0.0.1:8080&#x2F; 的时候会返次两个响应，但是我们基本不会这么写，一次请求对应多次响应是不准确也是不安全的，仅仅是用来做一个示例</li><li>根据打印和响应我们也可以发现执行顺序是中间件在处理函数之前</li></ul><h4 id="Abort-和-Next"><a href="#Abort-和-Next" class="headerlink" title="Abort() 和 Next()"></a>Abort() 和 Next()</h4><ul><li><code>Abort()</code><ul><li>会中止当前请求，不执行该语句后面的所有内容，即使后面可能处理函数都没有执行</li><li>注意和 return 不同，return 只结束该函数内的内容，不影响后续函数的执行</li></ul></li><li><code>Next()</code><ul><li>从当前 handler 的调用位置跳到下一个 handler 执行，执行完后续 handler（如果没有再次调用 next ），再返回上一个 next 调用位置继续往下执行</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳到下一个 handler</span></span><br><span class="line">    c.Next()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 out...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m2 in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳到下一个 handler</span></span><br><span class="line">    c.Next()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;m2 out...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, m1, m2, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;/ in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">&quot;/ out...&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里写了两个中间件 m1 和 m2，遇到 Next 后会跳转到下一个 Handler</li><li>本质上就是一个函数嵌套调用的过程</li><li><img src="https://img.lonesome.cn/blog/go-web/0866b73a-4d10-4d7d-adcf-7ac6c9483a4f.webp"><br>所以运行后的输出结果为：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m1 in...</span><br><span class="line">m2 in...</span><br><span class="line">/ in...</span><br><span class="line">/ out...</span><br><span class="line">m2 out...</span><br><span class="line">m1 out...</span><br></pre></td></tr></table></figure><p>如果将 m1 中的 <code>c.Next()</code> 换成 <code>c.Abort()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 in...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止当前请求，后续函数和代码都不会执行</span></span><br><span class="line">    c.Abort()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 out...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m1 in...</span><br></pre></td></tr></table></figure><p>运行到 Abort() 就结束了</p><h4 id="Set-和-Get"><a href="#Set-和-Get" class="headerlink" title="Set() 和 Get()"></a>Set() 和 Get()</h4><ul><li>用于中间件（handler）之间的通信，可以是在 handler 之内，也可以是之间</li><li>因为中间件实际上是不同的函数，在不同的函数之间我们不能直接传递数据，想要传递数据就需要用到 Gin 给我们封装好的 Context 中的 Set 和 Get 方法</li><li><code>Set</code>：用于在请求上下文中设置数据。可以使用 <code>c.Set(key, value)</code> 方法将某个键和对应的值存储到请求上下文中</li><li><code>Get</code>：用于从请求上下文中获取数据。可以使用 <code>c.Get(key)</code> 方法根据键获取在请求上下文中存储的值</li><li>先 Set 再 Get</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">m1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    user := UserInfo&#123;</span><br><span class="line">        Name: <span class="string">&quot;XiMo&quot;</span>,</span><br><span class="line">        Age:  <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 user 以键值对的形式存储到 Context 中</span></span><br><span class="line">    c.Set(<span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, m1, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 根据 key 返回 value（any 类型）和一个 bool 值</span></span><br><span class="line">        <span class="comment">// bool 值用来判断是否有这个 key</span></span><br><span class="line">        user, ok := c.Get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        fmt.Println(gin.H&#123;</span><br><span class="line">            <span class="string">&quot;userExist&quot;</span>: ok,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言，会返回断言类型的值和一个 bool 值</span></span><br><span class="line">        <span class="comment">// bool 值用来判断是否断言成功</span></span><br><span class="line">        <span class="comment">// 断言失败，返回的值为断言类型的零值</span></span><br><span class="line">        _user, _ok := user.(UserInfo)</span><br><span class="line">        fmt.Println(gin.H&#123;</span><br><span class="line">            <span class="string">&quot;type assertion&quot;</span>: _ok,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        fmt.Println(_user)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="记录接口耗时的中间件"><a href="#记录接口耗时的中间件" class="headerlink" title="记录接口耗时的中间件"></a>记录接口耗时的中间件</h4><p>我们可以写一个中间件用来记录接口耗时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StatCost 是一个统计请求耗时的中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatCost</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 请求开始的时间</span></span><br><span class="line">    start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该请求的剩余处理程序</span></span><br><span class="line">    c.Next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算耗时</span></span><br><span class="line">    cost := time.Since(start)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志形式打印</span></span><br><span class="line">    log.Println(cost)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h3><p>在 gin 框架中，我们可以为每个路由添加任意数量的中间件。</p><h4 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册 StatCost 中间件</span></span><br><span class="line">    r.Use(StatCost)</span><br><span class="line"></span><br><span class="line">    r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 停1秒</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello 精弘!&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们之前所讲的 <code>gin.Default()</code> 实际上就默认帮我们注册了两个全局中间件 <code>Logger()</code> 和 <code>Recovery()</code></li><li>如果不想集成这两个中间件可以使用 <code>gin.New()</code> 方法</li></ul><h4 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 / 路由单独注册中间件（可注册多个）</span></span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, StatCost, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 停1秒</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello 精弘!&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="为路由组注册中间件"><a href="#为路由组注册中间件" class="headerlink" title="为路由组注册中间件"></a>为路由组注册中间件</h4><p>为路由组注册中间件有以下两种写法。<br>写法 1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>, StatCost)</span><br><span class="line">&#123;</span><br><span class="line">    user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法 2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">user.Use(StatCost)</span><br><span class="line">&#123;</span><br><span class="line">    user.POST(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    user.POST(<span class="string">&quot;/exit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过路由组注册中间件易于定义中间件的使用范围<br>比如我只有 &#x2F;admin 相关的路由需要鉴权，判断是不是管理员，就可以通过路由组的方式去管理，而不需要单个一个个的注册或者全局注册（没有必要给所有路由都加上该中间件）</p>]]></content>
    
    
    <summary type="html">精弘网络 2023 暑期后端 Go Web 开发基础课程 —— Gin 框架
</summary>
    
    
    
    <category term="Go Web" scheme="https://lonesome.cn/categories/go-web/"/>
    
    
    <category term="Go" scheme="https://lonesome.cn/tags/Go/"/>
    
    <category term="Gin" scheme="https://lonesome.cn/tags/Gin/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse——你没有见过的列存储</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/clickhouse--column-storage-you-haven%E2%80%99t-seen-before/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/clickhouse--column-storage-you-haven%E2%80%99t-seen-before/</id>
    <published>2023-02-16T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:20.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><p>数据库是结构化信息或数据的有序集合，一般以电子形式存储在计算机系统中。通常由数据库管理系统(DBMS)来控制。在现实中，数据、DBMS 及关联应用一起被称为数据库系统，通常简称为数据库</p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><ul><li>数据解析整理成有序集合<ul><li><img src="https://img.lonesome.cn/blog/bytedance/CEHX_@B7@516RI4I@JRC7.webp"></li></ul></li><li>可以通过查询语言获取想要的信息<ul><li><img src="https://img.lonesome.cn/blog/bytedance/U80QJNAZFK2Q7TR8@_N.webp"></li></ul></li></ul><h3 id="数据库的类型"><a href="#数据库的类型" class="headerlink" title="数据库的类型"></a>数据库的类型</h3><ul><li>数据库有很多种，至于各种数据库孰优孰劣，主要取决于企业希望如何使用数据</li><li>关系数据库：关系型数据库是把数据以表的形式进行储存，然后再各个表之间建立关系，通过这些表之间的关系来操作不同表之间的数据</li><li>非关系数据库  <strong>：</strong> NoSQL 或非关系数据库，支持存储和操作非结构化及半结构化数据。相比于关系型数据库，NoSQL 没有固定的表结构，且数据之间不存在表与表之间的关系，数据之间可以是独立的。NoSQL 的关键是它们放弃了传统关系型数据库的强事务保证和关系模型，通过所谓最终一致性和非关系数据模型（例如键值对，图，文档）来提高 Web 应用所注重的高可用性和可扩展性</li><li>单机数据库：在一台计算机上完成数据的存储和查询的数据库系统</li><li>分布式数据库  <strong>：</strong>  分布式数据库由位于不同站点的两个或多个文件组成。数据库可以存储在多台计算机上，位于同一个物理位置，或分散在不同的网络上</li><li>OLTP 数据库  <strong>：</strong> OLTP（Online transactional processing）数据库是一种高速分析数据库，专为多个用户执行大量事务而设计</li><li>OLAP 数据库：OLAP (Online analytical processing) 数据库旨在同时分析多个数据维度，帮助团队更好地理解其数据中的复杂关系</li></ul><h3 id="OLAP-数据库"><a href="#OLAP-数据库" class="headerlink" title="OLAP 数据库"></a>OLAP 数据库</h3><ul><li>大量数据的读写，PB 级别的存储</li><li>多维分析，复杂的聚合函数</li><li>窗口函数，自定义 UDF (User Define Fucntion)</li><li>离线&#x2F;实时分析</li><li><img src="https://img.lonesome.cn/blog/bytedance/I2R7YO8J9L4AAPTUJF8.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/0XK4AOWRTPHOW1I.webp"></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li>一种编程语言，目前几乎所有的关系数据库都使用 SQL (<strong>Structured Query Language</strong> <strong>)</strong>  编程语言来查询、操作和定义数据，进行数据访问控制</li><li>SQL 的结构<ul><li>一个简单的 SQL 查询包含 SELECT 关键词。星号(“*“)也可以用来指定查询应当返回查询表所有字段，可选的关键词和子句</li><li><img src="https://img.lonesome.cn/blog/bytedance/JNWROXOR20AAJZR16N3.webp"><ul><li><code>FROM</code>子句指定了选择的数据表。<code>FROM</code>子句也可以包含<code>JOIN</code>  二层子句来为数据表的连接设置规则</li><li><code>WHERE</code>子句后接一个比较谓词以限制返回的行。<code>WHERE</code>子句仅保留返回结果里使得比较谓词的值为 True 的行</li><li><code>GROUP BY</code>子句用于将若干含有相同值的行合并。 <code>GROUP BY</code>通常与 SQL 聚合函数连用，或者用于清除数据重复的行。<code>GROUP BY</code>子句要用在<code>WHERE</code>子句之后</li><li><code>HAVING</code>子句后接一个谓词来过滤从<code>GROUP BY</code>子句中获得的结果，由于其作用于<code>GROUP BY</code>子句之上，所以聚合函数也可以放到其谓词中</li><li><code>ORDER BY</code>子句指明将哪个字段用作排序关键字，以及排序顺序(升序&#x2F;降序)，如果无此子句，那么返回结果的顺序不能保证有序</li></ul></li></ul></li><li>SQL 的用途<ul><li>定义数据模型<ul><li><img src="https://img.lonesome.cn/blog/bytedance/E5G_9X21_GXMAXTV5BHZIL.webp"></li></ul></li><li>读写数据库数据<ul><li><img src="https://img.lonesome.cn/blog/bytedance/537JP3IHGZSOZFCWUMAP2.webp"></li></ul></li></ul></li><li>SQL 的优点<ul><li>标准化，ISO 和 ANSI 是长期建立使用的 SQL 数据库标准</li><li>高度非过程化，用 SQL 进行数据操作，用户只需提出“做什么”，而不必指明“怎么做”，因此用户无须了解存取路径，存取路径的选择以及 SQL 语句的操作过程由系统自动完成。这不但大大减轻了用户负担，而且有利于提高数据独立性</li><li>以同一种语法结构提供两种使用方式，用户可以在终端上直接输入 SQL 命令对数据库进行操作。作为嵌入式语言，SQL 语句能够嵌入到高级语言（如 C、C#、JAVA）程序中，供程序员设计程序时使用。而在两种不同的使用方式下，SQL 的语法结构基本上是一致的</li><li>语言简洁，易学易用：SQL 功能极强，但由于设计巧妙，语言十分简洁，完成数据定义、数据操纵、数据控制的核心功能只用了 9 个动词：CREATE、ALTER、DROP、SELECT、INSERT、UPDATE、DELETE、GRANT、REVOKE。且 SQL 语言语法简单，接近英语口语，因此容易学习，也容易使用</li></ul></li></ul><h3 id="数据库的架构"><a href="#数据库的架构" class="headerlink" title="数据库的架构"></a>数据库的架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/G2TED_REA98AJAP2CW5.webp"></p><ul><li>SQL 的执行<ul><li>Parser：词法分析，语法分析，生成 AST 树 (Abstract syntax tree)<ul><li><img src="https://img.lonesome.cn/blog/bytedance/25N84EDYOTWW727LHH.webp"></li></ul></li><li>Analyzer：变量绑定、类型推导、语义检查、安全、权限检查、完整性检查等，为生成计划做准备<ul><li>例如：<ul><li>判断 a，b 是不是类型正确</li><li>a，b 是不是来自表 t</li><li>group by 字段是否合法，是否存在聚合函数</li></ul></li></ul></li><li>Optimizer：为查询生成性能最优的执行计划，进行代价评估<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WT8ZRR0AXDQXFBEV_T.webp"></li></ul></li><li>Executor：将执行计划翻译成可执行的物理计划并驱动其执行<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OK49@A74MBVO_K3YU9.webp"></li></ul></li></ul></li><li>存储引擎<ul><li>管理内存数据结构<ul><li>索引</li><li>内存数据</li><li>缓存<ul><li>Query cache</li><li>Data cache</li><li>Index cache</li></ul></li></ul></li><li>管理磁盘数据<ul><li>磁盘数据的文件格式</li><li>磁盘数据的增删查改</li></ul></li><li>读写算子<ul><li>数据写入逻辑</li><li>数据读取逻辑</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/CWGR6ORM38UM1SA1VDQL.webp"></li><li>如何存储数据？<ul><li>是否可以并发处理</li><li>是否可以构建索引</li><li>行存、列存或者行列混合存储</li></ul></li><li>如何读写数据？<ul><li>读多写少</li><li>读少写多</li><li>点查场景</li><li>分析型场景</li></ul></li></ul></li></ul><h2 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h2><p><img src="https://img.lonesome.cn/blog/bytedance/PKD4_0IC7IL8RAGCBF8SV.webp"></p><h3 id="列式存储的优点"><a href="#列式存储的优点" class="headerlink" title="列式存储的优点"></a>列式存储的优点</h3><ul><li>数据压缩<ul><li>数据压缩可以使读的数据量更少，在 IO 密集型计算中获得大的性能优势</li><li>相同类型压缩效率更高</li><li>排序之后压缩效率更高</li><li>可以针对不同类型使用不同的压缩算法</li><li>几种常见的压缩算法<ul><li><img src="https://img.lonesome.cn/blog/bytedance/SJN41QW8AKJI7BD@0RJ.webp"></li><li>LZ4<ul><li>(5,4) 代表向前 5 个 byte，匹配到的内容长度有 4，即”bcde”是一个重复</li><li>重复项越多或者越长，压缩率就会越高</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/50FJIITPI5J@DQ.webp"></li><li>Run-length encoding<ul><li>压缩重复的数据</li><li>可以在压缩数据上直接计算</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/TAQQXVO7DYKPU5TJ8KE6.webp"></li><li>Delta encoding<ul><li>将数据存储为连续数据之间的差异，而不是直接存储数据本身</li><li>特定算子也能直接在压缩数据上计算</li></ul></li></ul></li></ul></li><li>数据选择<ul><li>可以选择特定的列做计算而不是读所有列</li><li>对聚合计算友好</li><li><img src="https://img.lonesome.cn/blog/bytedance/DA6UA6MFDM35XXHGQ0.webp"></li></ul></li><li>延迟物化<ul><li>物化：将列数据转换为可以被计算或者输出的行数据或者内存数据结果的过程，物化后的数据通常可以用来做数据过滤，聚合计算，Join<ul><li><img src="https://img.lonesome.cn/blog/bytedance/T4EG@FAOA4MU9JE@6SN2.webp"></li></ul></li><li>延迟物化：尽可能推迟物化操作的发生<ul><li><img src="https://img.lonesome.cn/blog/bytedance/37Z_4KXHMGCPY6QR4.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/5CI1O@@DT4KR8VDRQ6DU.webp"></li></ul></li><li>缓存友好</li><li>CPU &#x2F; 内存带宽友好</li><li>可以利用到执行计划和算子的优化，例如 filter</li><li>保留直接在压缩列做计算的机会</li></ul></li><li>向量化<ul><li>SIMD (single instruction multiple data)，对于现代多核 CPU，其都有能力用一条指令执行多条数据</li><li><img src="https://img.lonesome.cn/blog/bytedance/QO9AIIZ3LANAJFVP79E.webp"><ul><li>如果这时候 CPU 也可以并行的计算我们写的代码，那么理论上我们的处理速度就会是之前代码的 100 倍，幸运的是 SIMD 指令就是完成这样的工作的，用 SIMD 指令完成这样代码设计和执行就叫做向量化</li></ul></li><li>指令集<ul><li>SIMD 程序使用的指令集有 SSE 和 AVX 系列，AVX 有 AVX-256 和 AVX-512，SSE 提供 128-bits 的寄存器，AVX-256 提供 256-bits，AVX-512 提供 512bits 的寄存器</li><li><img src="https://img.lonesome.cn/blog/bytedance/VEN5P_JQZ1LYTSWYRBU.webp"></li><li>数据格式要求<ul><li>需要处理多个数据，因此数据需要是连续内存</li><li>需要明确数据类型</li></ul></li></ul></li><li>执行模型<ul><li>数据需要按批读取</li><li>函数的调用需要明确数据类型</li><li><img src="https://img.lonesome.cn/blog/bytedance/8UNLAQJXO16BNM9NQ.webp"></li></ul></li><li>列存数据库适合设计出这样的执行模型，从而使用向量化技术<ul><li>按列读取</li><li>每种列类型定义数据读写逻辑</li><li>函数按列类型处理</li></ul></li></ul></li></ul><h3 id="行存-VS-列存"><a href="#行存-VS-列存" class="headerlink" title="行存 VS 列存"></a>行存 VS 列存</h3><p><img src="https://img.lonesome.cn/blog/bytedance/WOT_J@6XGPZU.webp"></p><h2 id="ClickHouse-存储设计"><a href="#ClickHouse-存储设计" class="headerlink" title="ClickHouse 存储设计"></a>ClickHouse 存储设计</h2><h3 id="表定义和结构"><a href="#表定义和结构" class="headerlink" title="表定义和结构"></a>表定义和结构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/00LOWTITE5442QHI07A24.webp"></p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/IRFQIBSJW3G98YAG89.webp"></p><h3 id="引擎架构"><a href="#引擎架构" class="headerlink" title="引擎架构"></a>引擎架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/PU372W3ME0D63GFZ2_HYG1.webp"></p><h3 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a>存储架构</h3><ul><li>文件组织<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5WFMS9UBJ2GP9G_L_I.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/ZY3WA2J3OKANJS88@9.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/73NEN87QO379E671Y0N8@W.webp"></li></ul></li><li>part 和 partition<ul><li>part 是物理文件夹的名字</li><li>partition 是逻辑结构</li><li><img src="https://img.lonesome.cn/blog/bytedance/3Z3H1VRE@BFM852EK8V.webp"></li></ul></li><li>part 和 column<ul><li>每个 column 都是一个文件</li><li>所有的 column 文件都在自己的 part 文件夹下</li></ul></li><li>column 和 index<ul><li>一个 part 有一个主键索引</li><li>每个 column 都有列索引</li></ul></li></ul><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><ul><li><p>Hash index</p><ul><li>将输入的 key 通过一个 HashFunction 映射到一组 bucket 上</li><li>每个 bucket 都包含一个指向一条记录的地址</li><li>哈希索引在查找的时候只适用于等值比较</li><li><img src="https://img.lonesome.cn/blog/bytedance/N8SP9JS4RQXDE68AQ9.webp"></li></ul></li><li><p>B-Tree</p><ul><li>数据写入是有序的，支持增删查改</li><li>每个节点有多个孩子节点</li><li>每个节点都按照升序排列 key 值</li><li>每个 key 有两个指向左右孩子节点的引用<ul><li>左孩子节点保存的 key 都小于当前 key</li><li>右孩子节点的保存的 key 都大于当前 key</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/EF@XOTDJ59URWZVVHD.webp"></li></ul></li><li><p>B+Tree</p><ul><li>所有的数据都存储在叶子节点，非叶子节点只保存 key 值</li><li>叶子节点维护到相邻叶子节点的引用</li><li>可以通过 key 值做二分查找，也可以通过叶子节点做顺序访问</li><li><img src="https://img.lonesome.cn/blog/bytedance/0BK74THVRW2@2UE4B.webp"></li></ul></li><li><p>对于大数据量，B(B+)-Tree 深度太高</p></li><li><p>索引数据量太大，多个列如何平衡查询和存储——LSM-Tree</p></li><li><p>OLAP 场景写入量非常大，如何优化写入</p></li><li><p>Log-structured merge-tree(LSM tree)是一种为大吞吐写入场景而设计的数据结构</p><ul><li>着重优化顺序写入</li><li>主要数据结构<ul><li>SSTables</li><li>Memtable</li></ul></li></ul></li><li><p>SSTables</p><ul><li>Key 按顺序存储到文件中，称为 segment</li><li>包含多个 segment</li><li>每个 segment 写入磁盘后都是不可更改的，新加的数据只能生成新的 segment</li><li><img src="https://img.lonesome.cn/blog/bytedance/XQR4WUOWCIQ50BNV8OOE.webp"></li></ul></li><li><p>Memtable</p><ul><li>在内存中的数据保存在 memtable 中，大多数实现都是一颗 Binary search tree</li><li>当 memtable 存储的数据到达一定的阈值的时候，就会按顺序写入到磁盘</li></ul></li><li><p>数据查询</p><ul><li>需要从最新的 segment 开始遍历每个 key</li><li>也可以为每个 segment 建一个索引，例如</li><li><img src="https://img.lonesome.cn/blog/bytedance/KVH55HBDZL@WOR0FQBNL.webp"></li></ul></li><li><p>Compaction(合并)</p><ul><li>Compaction 指将多个 segments 合并成一个 segments 的过程<ul><li>一般是有一个后台线程完成</li><li>不同的 segments 写入新的 segment 的时候也是需要排序，形成新的 segment 之后，旧的 segment 文件就会被删除</li><li><img src="https://img.lonesome.cn/blog/bytedance/4EJF@_Q5D4YMC96QELIGYMY.webp"></li></ul></li></ul></li></ul><h3 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h3><ul><li>主键索引<ul><li><img src="https://img.lonesome.cn/blog/bytedance/FEGZO4JNMI@R6KEGREQ.webp"></li></ul></li><li>数据按照主键顺序依次做排序<ul><li>首先按照 UserID 做排序</li><li>再按照 URL 排序</li><li>最后是 EventTime</li><li><img src="https://img.lonesome.cn/blog/bytedance/QJQ5KNRLNQTVXDAVLCP.webp"></li></ul></li><li>数据被划分成 granule<ul><li>granule 是最小的数据读取单元</li><li>不同的 granulas 可以并行读取</li><li><img src="https://img.lonesome.cn/blog/bytedance/6JYEJOEWIK6GUY3TTXQ.webp"></li></ul></li><li>每个 granule 都对应 primary.idx 里面的一行<ul><li><img src="https://img.lonesome.cn/blog/bytedance/UTDTHUYPXCSH1YXN0ZKG1.webp"></li></ul></li><li>默认每 8192 行记录主键的一行值，primary.idx 需要被全部加载到内存里面<ul><li><img src="https://img.lonesome.cn/blog/bytedance/51SM_886L@BDX9FR18R.webp"></li></ul></li><li>里面保存的每一行数据被称为一个 index mark<ul><li><img src="https://img.lonesome.cn/blog/bytedance/8SZH9EMI0U5PAUSKV7.webp"></li></ul></li><li>每个列都有这样一个 mark 文件<ul><li>mark 文件保存的是每个 granule 的物理地址</li><li>每一列都有一个自己的 mark 文件</li><li><img src="https://img.lonesome.cn/blog/bytedance/QLHU57ICKK6HZKFB.webp"></li></ul></li><li>mark 文件里面的每一行存储两个地址<ul><li>第一个地址称为 block_offset，用于定位一个 granule 的压缩数据在物理文件中的位置，压缩数据会以一个 block 为单位解压到内存中</li><li>第二个地址称为 granule_offset，用于定位一个 granule 在解压之后的 block 中的位置</li></ul></li><li>缺陷：数据按照 key 的顺序做排序，因此只有第一个 key 的过滤效果好，后面的 key 过滤效果依赖第一个 key 的基数大小<ul><li><img src="https://img.lonesome.cn/blog/bytedance/KDX85Y3E11Y83ZKVKAS.webp"></li></ul></li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><ul><li>secondary index：在 URL 列上构建二级索引<ul><li><img src="https://img.lonesome.cn/blog/bytedance/HZVH8TNFNGGMYPW4B.webp"></li></ul></li><li>构建多个主键索引<ul><li>再建一个表<ul><li><img src="https://img.lonesome.cn/blog/bytedance/3VGMLBRP69HXNYZQWJX2.webp"></li><li>数据需要同步两份</li><li>查询需要用户判断查哪张表</li><li><img src="https://img.lonesome.cn/blog/bytedance/L9GYTY7VM_CDL5CN32.webp"></li></ul></li><li>建一个物化视图<ul><li>物化视图：可以通过 select 查询将一个表的数据写入一张隐式表</li><li><img src="https://img.lonesome.cn/blog/bytedance/2FA41GG3XFBRCLH8SQ.webp"></li><li>数据自动同步到隐式表</li><li>查询需要用户判断查哪张表</li><li><img src="https://img.lonesome.cn/blog/bytedance/6W@6O@3CE90@9N26@IL.webp"></li></ul></li><li>使用 Projection<ul><li>projection：类似于物化试图，但是不是将数据写入新的表，而是存储在原始表中，以一个列文件的形式存在</li><li><img src="https://img.lonesome.cn/blog/bytedance/8L@4OYSF7ERH6I6QH4.webp"></li><li>数据自动同步到隐式表</li><li>查询自动路由到最优的表</li><li><img src="https://img.lonesome.cn/blog/bytedance/UG9QDSRX@8O@N.webp"></li></ul></li><li>小结<ul><li>主键包含的数据顺序写入</li><li>主键构造一个主键索引</li><li>每个列构建一个稀疏索引</li><li>通过 mark 的选择让主键索引可以定位到每一列的索引</li><li>可以通过多种手段优化非主键列的索引</li></ul></li></ul></li></ul><h3 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h3><ul><li>一个 part 内的数据是有序的<ul><li><img src="https://img.lonesome.cn/blog/bytedance/K1NA40_HNS530SP.webp"></li></ul></li><li>不同 part 之间的数据是无序的<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5YZP99G7328T0USPD7HNE.webp"></li></ul></li><li>数据合并是将多个 part 合并成一起的过程<ul><li><img src="https://img.lonesome.cn/blog/bytedance/A3M5GT@6XKREIKZ5ATZEKO.webp"></li></ul></li><li>part 的合并发生在一个分区内<ul><li><img src="https://img.lonesome.cn/blog/bytedance/N_YTPXL84Y1_OBS2RFGU.webp"></li></ul></li><li>数据的可见性<ul><li>数据合并过程中，未被合并的数据对查询可见</li><li>数据合并完成后，新 part 可见，被合并的 part 被标记删除</li><li><img src="https://img.lonesome.cn/blog/bytedance/2BH5UXQFR05SSZP.webp"></li></ul></li></ul><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul><li>通过主键找到需要读的 mark<ul><li><img src="https://img.lonesome.cn/blog/bytedance/QOYM1NWECQECEJI7DTKG.webp"></li></ul></li><li>切分 marks，然后并发的调度 reader<ul><li><img src="https://img.lonesome.cn/blog/bytedance/MI_H1T9J1LS47W0O@@6M@E.webp"></li></ul></li><li>Reader 通过 mark block_offset 得到需要读的数据文件的偏移量</li><li>Reader 通过 mark granule_offset 得到解压之后数据的偏移量<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1RME807C1Y1J6VU@F@7Q.webp"></li></ul></li><li>构建列式 filter 做数据过滤<ul><li><img src="https://img.lonesome.cn/blog/bytedance/6QTSQZE29C5IP7V@BF.webp"></li></ul></li></ul><h2 id="ClickHouse-应用场景"><a href="#ClickHouse-应用场景" class="headerlink" title="ClickHouse 应用场景"></a>ClickHouse 应用场景</h2><ul><li>大宽表存储和查询<ul><li>大宽表查询<ul><li>可以建非常多的列</li><li>可以增加，删除，清空每一列的数据</li><li>查询的时候引擎可以快速选择需要的列</li><li>可以将列涉及到的过滤条件下推到存储层从而加速查询</li><li><img src="https://img.lonesome.cn/blog/bytedance/HWE7DFM65_ZXZLY2@7R.webp"></li></ul></li><li>动态表结构<ul><li>map 中的每个 key 都是一列</li><li>map 中的每一列都可以单独的查询</li><li>使用方式同普通列，可以做任何计算</li><li><img src="https://img.lonesome.cn/blog/bytedance/VFU9KVR8SU8W03EHDU6K.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/CB79G2W151S@D_IDB01.webp"></li></ul></li></ul></li><li>离线数据分析<ul><li>数据导入<ul><li>数据可以通过 spark 生成 clickhouse 格式的文件</li><li>导入到 hdfs 上由 hive2ch 导入工具完成数据导入</li><li>数据直接导入到各个物理节点</li><li><img src="https://img.lonesome.cn/blog/bytedance/WH0TMCLIMFSUK43I5HH.webp"></li></ul></li><li>数据按列导入<ul><li>保证查询可以及时访问已有数据</li><li>可以按需加载需要的列</li><li><img src="https://img.lonesome.cn/blog/bytedance/H3RJMXT_C9SULC61R@M.webp"></li></ul></li></ul></li><li>实时数据分析<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0FG21J8@O0AUHH6R8X9.webp"></li><li>使用 memory table 减少 parts 数量<ul><li>数据先缓存在内存中</li><li>到达一定阈值再写到磁盘</li><li><img src="https://img.lonesome.cn/blog/bytedance/MY9HP64NWE8UZUOKWK.webp"></li></ul></li></ul></li><li>复杂类型查询<ul><li>bitmap 索引<ul><li>构建<ul><li><img src="https://img.lonesome.cn/blog/bytedance/ET9NNRG6LKXR3RF1Z2OE.webp"></li></ul></li><li>查询<ul><li><img src="https://img.lonesome.cn/blog/bytedance/BHCF3510IEQ_WCYFOK.webp"></li></ul></li></ul></li><li>bitmap64 类型<ul><li><img src="https://img.lonesome.cn/blog/bytedance/AJEYVMCWOEXLB748EO9.webp"></li></ul></li><li>lowcardinality<ul><li>对于低基数列使用字典编码</li><li>减少数据存储和读写的 IO 使用</li><li>可以做运行时的压缩数据过滤</li><li><img src="https://img.lonesome.cn/blog/bytedance/M__P1U9P2A80W_N2BQF0.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/8MTTVKRU6TFUF8BK0Y.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/5M9EMKCKKIX5LCZ2_@AS.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/@N5L83ZNGWETRQS9H3J6.webp"></li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ClickHouse 是标准的列存结构</li><li>存储设计是 LSM-Tree 架构</li><li>使用稀疏索引加速查询</li><li>每个列都有丰富的压缩算法和索引结构</li><li>基于列存设计的高效的数据处理逻辑</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库基本概念&quot;&gt;&lt;a href=&quot;#数据库基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库基本概念&quot;&gt;&lt;/a&gt;数据库基本概念&lt;/h2&gt;&lt;p&gt;数据库是结构化信息或数据的有序集合，一般以电子形式存储在计算机系统中。通常由数据库管理系统(DBMS</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="ClickHouse" scheme="https://lonesome.cn/tags/ClickHouse/"/>
    
  </entry>
  
  <entry>
    <title>Redis——大厂程序员是怎么用的</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/redis--how-do-programmers-use-it/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/redis--how-do-programmers-use-it/</id>
    <published>2023-02-15T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:19.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-是什么"><a href="#Redis-是什么" class="headerlink" title="Redis 是什么"></a>Redis 是什么</h2><ul><li>为什么需要 Redis<ul><li>数据从单表，演进出了分库分表<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1834A2OICLDX7C4CX6.webp"></li></ul></li><li>Mysql 从单机演进出了集群<ul><li>数据量增长</li><li>读写数据压力的不断增加</li></ul></li><li>数据分冷热<ul><li>热数据：经常被访问到的数据</li></ul></li><li>将热数据存储到内存中</li><li><img src="https://img.lonesome.cn/blog/bytedance/4QMRLI99NKP8UT8KBX.webp"></li></ul></li><li>Redis 基本工作原理<ul><li><img src="https://img.lonesome.cn/blog/bytedance/YF0FAQ6DF4C6LI4R37M.webp"></li><li>数据从内存中读写</li><li>数据保存到硬盘上防止重启数据丢失<ul><li>增量数据保存到 AOF 文件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/CKJ4Z6G@KZJISJQI4.webp"></li></ul></li><li>全量数据 RDB 文件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/VZEPJXPJSVEK60FVA.webp"></li></ul></li></ul></li><li>单线程处理所有操作命令<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1YKFIJBZZMNL@XONF.webp"></li></ul></li></ul></li></ul><h2 id="Redis-应用案例"><a href="#Redis-应用案例" class="headerlink" title="Redis 应用案例"></a><a href="https://gitee.com/wedone/redis_course">Redis 应用案例</a></h2><ul><li>1、连续签到<ul><li>掘金每日连续签到<ul><li>用户每日有一次签到机会，如果断签，连续签到计数将归为 0</li><li>连续签到的定义：每天必须在 23:59:59 前签到</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/5@H6PUZ3MD8O45O_E.webp"><ul><li>Key：cc_uid_1165894833417101</li><li>value：252</li><li>expireAt：后天的零点</li></ul></li><li>String 数据结构<ul><li>数据结构-sds</li><li><img src="https://img.lonesome.cn/blog/bytedance/YH9_XC4HXY16@EBYN.webp"><ul><li>可以存储字符串、数字、二进制数据</li><li>通常和 expire 配合使用</li><li>场景：存储计数、Session</li></ul></li></ul></li></ul></li><li>2、消息通知<ul><li>用 list 作为消息队列</li><li>使用场景：消息通知<ul><li>例如当文章更新时，将更新后的文章推送到 ES，用户就能搜索到最新的文章数据</li><li><img src="https://img.lonesome.cn/blog/bytedance/OUEGDJFIAMJC7FC22H7O.webp"></li></ul></li><li>List 数据结构 Quicklist<ul><li>Quicklist 由一个双向链表和 listpack 实现</li><li><img src="https://img.lonesome.cn/blog/bytedance/6_XP84SI3W6AC52HKJCCF.webp"></li><li>Listpack 数据结构<ul><li><img src="https://img.lonesome.cn/blog/bytedance/D1QVL7B8RSVHCFJ8@NCF.webp"></li></ul></li></ul></li></ul></li><li>3、计数<ul><li>一个用户有多项计数需求，可通过 hash 结构存储</li><li><img src="https://img.lonesome.cn/blog/bytedance/C5YNICY5QPFH_Z92X107.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/D0MX8QMNUBH0NN8K.webp"></li><li>Hash 数据结构 dict<ul><li><img src="https://img.lonesome.cn/blog/bytedance/BVM_SDVMBQBS0URV74.webp"></li><li>rehash：rehash 操作是将 ht[O]中的数据全部迁移到 ht[1]中。数据量小的场景下直接将数据从 ht[O 拷贝到 ht[1]速度是较快的。数据量大的场景，例如存有上百万的 KV 时，迁移过程将会明显阻塞用户请求</li><li>渐进式 rehash：为避免出现这种情况，使用了 rehash 方案。基本原理就是，每次用户访问时都会迁移少量数据。将整个迁移过程，平摊到所有的访问用不请求过程中</li></ul></li></ul></li><li>排行榜<ul><li>积分变化时，排名要实时变更</li><li><img src="https://img.lonesome.cn/blog/bytedance/0HG0COLNIAVE1A8HMK.webp"></li><li>zset 数据结构 zskiplist<ul><li>查找数字 7 的路径，head，3，3，7</li><li>结合 dict 时，可实现通过 key 操作跳表的功能<ul><li>ZINCRBY myzset 2 “Alex”</li><li>ZSCORE myzset “Alex”</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/ER5I2HKVBT5KJM27KTJ.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/6VM829WCWJW7_UVFI2.webp"></li></ul></li></ul></li><li>5、限流<ul><li>要求 1 秒内放行的请求为 N，超过 N 则禁止访问</li><li><img src="https://img.lonesome.cn/blog/bytedance/3CVV_Q9I9F93F_L5SBCJ.webp"></li><li>Key：comment_freq_limit_1671356046<ul><li>对这个 Key 调用 incr，超过限制 N 则禁止访问</li><li>1671356046 是当前时间戳</li></ul></li></ul></li><li>分布式锁<ul><li>并发场景，要求一次只能有一个协程运行，执行完成后，其他等待中的协程才能执行</li><li><img src="https://img.lonesome.cn/blog/bytedance/R2JOO8V45N89SK_YIK.webp"></li><li>可以使用 redis 的 setnx 实现，利用了两个特性<ul><li>Redis 是单线程执行命令</li><li>setnx 只有未设置过才能执行成功</li></ul></li></ul></li></ul><h2 id="Redis-使用注意事项"><a href="#Redis-使用注意事项" class="headerlink" title="Redis 使用注意事项"></a>Redis 使用注意事项</h2><h3 id="大-Key、热-Key"><a href="#大-Key、热-Key" class="headerlink" title="大 Key、热 Key"></a>大 Key、热 Key</h3><ul><li><p>大 Key 的定义</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/YHIQXGKJS5Y816ZAX.webp"></li></ul></li><li><p><img src="https://img.lonesome.cn/blog/bytedance/LDCX12BXH6T95D74LON.webp"></p></li><li><p>大 Key 的危害</p><ul><li>读取成本高</li><li>容易导致慢查询（过期、删除）</li><li>主从复制异常，服务组塞无法正常响应请求</li></ul></li><li><p>业务侧使用大 Key</p><ul><li>请求 Redis 超时报错</li></ul></li><li><p>消除大 Key 的方法</p><ul><li>1、拆分<ul><li>将大 Key 拆分为小 Key。例如一个 String 拆分成多个 String</li><li><img src="https://img.lonesome.cn/blog/bytedance/2LZ8_62MHWK29T30DJW.webp"></li></ul></li><li>2、压缩<ul><li>将 valuel 压缩后写入 redis，读取时解压后再使用。压缩算法可以是 gzip、snappy、lz4 等。通常情况下，一个压缩算法压缩率高、则解压耗时就长。需要对实际数据进行测试后，选择一个合适的算法</li><li>如果存储的是 JSON 字符串，可以考虑使用 MessagePack 进行序列化</li></ul></li><li>3、集合类结构 hash、list、set<ul><li>拆分：可以用 hash 取余、位掩码的方式决定放在哪个 Key 中</li><li>区分冷热：如榜单列表场景使用 zset，只缓存前 10 页数据，后续数据走 db</li></ul></li></ul></li><li><p>热 Key 的定义</p><ul><li>用户访问一个 Key 的 QPS 特别高，导致 Server 实例出现 CPU 负载突增或者不均的情况</li><li>热 key 没有明确的标准，QPS 超过 500 就有可能被识别为热 Key</li><li><img src="https://img.lonesome.cn/blog/bytedance/TO@0JW9OAOTAP7NU.webp"></li></ul></li><li><p>解决热 Key 的方法</p><ul><li>1、设置 Localcache<ul><li>在访问 Redis 前，在业务服务侧设置 Localcache，降低访问 Redis 的 QPS。LocalCache 中缓存过期或未命中，则从 Redist 中将数据更新到 LocalCache。Java 的 Guava、Golang 的 Bigcache 就是这类 LocalCache</li><li><img src="https://img.lonesome.cn/blog/bytedance/7N5_6X_Y5O0XAUME.webp"></li></ul></li><li>2、拆分<ul><li>将 key : value 这一个热 Key 复制写入多份，例如 key1 : value,key2 : value，访问的时候访问多个 key，但 value 是同一个，以此将 qps 分散到不同实例上，降低负载。代价是，更新时需要更新多个 key，存在数据短暂不一致的风险</li><li><img src="https://img.lonesome.cn/blog/bytedance/DUYBC3FMWI7JBM1Z8MAC4.webp"></li></ul></li><li>3、使用 Redis 代理的热 Key 承载能力<ul><li>字节跳动的 Redis 访问代理就具备热 Key 承载能力。本质上是结合了“热 Key 发现”、“LocalCache”两个功能</li><li><img src="https://img.lonesome.cn/blog/bytedance/P3QS8SD3R6IFK3KEOC.webp"></li></ul></li></ul></li></ul><h3 id="慢查询场景"><a href="#慢查询场景" class="headerlink" title="慢查询场景"></a>慢查询场景</h3><ul><li>容易导致 redis 慢查询的操作<ul><li>批量操作一次性传入过多的 key&#x2F;value，如 mset&#x2F;hmset&#x2F;sadd&#x2F;zadd 等 O(n)操作建议单批次不要超过 100，超过 100 之后性能下降明显</li><li>Zset 大部分命令都是 O(log(n))，当大小超过 5k 以上时，简单的 zadd&#x2F;zrem 也可能导致慢查询</li><li>操作的单个 vaue 过大，超过 10KB。也即，避免使用大 Key</li><li>对大 key 的 delete&#x2F;expire 操作也可能导致慢查询，Redis4.0 之前不支持异步删除 unlink，大 key 删除会阻塞 Redis</li></ul></li></ul><h3 id="缓存穿透、缓存雪崩"><a href="#缓存穿透、缓存雪崩" class="headerlink" title="缓存穿透、缓存雪崩"></a>缓存穿透、缓存雪崩</h3><ul><li>缓存穿透：热点数据查询绕过缓存，直接查询数据库</li><li>缓存雪崩：大量缓存同时过期</li><li>缓存穿透的危害<ul><li>查询一个一定不存在的数据<ul><li>通常不会缓存不存在的数据，这类查询请求都会直接打到 db，如果有系统 bug 或人为攻击，那么容易导致 db 响应慢甚至宕机</li></ul></li><li>缓存过期时<ul><li>在高并发场景下，一个热 key 如果过期，会有大量请求同时击穿至 db，容易影响 db 性能和稳定</li><li>同一时间有大量 key 集中过期时，也会导致大量请求落到 db 上，导致查询变慢，甚至出现 db 无法响应新的查询</li></ul></li></ul></li><li>如何减少缓存穿透<ul><li>缓存空值<ul><li>如一个不存在的 userlD。这个 id 在缓存和数据库中都不存在。则可以缓存一个空值，下次再查缓存直接反空值</li></ul></li><li>布隆过滤器<ul><li>通过 bloom filter 算法来存储合法 Key，得益于该算法超高的压缩率，只需占用极小的空间就能存储大量 key 值</li></ul></li></ul></li><li>如何避免缓存雪崩<ul><li>缓存空值<ul><li>将缓存失效时间分散开，比如在原有的失效时间基础上增加一个随机值，例如不同 Key 过期时间可以设置为 10 分 1 秒过期，10 分 23 秒过期，10 分 8 秒过期。单位秒部分就是随机时间，这样过期时间就分散了</li><li>对于热点数据，过期时间尽量设置得长一些，冷门的数据可以相对设置过期时间短一些</li></ul></li><li>使用缓存集群，避免单机宕机造成的缓存雪崩</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-是什么&quot;&gt;&lt;a href=&quot;#Redis-是什么&quot; class=&quot;headerlink&quot; title=&quot;Redis 是什么&quot;&gt;&lt;/a&gt;Redis 是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么需要 Redis&lt;ul&gt;
&lt;li&gt;数据从单表，演进出了分库分表&lt;u</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="Redis" scheme="https://lonesome.cn/tags/Redis/"/>
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL——深入理解RDBMS</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/mysql--in-depth-understanding-of-rdbms/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/mysql--in-depth-understanding-of-rdbms/</id>
    <published>2023-02-13T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:19.304Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.lonesome.cn/blog/bytedance/ZEW16CSVEKU@SM10IR0JPI.webp"></p><h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><ul><li>从一场红包雨说起<ul><li><img src="https://img.lonesome.cn/blog/bytedance/2FVS4PX3SREBSTOL_V58.webp"></li></ul></li><li>RDBMS 事务 ACID<ul><li>事务(Transaction)：是由一组 SQL 语句组成的一个程序执行单元（Unit），它需要满足 ACID 特性<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5TU_YNQEDKMA17YREL.webp"></li></ul></li><li>ACID：<ul><li>原子性(<strong>Atomicity</strong>)：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生</li><li>一致性(<strong>Consistency</strong>)：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性</li><li>隔离性(<strong>Isolation</strong>)：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果</li><li>持久性(<strong>Durability</strong>)：在事务完成以后，该事务所对数据库所做的更改便持久的保存在数据库之中，并不会被回滚</li></ul></li><li>红包雨 与 ACID<ul><li><img src="https://img.lonesome.cn/blog/bytedance/56XYK56QIG0GRUG436.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/F091PF@MTFDPOP5FQOQ.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/@YJYQ32NE5W3WQ18C3J2.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/NKLRZFDXR0@BSO1ZTXC9.webp"></li></ul></li><li>红包雨 与 高并发<ul><li><img src="https://img.lonesome.cn/blog/bytedance/Y3AS7IBHF34F49MUVV.webp"></li></ul></li><li>红包雨 与 高可靠<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DWACJCWDRIVZ23ZYAPS.webp"></li></ul></li></ul></li></ul><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="前-DBMS-时代"><a href="#前-DBMS-时代" class="headerlink" title="前 DBMS 时代"></a>前 DBMS 时代</h3><ul><li>人工管理<ul><li>在现代计算机发明出来以前，通过人工的方式进行数据记录和管理</li></ul></li><li>文件系统<ul><li>1950s，现代计算机的雏形基本出现。1956 年 IBM 发布了第一个磁盘驱动器–Model 305 RAMAC，从此数据存储进入硬盘时代。在这个阶段，数据管理直接通过文件系统来实现</li></ul></li></ul><h3 id="DBMS-时代"><a href="#DBMS-时代" class="headerlink" title="DBMS 时代"></a>DBMS 时代</h3><ul><li>1960s，传统的文件系统已经不能满足人们的需要，数据库管理系统（<strong>DBMS</strong>）应运而生</li><li>DBMS：按照某种数据模型来组织、存储和管理数据的仓库</li><li>所以通常按照数据模型的特点将传统数据库系统分成<strong>网状数据库</strong>、<strong>层次数据库</strong>和<strong>关系数据库</strong>三类</li><li><img src="https://img.lonesome.cn/blog/bytedance/I@TYJV0_F@IF88_JAVB.webp"></li></ul><h3 id="DBMS-数据模型"><a href="#DBMS-数据模型" class="headerlink" title="DBMS 数据模型"></a>DBMS 数据模型</h3><ul><li>网状模型<ul><li>网状数据库所基于的网状数据模型建立的数据之间的联系，能反映现实世界中信息的关联，是许多空间对象的自然表达形式</li><li>1964 年，世界上第一个数据库系统一集成数据存储（Integrated Data Storage，IDS）诞生于通用电气公司。1DS 是世界上第一个网状数据库，奠定了数据库发展的基础，在当时得到了广泛的应用。在 1970s 网状数据库系统十分流行，在数据库系统产品中占据主导地位</li><li><img src="https://img.lonesome.cn/blog/bytedance/BGK8K3HRU_JZSWJOSF5YI.webp"></li></ul></li><li>层次模型<ul><li>1968 年，世界上第一个层次数据库一信息管理系统（Information Management System，IMS）诞生于于 IBM 公司，这也是世界上第一个大型商用的数据库系统。层次数据模型，即使用树形结构来描述实体及其之间关系的数据模型</li><li><img src="https://img.lonesome.cn/blog/bytedance/M89HJZ5DFCTQ45WWGC.webp"></li></ul></li><li>关系模型<ul><li>1970 年，IBM 的研究员 E.F.Codd 博士发表了一篇名为“A Relational Model of Data for large Shared Data Banks”的论文，提出了关系模型的概念，奠定了关系模型的理论基础。1979 年 Oracle 首次将关系型数据库商业化，后续 DB2，SAP Sysbase ASE，and Informix 等知名数据库产品也纷纷面世</li><li><img src="https://img.lonesome.cn/blog/bytedance/CDY81XGW5AK1T47SW6HE.webp"></li></ul></li><li>优劣势<ul><li><img src="https://img.lonesome.cn/blog/bytedance/RA@T_XGVQ8T54C_73F.webp"></li></ul></li></ul><h3 id="SQL-语言"><a href="#SQL-语言" class="headerlink" title="SQL 语言"></a>SQL 语言</h3><ul><li>1974 年 IBM 的 Ray Boycei 和 Don Chamberlin 将 Codd 关系数据库的 12 条准则的数学定义以简单的关键字语法表现出来，里程碑式地提出了 SQL(Structured Query Language)语言<ul><li>语法风格接近自然语言</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>语言简洁，易学易用</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/JEHRBF7W0P3I4AMIUEI5.webp"></li></ul><h3 id="历史回顾"><a href="#历史回顾" class="headerlink" title="历史回顾"></a>历史回顾</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ANUJJ5MW5E1E@37OQU9.webp"></p><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><h3 id="一条-SQL-的一生"><a href="#一条-SQL-的一生" class="headerlink" title="一条 SQL 的一生"></a>一条 SQL 的一生</h3><p><img src="https://img.lonesome.cn/blog/bytedance/IX8HEIYE5Y3CKAIFD6.webp"></p><h3 id="SQL-引擎"><a href="#SQL-引擎" class="headerlink" title="SQL 引擎"></a>SQL 引擎</h3><ul><li>Parser<ul><li>解析器(Parser)一般分为词法分析(Lexical analysis)、语法分析(Syntax analysis))、语义分析(Semantic analyzer)等步骤</li><li><img src="https://img.lonesome.cn/blog/bytedance/JI_PSRX64RWUZ_5VTXMVN.webp"></li></ul></li><li>Optimizer<ul><li>为什么需要一个优化器(Optimizer)？<ul><li><img src="https://img.lonesome.cn/blog/bytedance/IL7VWM1OW6N@8LW@4.webp"></li></ul></li><li>基于规则的优化(<strong>RBO</strong> Rule Base Optimizer)<ul><li>条件化简<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OOM4HXWSUIJ4OGBRM.webp"></li></ul></li><li>表连接优化<ul><li>总是小表先进行连接</li></ul></li><li>Scan 优化<ul><li>唯一索引</li><li>普通索引</li><li>全表扫描</li></ul></li><li>数据库索引：是数据库管理系统中辅助数据结构，以协助快速查询、更新数据库表中数据。目前数据库中最常用的索引是通过 B+树实现的</li></ul></li><li>基于代价的优化(CBO Cost Base Optimizer)<ul><li>一个查询有多种执行方案，CBO 会选择其中代价最低的方案去真正的执行</li><li>什么是代价？<ul><li><img src="https://img.lonesome.cn/blog/bytedance/9LRZMYRJAQZ9@JL.webp"></li></ul></li></ul></li></ul></li><li>Executor<ul><li>火山模型<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5B7FVB2M3VM48FYB0.webp"></li><li>每个 Operator 调用 Next 操作，访问下层 Operator，获得下层 Operator 返回的一行数据，经过计算之后，将这行数据返回给上层</li><li>优点：<ul><li>每个算子独立抽象实现，相互之间没有耦合，逻辑结构简单</li></ul></li><li>缺点：<ul><li>每计算一条数据有多次函数调用开销，导致 CPU 效率不高</li></ul></li></ul></li><li>向量化<ul><li><img src="https://img.lonesome.cn/blog/bytedance/BDAN4U@9LIF1M51549D.webp"></li><li>每个 ○perator 每次操作计算的不再是一行数据，而是一批数据(Batch N 行数据)，计算完成后向上层算子返回一个 Batch</li><li>优点：<ul><li>函数调用次数降低为 1&#x2F;N</li><li>CPU cache 命中率更高</li><li>可以利用 CPU 提供的 SIMD(Single Instruction Multi Data)机制</li></ul></li></ul></li><li>编译执行<ul><li><img src="https://img.lonesome.cn/blog/bytedance/76FIP7OEWDIFLQ2ULM24NE.webp"></li><li>将所有的操作封装到一个函数里面，函数调用的代价也能大幅度降低</li><li>用户 SQL 干变万化怎么办？难道要穷举用户的所有 SQL,给每一个 SQL 都预先写好一个执行函数吗？<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@V6T1NMDHVUQ7H1MY.webp"></li></ul></li></ul></li></ul></li></ul><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><ul><li>InnoDB<ul><li><img src="https://img.lonesome.cn/blog/bytedance/V8X_Y3GRTIAY5X4_DJ.webp"></li><li>In-Memory：<ul><li>Buffer Pool</li><li>Change Buffer</li><li>Adaptive Hash Index</li><li>Log Buffer</li></ul></li><li>On-Disk：<ul><li>System Tablespace(ibdata1)</li><li>General Tablespaces(xxx.ibd)</li><li>Undo Tablespaces(xxx.ibu)</li><li>Temporary Tablespaces(xxx.ibt)</li><li>Redo Log(ib_logfileN)</li></ul></li></ul></li><li>Buffer Pool<ul><li><img src="https://img.lonesome.cn/blog/bytedance/UKR1BW0Q4B8BT6Z6.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/XG_PRVEHBH5AJGE.webp"></li></ul></li><li>Page<ul><li><img src="https://img.lonesome.cn/blog/bytedance/13N89GLL1FTV2BWKETF.webp"></li></ul></li><li>B+ Tree<ul><li><img src="https://img.lonesome.cn/blog/bytedance/LNTJY320TBS3H@1L3L8OX.webp"></li><li>页面内：<ul><li>页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li></ul></li><li>从根到叶：<ul><li>中间节点存储</li></ul></li><li>点查：<ul><li>Select * from table wehre id &#x3D; 2000;</li></ul></li><li>范围查询：<ul><li>Select * from table wehre id &gt; 2000;</li></ul></li></ul></li></ul><h3 id="事务引擎"><a href="#事务引擎" class="headerlink" title="事务引擎"></a>事务引擎</h3><ul><li>Atomicity 与 Undo Log<ul><li><img src="https://img.lonesome.cn/blog/bytedance/XN3R5VMNEFM_94.webp"></li><li>如何将数据库回退到修改之前的状态？<ul><li>Undo Log<ul><li>Undo Log 是<strong>逻辑日志</strong>，记录的是数据的<strong>增量变化</strong>。利用 Undo Log 可以进行事务回滚，从而保证事务的原子性。同时也实现了多版本并发控制(MVCC)，解决读写冲突和一致性读的问题</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/62FKKM3ZY48URE2R2PW.webp"></li></ul></li></ul></li><li>Isolation 与 锁<ul><li>前情提要：羊老师从抖音抢了一个亿红包，又从头条抢了一个亿。抖音和头条都要往羊老师的账户转一个亿，如果两个操作同时进行，发生冲突怎么办？</li><li><img src="https://img.lonesome.cn/blog/bytedance/7S3G1OLVHYYC_55R.webp"></li></ul></li><li>Isolation 与 MVCC<ul><li><img src="https://img.lonesome.cn/blog/bytedance/V74Z8ASO2Y7DY7C37DR.webp"></li><li>MVCC 的意义：<ul><li>读写互补阻塞</li><li>降低死锁概率</li><li>实现一致性读</li></ul></li><li>Undo Log 在 MVCC 的作用：<ul><li>每个事务有一个单增的事务 ID</li><li>数据页的行记录中包含了 DB_ROW_ID，DB_TRX_ID，DB_ROLL_PTR</li><li>DB_ROLL_PTR 将数据行的所有快照记录都通过链表的结构串联了起来</li></ul></li></ul></li><li>Durability 与 Redo Log<ul><li>如何保证事务结束后，对数据的修改永久的保存？</li><li>方案一：事务提交前页面写盘<ul><li><img src="https://img.lonesome.cn/blog/bytedance/A1PP56F0BI8OMA00L.webp"></li><li>问题：随机 IO、写放大</li></ul></li><li>方案二：WAL(Write-ahead logging)<ul><li>redo log 是物理日志，记录的是页面的变化，它的作用是保证事务持久化。如果数据写入磁盘前发生故障，重启 MySQL 后会根据 redo log 重做</li></ul></li></ul></li></ul><h2 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h2><h3 id="春节红包雨挑战"><a href="#春节红包雨挑战" class="headerlink" title="春节红包雨挑战"></a>春节红包雨挑战</h3><p><img src="https://img.lonesome.cn/blog/bytedance/YKR7C8H6H7U71IJIUND5.webp"></p><h3 id="大流量-Sharding"><a href="#大流量-Sharding" class="headerlink" title="大流量-Sharding"></a>大流量-Sharding</h3><ul><li>问题背景<ul><li>单节点写容易成为瓶颈</li><li>单机数据容量上限</li></ul></li><li>解决方案<ul><li>业务数据进行水平拆分</li><li>代理层进行分片路由</li></ul></li><li>实施效果<ul><li>数据库写入能力扩展</li><li>数据库容量线性扩展</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/8NQB5_V616@TOCTCZL9.webp"></li></ul><h3 id="流量突增"><a href="#流量突增" class="headerlink" title="流量突增"></a>流量突增</h3><ul><li>扩容<ul><li>问题背景<ul><li>活动流量上涨</li><li>集群性能不满足要求</li></ul></li><li>解决方案<ul><li>扩容 DB 物理节点数量</li><li>利用影子表进行压测</li></ul></li><li>实施效果<ul><li>数据库集群提供更高的吞吐</li><li>保证集群可以承担预期流量</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/TFBGJXV_S_CWURD8UL.webp"></li></ul></li><li>代理连接池<ul><li>问题背景<ul><li>突增流量导致大量建联</li><li>大量建联导致负载变大，延时上升</li></ul></li><li>解决方案<ul><li>业务侧预热连接池</li><li>代理则预热连接池</li><li>代理侧则支持连接队列</li></ul></li><li>实施效果<ul><li>避免 DB 被突增流量打死</li><li>避免代理和 DB 被大量建联打死</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/O9J3XWP3IO6PA5T3M4.webp"></li></ul></li></ul><h3 id="稳定性-可靠性"><a href="#稳定性-可靠性" class="headerlink" title="稳定性&amp;可靠性"></a>稳定性&amp;可靠性</h3><ul><li>3AZ 高可用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DBX19QOBV1YDSYLR.webp"></li></ul></li><li>HA 管理<ul><li>问题背景<ul><li>db 所在机器异常宕机</li><li>db 节点异常宕机</li></ul></li><li>解决方案<ul><li>ha 服务监管、切换宕机节点</li><li>代理支持配置热加载</li><li>代理自动屏蔽宕机读节点</li></ul></li><li>实施效果<ul><li>读节点宕机秒级恢复</li><li>写节点宕机 30s 内恢复服务</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/T_96F64E94360SHAG2L.webp"></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/bytedance/ZEW16CSVEKU@SM10IR0JPI.webp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;经典案例&quot;&gt;&lt;a href=&quot;#经典案例&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="MySQL" scheme="https://lonesome.cn/tags/MySQL/"/>
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>带你认识存储的本质——状态</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/let-you-understand-the-essence-of-storage--status/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/let-you-understand-the-essence-of-storage--status/</id>
    <published>2023-02-12T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:19.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><ul><li>数据的产生<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WSEP50IU2J4@1BK2YDUE7.webp"></li></ul></li><li>数据的流动<ul><li><img src="https://img.lonesome.cn/blog/bytedance/L2G18WHQLARXJX7K4NK.webp"></li></ul></li><li>数据的持久化<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DJUSTW7KHJZCV5P868XFF.webp"></li></ul></li><li>潜在的问题<ul><li>数据库怎么保证<strong>数据不丢</strong></li><li>数据库怎么处理<strong>多人同时修改</strong>的问题</li><li>为什么用数据库，除了数据库还能存到<strong>别的存储系统</strong>吗</li><li>数据库只能处理<strong>结构化数据</strong>吗</li><li>有哪些操作数据库的<strong>方式</strong>，要用什么<strong>编程语言</strong></li></ul></li></ul><h2 id="存储-数据库简介"><a href="#存储-数据库简介" class="headerlink" title="存储 &amp; 数据库简介"></a>存储 &amp; 数据库简介</h2><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><ul><li>系统概览<ul><li>什么是存储系统？</li><li>一个提供了读写、控制类的接口，能够安全有效的把数据持久化的软件，就可以称为<strong>存储系统</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/0XU1H09SRBXM@@WUB.webp"></li></ul></li><li>系统特点<ul><li>作为后端软件的底座，<strong>性能敏感</strong></li><li>存储系统软件架构，<strong>容易受硬件影响</strong></li><li>存储系统<strong>代码，既“简单”又“复杂”</strong></li></ul></li><li>存储器层级结构<ul><li><img src="https://img.lonesome.cn/blog/bytedance/H4P0LHX0K21NID7VMVS.webp"></li></ul></li><li>数据怎么从应用到存储介质<ul><li><img src="https://img.lonesome.cn/blog/bytedance/D3NES3@5M0ZMW27IZ05.webp"></li><li><strong>[缓存]</strong> 很重要，贯穿整个存储体系</li><li><strong>[拷贝]</strong> 很昂贵，应该尽量减少</li><li>硬件设备五花八门，需要有抽象统一的接入层</li></ul></li><li>RAID 技术<ul><li>单机存储系统怎么做到<strong>高性能&#x2F;高性价比&#x2F;高可靠性</strong>？<ul><li><strong>R</strong>(edundant) <strong>A</strong>(rray) of <strong>I</strong>(nexpensive) <strong>D</strong>(isks)</li></ul></li><li>RAID 出现的背景：<ul><li>单块大容量磁盘的<strong>价格</strong>&gt;多块小容量磁盘</li><li>单块磁盘的写入<strong>性能</strong>&lt;多块磁盘的并发写入性能</li><li>单块磁盘的<strong>容错能力</strong>有限，不够安全</li></ul></li><li>RAID 0<ul><li>多块磁盘简单组合</li><li>数据条带化存储，提高磁盘宽带</li><li>没有额外的容错设计</li></ul></li><li>RAID 1<ul><li>一块磁盘对应一块额外镜像盘</li><li>真实空间利用率仅 50%</li><li>容错能力强</li></ul></li><li>RAID 0+1<ul><li>结合了 RAID 0 和 RAID 1</li><li>真实空间利用率仅 50%</li><li>容错能力强，写入宽带好</li></ul></li></ul></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>数据库和存储系统<strong>不一样</strong><ul><li>关系型数据库</li><li>非关系型数据库</li></ul></li><li>概览<ul><li><strong>关系</strong>（Relation）是什么？<ul><li>Edgar.F.Codd 于 1970 年提出 <strong>[关系模型]</strong></li><li>关系 &#x3D; <strong>集合</strong> &#x3D; 任意元素组成的若干有序偶对反映了事物间的联系</li><li>关系代数 &#x3D; 对关系作<strong>运算的抽象查询语言</strong><ul><li>交、并、笛卡尔积……</li></ul></li><li>SQL &#x3D; 一种 DSL &#x3D; <strong>方便人类阅读</strong>的关系代数表达形式</li></ul></li></ul></li><li>关系型数据库特点<ul><li><strong>关系型数据库是存储系统</strong>，但是在存储之外，又发展出<strong>其他能力</strong><ul><li>结构化数据友好</li><li>支持事务（ACID）</li><li>支持复杂查询语言</li></ul></li></ul></li><li>非关系型数据库特点<ul><li>非关系型数据体也是存储系统，但是<strong>一般不要求严格的结构化</strong><ul><li>半结构化数据友好</li><li>可能支持事务（ACID）</li><li>可能支持复杂查询语言</li></ul></li></ul></li></ul><h3 id="数据库-vs-经典存储"><a href="#数据库-vs-经典存储" class="headerlink" title="数据库 vs 经典存储"></a>数据库 vs 经典存储</h3><ul><li>结构化数据管理<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@B6QO3YCEEF2LAOXO3.webp"></li></ul></li><li>事务能力<ul><li>凸显出数据库支持[事务]的优越性</li><li>事务具有：<ul><li>A(tomicity).事务内的操作要么全做，要么不做</li><li>C(onsistency).事务执行前后，数据状态是一致的</li><li>I(solation).可以隔离多个并发事务，避免影响</li><li>D(urability).事务一旦提交成功，数据保证持久性</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/XTAE5ZDHD1BNKISY43_2.webp"></li></ul></li><li>复杂查询能力<ul><li>写入数据之后，想做很复杂的查询怎么办？</li><li>Example：请查询出名字以 xiao 开头，且密码提示问题小于 10 个字的人，并按性别分组统计人数</li><li><img src="https://img.lonesome.cn/blog/bytedance/PG0_F0@GCUOK97NT8F.webp"></li></ul></li></ul><h3 id="数据库使用方式"><a href="#数据库使用方式" class="headerlink" title="数据库使用方式"></a>数据库使用方式</h3><ul><li>Everything is D(omain) S(pecific) L(anguage) &#x3D;&#x3D;&gt; maybe SQL</li><li>以 SQl 为例，要操作数据时，支持以下操作：<ul><li>Insert</li><li>Update</li><li>Select</li><li>Delete</li><li>Where 子句</li><li>GroupBy</li><li>OrderBy</li></ul></li><li>要对数据库定义做修改时，支持以下操作：<ul><li>Create User</li><li>Create database</li><li>Create table</li><li>Alter table</li><li>……</li></ul></li></ul><h2 id="主流产品剖析"><a href="#主流产品剖析" class="headerlink" title="主流产品剖析"></a>主流产品剖析</h2><h3 id="单机存储"><a href="#单机存储" class="headerlink" title="单机存储"></a>单机存储</h3><ul><li>概览<ul><li>单机存储 &#x3D; 单个计算机节点上的存储软件系统，一般不涉及网络交互<ul><li>本地文件系统</li><li>key-value 存储</li></ul></li></ul></li><li>本地文件系统<ul><li>Linux 经典哲学：<strong>一切皆文件</strong></li><li>文件系统的管理单元：文件</li><li>文件系统接口：文件系统繁多，如 Ext2&#x2F;3&#x2F;4，sysfs，rootfs 等，但都遵循 VFS 的统一抽象接口</li><li>Linux 文件系统的两大数据结构：<strong>Index Node</strong> &amp; <strong>Directory Entry</strong><ul><li><strong>Index Node</strong><ul><li>记录文件元数据，如 id、大小、权限、磁盘位置等 inode 是一个文件的<strong>唯一标识</strong>，会被存储到磁盘上 inode 的总数在格式化文件系统时就固定了</li></ul></li><li><strong>Directory Entry</strong><ul><li>记录文件名、inode 指针，层级关系（parent）等</li><li>dentry 是内存结构，与 inode 的关系 N:1（hardlink 的实现）</li></ul></li></ul></li></ul></li><li>key-value 存储<ul><li>世间一切皆<strong>key-value</strong></li><li>常见使用方式：put(k,v)&amp;get(k)</li><li>常见数据结构：LSM-Tree，某种程度上牺牲读性能，追求写入性能</li><li>拳头产品：RocksDB</li><li><img src="https://img.lonesome.cn/blog/bytedance/OBUH3UXU3T0NFUZV76.webp"></li></ul></li></ul><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><ul><li>概览<ul><li>分布式存储 &#x3D; 在单机存储基础上实现了<strong>分布式协议</strong>，涉及大量网络交互<ul><li>分布式文件系统</li><li>分布式对象存储</li></ul></li></ul></li><li>HDFS<ul><li>HDFS：堪称大数据时代的<strong>基石</strong></li><li>时代背景：专用的高级硬件<strong>很贵</strong>，同时数据存量<strong>很大</strong>，要求超高<strong>吞吐</strong></li><li>HDFS 核心特点：<ul><li>支持<strong>海量数据存储</strong></li><li><strong>高容错性</strong></li><li><strong>弱 POSIX 语义</strong></li><li>使用普通 x86 服务器，<strong>性价比高</strong></li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/YOGWN319DE8JG5MZWD.webp"></li></ul></li><li>Ceph<ul><li>Ceph：开源分布式存储系统里的 <strong>[万金油]</strong></li><li>Ceph 的核心特点：<ul><li>一套系统支持对象接口、块接口、文件接口，但是<strong>一切皆对象</strong></li><li>数据写入采用<strong>主备复制模型</strong></li><li>数据分布模型采用 CRUSH 算法</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/FTWWBPCHG75C1QU9K_F72.webp"></li></ul></li></ul><h3 id="单机数据库"><a href="#单机数据库" class="headerlink" title="单机数据库"></a>单机数据库</h3><ul><li>概览<ul><li>单机数据库 &#x3D; 单个计算机节点上的数据库系统</li><li><strong>事务在单机内执行，也可能通过网络交互实现分布式事务</strong><ul><li>关系型数据库</li><li>非关系型数据库</li></ul></li></ul></li><li>关系型数据库<ul><li>商业产品 Oracle 称王，开源产品<strong>MySQL</strong> &amp; <strong>PostgreSQL</strong>称霸</li><li>关系型数据库的通用组件：<ul><li>Query Engine——负责解析 query，生成查询计划</li><li>Txn Manager——负责事务并发管理</li><li>Lock Manager——负责锁相关的策略</li><li>Storage Engine——负责组织内存&#x2F;磁盘数据结构</li><li>Replication——负责主备同步</li></ul></li><li>关键内存数据结构：B-Tree、B+-Tree、LRU List 等</li><li>关键磁盘数据结构：WriteAheadLog（RedoLog）、Page</li><li><img src="https://img.lonesome.cn/blog/bytedance/U36CVB1LKX3F397JE_ALFY.webp"></li></ul></li><li>非关系型数据库<ul><li><strong>MongoDB</strong>、<strong>Redis</strong>、<strong>Elasticsearch</strong>三足鼎立</li><li>关系型数据库一般直接使用 SQL 交互，而非关系型数据库<strong>交互方式各不相同</strong></li><li>非关系型数据库的数据结构千奇百怪，没有关系约束后，<strong>schema 相对灵活</strong></li><li>不管是否关系型数据库，大家都在尝试支持<strong>SQL（子集）和“事务”</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/G91D4W3@DB@RACQPMHQ.webp"></li></ul></li><li>Elasticsearch 使用案例<ul><li><img src="https://img.lonesome.cn/blog/bytedance/YHGLRQDTXO4GXZK30W6L.webp"></li></ul></li></ul><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><ul><li>从单机到分布式数据库<ul><li>单机数据库遇到了哪些问题 &amp; 挑战，需要我们引入<strong>分布式架构</strong>来解决？<ul><li>容量</li><li>弹性</li><li>性价比</li></ul></li></ul></li><li>解决容量问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0ADRQT8RY50YDU0B6.webp"></li></ul></li><li>解决弹性问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0YM1U6QJW@OGXFKEW.webp"></li></ul></li><li>解决性价比问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/1IQ9IOVQI8FLHWYQQ94GB.webp"></li></ul></li><li>More to Do<ul><li>单写 vs <strong>多写</strong></li><li>从磁盘弹性到<strong>内存弹性</strong></li><li><strong>分布式事务</strong>优化</li></ul></li></ul><h2 id="新技术演进"><a href="#新技术演进" class="headerlink" title="新技术演进"></a>新技术演进</h2><ul><li>概览<ul><li><img src="https://img.lonesome.cn/blog/bytedance/MRYS352X4UW70H9US.webp"></li></ul></li><li>SPDK<ul><li><img src="https://img.lonesome.cn/blog/bytedance/8IXGJW0VDN9NQ1L6ZLY.webp"></li></ul></li><li>AI &amp; Storage<ul><li>AI 领域相关技术，如 Machine Learning 在很多领域：如推荐、风控、视觉领域证明了有效性</li><li><img src="https://img.lonesome.cn/blog/bytedance/2HDQ7CAXO3D51CES0.webp"></li></ul></li><li>高性能硬件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4DSZ57JZB25JWHVMNNI.webp"></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img.lonesome.cn/blog/bytedance/KGDUN@6YBT7OUZP5PB.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经典案例&quot;&gt;&lt;a href=&quot;#经典案例&quot; class=&quot;headerlink&quot; title=&quot;经典案例&quot;&gt;&lt;/a&gt;经典案例&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据的产生&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/byt</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="数据库" scheme="https://lonesome.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="存储" scheme="https://lonesome.cn/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>RPC原理与实现</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/rpc-principle-and-implementation/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/rpc-principle-and-implementation/</id>
    <published>2023-02-10T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:19.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="本地函数调用"><a href="#本地函数调用" class="headerlink" title="本地函数调用"></a>本地函数调用</h3><p><img src="https://img.lonesome.cn/blog/bytedance/TRPJ39738A38QJL28O33.webp"></p><ol><li>将 a 和 b 的值压栈</li><li>通过函数指针找到 calculate 函数，进入函数取出栈中的值 2 和 3，将其赋予 x 和 y</li><li>计算 x * y，并将结果存在 z</li><li>将 z 的值压栈，然后从 calculate 返回</li><li>从栈中取出 z 返回值，并赋值给 result</li></ol><h3 id="远程函数调用（RPC-Remote-Procedure-Calls）"><a href="#远程函数调用（RPC-Remote-Procedure-Calls）" class="headerlink" title="远程函数调用（RPC-Remote Procedure Calls）"></a>远程函数调用（RPC-Remote Procedure Calls）</h3><p><img src="https://img.lonesome.cn/blog/bytedance/7JFHRZWK39EJ7P5GHCPG.webp"></p><ul><li>RPC 需要解决的问题<ul><li>函数映射</li><li>数据转换成字节流</li><li>网络传输</li></ul></li></ul><h3 id="RPC-概念模型"><a href="#RPC-概念模型" class="headerlink" title="RPC 概念模型"></a>RPC 概念模型</h3><p><img src="https://img.lonesome.cn/blog/bytedance/512XM2K7JJZM3IY11.webp"></p><p>1984 年 Neison 发表了论文《Implementing Remote Procedure Calls》，其中提出了 RPC 的过程由 5 个模型组成：User、User-Stub、RPC-Runtime、Server-Stub、Server</p><h3 id="一次-RPC-的完整过程"><a href="#一次-RPC-的完整过程" class="headerlink" title="一次 RPC 的完整过程"></a>一次 RPC 的完整过程</h3><p><img src="https://img.lonesome.cn/blog/bytedance/U1HJEDMCZ41V08CG.webp"></p><ul><li>IDL（Interface description language）文件<ul><li>IDL 通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信</li></ul></li><li>生成代码<ul><li>通过编译器工具把 IDL 文件转换成语言对应的静态库</li></ul></li><li>编解码<ul><li>从内存中表示到字节序列的转换称为编码，反之为解码，也常叫做序列化和反序列化</li></ul></li><li>通信协议<ul><li>规范了数据在网络中的传输内容和格式，除必须的请求&#x2F;响应数据外，通常还会包含额外的元数据</li></ul></li><li>网络传输<ul><li>通常基于成熟的网络库走 TCP&#x2F;UDP 传输</li></ul></li></ul><h3 id="RPC-的好处"><a href="#RPC-的好处" class="headerlink" title="RPC 的好处"></a>RPC 的好处</h3><p><img src="https://img.lonesome.cn/blog/bytedance/AFNBEUZNZ7R6PDBA6N5EH.webp"></p><ol><li>单一职责，有利于分工协作和运维开发</li><li>可扩展性强，资源使用率更优</li><li>故障隔离，服务的整体可靠性更高</li></ol><h3 id="RPC-带来的问题"><a href="#RPC-带来的问题" class="headerlink" title="RPC 带来的问题"></a>RPC 带来的问题</h3><ol><li>服务宕机，对方应该如何处理？</li><li>在调用过程中发生网络异常如何保证消息的可达性？</li><li>请求量暴增导致服务无法及时处理，有哪些应对措施？</li></ol><h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><h3 id="以-Apache-Thrift-为例"><a href="#以-Apache-Thrift-为例" class="headerlink" title="以 Apache Thrift 为例"></a>以 Apache Thrift 为例</h3><p><img src="https://img.lonesome.cn/blog/bytedance/MOJJ1YQRR@B8H8VY.webp"></p><h3 id="编解码层"><a href="#编解码层" class="headerlink" title="编解码层"></a>编解码层</h3><p><img src="https://img.lonesome.cn/blog/bytedance/FHORA5PC1MY45IT777ZHY.webp"></p><ul><li>生成代码<ul><li><img src="https://img.lonesome.cn/blog/bytedance/9YHHPWC7UP8C01WKT4O@A24.webp"></li></ul></li><li>数据格式<ul><li>语言特定的格式<ul><li>许多编程语言都内建了将内存对象编码为字节序列的支持，例如 Java 有 Java.io.Serializable</li></ul></li><li>文本格式<ul><li>JSON、XML、CSV 等文本格式，具有人类可读性</li></ul></li><li>二进制编码<ul><li>具备跨语言和高性能等优点，常见有 Thrift 的 BinaryProtocol，Protobuf 等</li></ul></li></ul></li><li>二进制编码<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DZMPLP@PCD3EZW71Q.webp"></li><li>TLV 编码<ul><li><ul><li>Tag：标签，可以理解为类型</li></ul></li><li><ul><li>Lenght：长度</li></ul></li><li><ul><li>Value：值，Value 也可以是个 TLV 结构</li></ul></li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/DEUD@BFR@W2YKJRQZF.webp"></li></ul></li><li>选型<ul><li>兼容性<ul><li>支持自动增加新的字段，而不影响老的服务，这将提高系统的灵活性</li></ul></li><li>通用性<ul><li>支持跨平台、跨语言</li></ul></li><li>性能<ul><li>从空间和时间两个维度来考虑，也就是编码后数据大小和编码耗费时长</li></ul></li></ul></li></ul><h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><p><img src="https://img.lonesome.cn/blog/bytedance/YBC83@JWP2L7P@8_6.webp"></p><ul><li>概念<ul><li>特殊结束符：一个特殊字符作为每个协议单元结束的标识<ul><li><img src="https://img.lonesome.cn/blog/bytedance/CUR3O6FWNIPF5O7HMOSVK.webp"></li></ul></li><li>变长协议：以定长加不定长的部分组成，其中定长的部分需要描述不定长的内容长度<ul><li><img src="https://img.lonesome.cn/blog/bytedance/POY2ZMTOD62ILMMQDFA9M.webp"></li></ul></li></ul></li><li>协议构造<ul><li><img src="https://img.lonesome.cn/blog/bytedance/DGMZFYCGOKKXLY2OUW2.webp"></li><li>LENGTH：数据包大小，不包含自身</li><li>HEADER MAGIC：标识版本信息，协议解析时候快速校验</li><li>SEQUENCE NUMBER：表示数据包的 seqID，可用于多路复用，单连接内递增</li><li>HEADER SIZE：头部长度，从第 14 个字节开始计算一直到 PAYLOAD 前</li><li>PROTOCAL ID：编解码方式，有 Binary 和 Compact 两种</li><li>TRANSFORM ID：压缩方式，如 zlib 和 snappy</li><li>INFO ID：传递一些定制的 meta 信息</li><li>PAYLOAD：消息体</li></ul></li><li>协议解析<ul><li><img src="https://img.lonesome.cn/blog/bytedance/26OR90Z3Y9EBFXTRV0T.webp"></li></ul></li></ul><h3 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h3><p><img src="https://img.lonesome.cn/blog/bytedance/VSOIV45FZUUNWW_I.webp"></p><ul><li>Sockets API<ul><li><img src="https://img.lonesome.cn/blog/bytedance/ZWWBGERE2L3HCMI55V3GBH.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/BIXBO4WW2LMFIKXD.webp"></li></ul></li><li>网络库<ul><li>提供易用 API<ul><li>封装底层 Socket API</li><li>连接管理和事件分发</li></ul></li><li>功能<ul><li>协议支持：tcp、udp 和 uds 等</li><li>优雅退出、异常处理等</li></ul></li><li>性能<ul><li>应用层 buffer 减少 copy</li><li>高性能定时器、对象池等</li></ul></li></ul></li></ul><h2 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>保障策略<ul><li>熔断：保护调用方，防止被调用的服务出现问题而影响到整个链路</li><li>限流：保护被调用方，防止大流量把服务压垮</li><li>超时控制：避免浪费资源在不可用节点上</li><li><img src="https://img.lonesome.cn/blog/bytedance/S6A3H_LMNOXI_7XYQQ.webp"></li></ul></li><li>请求成功率<ul><li>负载均衡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/39IN3BZXND36SZYKK.webp"></li></ul></li><li>重试<ul><li><img src="https://img.lonesome.cn/blog/bytedance/G2T02HQNLOBUN7MEJE.webp"></li></ul></li></ul></li><li>长尾请求<ul><li>Backup Request<ul><li><img src="https://img.lonesome.cn/blog/bytedance/61E7E8SJS8S@3WELA.webp"></li></ul></li></ul></li><li>注册中间件<ul><li><img src="https://img.lonesome.cn/blog/bytedance/JU7W5IZQRU5F@IE9G6N1S.webp"></li></ul></li></ul><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul><li>开箱即用<ul><li>合理的默认参数选项，丰富的文档</li></ul></li><li>周边工具<ul><li>生成代码工具，脚手架工具</li></ul></li></ul><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ul><li>Middleware</li><li>Option</li><li>编解码层</li><li>协议层</li><li>网络传输层</li><li>代码生成工具插件扩展</li><li><img src="https://img.lonesome.cn/blog/bytedance/QP0@QS03672V40WMI5E.webp"></li></ul><h3 id="观测性"><a href="#观测性" class="headerlink" title="观测性"></a>观测性</h3><ul><li>Log、Metric、Tracing</li><li>内置观测性服务</li><li><img src="https://img.lonesome.cn/blog/bytedance/WPVDCEY8H8K94XZTD9M.webp"></li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>场景<ul><li>单机多机</li><li>单连接多连接</li><li>单&#x2F;多 client 单&#x2F;多 server</li><li>不同大小的请求包</li><li>不同请求类型：例如 pingpong、streaming 等</li></ul></li><li>目标<ul><li>高吞吐</li><li>低延迟</li></ul></li><li>手段<ul><li>连接池</li><li>多路复用</li><li>高性能编解码协议</li><li>高性能网络库</li></ul></li></ul><h2 id="企业实践"><a href="#企业实践" class="headerlink" title="企业实践"></a>企业实践</h2><h3 id="整体架构-Kitex"><a href="#整体架构-Kitex" class="headerlink" title="整体架构-Kitex"></a>整体架构-Kitex</h3><p><img src="https://img.lonesome.cn/blog/bytedance/2M60HMIITZ74HLUR4YY.webp"></p><ul><li>Kitex Core<ul><li>核心组件</li></ul></li><li>Kitex Byted<ul><li>与公司内部基础设施集成</li></ul></li><li>Kitex Tool<ul><li>代码生成工具</li></ul></li></ul><h3 id="自研网络库"><a href="#自研网络库" class="headerlink" title="自研网络库"></a>自研网络库</h3><ul><li>背景<ul><li>原生库无法感知连接状态问题<ul><li>在使用连接池时，池中存在失效链接，影响连接池的复用</li></ul></li><li>原生库存在 goroutine 暴涨的风险<ul><li>一个连接一个 goroutine 的模式，由于连接利用率低下，存在大量 goroutine 占用调度开销，影响性能</li></ul></li></ul></li><li>Netpoll<ul><li>解决无法感知连接状态问题<ul><li>引入 epoll 主动监听机制，感知连接状态</li></ul></li><li>解决 goroutine 暴涨的风险<ul><li>建议 goroutine 池，复用 goroutine</li></ul></li><li>提升性能<ul><li>引入 Nocopy Buffer，向上层提供 NoCopy 的调用接口，编解码层面零拷贝</li></ul></li></ul></li></ul><h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><ul><li>支持多协议，也支持灵活的自定义协议扩展</li><li><img src="https://img.lonesome.cn/blog/bytedance/28NXVC1IYITITAF7QHV.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/IFGHVH3ABFLQXASE_V.webp"></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>网络库优化<ul><li>调度优化<ul><li>epoll_wait 在调度上的控制</li><li>gopool 重用 goroutine 降低同时运行协程数</li></ul></li><li>LinkBuffer<ul><li>读写并行无锁，支持 nocopy 地流式读写</li><li>高效扩缩容</li><li>Nocopy Buffer 池化，减少 GC</li></ul></li><li>Pool<ul><li>引入内存池和对象池，减少 GC 开销</li></ul></li></ul></li><li>编解码优化<ul><li>Codegen<ul><li>预计算并预分配内存，减少内存操作次数，包括次数分配和拷贝</li><li>Inline 减少函数调用次数和减少不必要的反射操作等</li><li>自研了 Go 语言实现的 Thrift IDL 解析和代码生成器，支持完善的 Thrift IDL 语法和语义检查，并支持了插件机制 - Thriftgo</li></ul></li><li>JIT<ul><li>使用 JIT 编译技术改善用户体验的同时带来更强的编解码性能，减轻用户维护生成代码的负担</li><li>基于 JIT 编译技术的高性能动态 Thrift 编解码器 - Frugal</li></ul></li></ul></li></ul><h3 id="合并部署"><a href="#合并部署" class="headerlink" title="合并部署"></a>合并部署</h3><ul><li>微服务过微，传输和序列化开销越来越大</li><li>将亲和性强的服务实例尽可能调度到同一个物理机，远程 RPC 调用优化为本地 IPC 调用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4CNU55C9G4Z9B8VI@O.webp"><img src="https://img.lonesome.cn/blog/bytedance/RVAG16RR2VC870XCOT.webp"></li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/JMH8_L9PG2NMB6JVQ.webp"></li><li>中心化的部署调度和流量控制</li><li>基于共享内存的通信协议</li><li>定制化的服务发现和连接池实现</li><li>定制化的服务启动和监听逻辑</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;本地函数调用&quot;&gt;&lt;a href=&quot;#本地函数调用&quot; class=&quot;headerlink&quot; title=&quot;本地函数调</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="RPC" scheme="https://lonesome.cn/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>消息队列原理与实战</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/message-queue-principle-and-practice/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/message-queue-principle-and-practice/</id>
    <published>2023-02-09T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:19.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li><p>案例一：系统崩溃</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/5R89LNJTF647MDEXS.webp"></li><li>解决方案：解耦<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4WNK6CJEEMGECSKHCPMC.webp"></li></ul></li></ul></li><li><p>案例二：服务能力有限</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/MNEQBGWPC8_M8VBUPBS.webp"></li><li>解决方案：削峰<ul><li><img src="https://img.lonesome.cn/blog/bytedance/VBLQS58S4FIILB_196D.webp"></li></ul></li></ul></li><li><p>案例三：链路耗时长尾</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/9VWDDLW20T2U18@DFSJ.webp"></li><li>解决方案：异步<ul><li><img src="https://img.lonesome.cn/blog/bytedance/I64F3@AHGYM7HCGH15.webp"></li></ul></li></ul></li><li><p>案例四：日志存储</p><ul><li>服务器故障日志丢失</li><li>解决方案：<ul><li><img src="https://img.lonesome.cn/blog/bytedance/K_4XQ0ZIMSX5YH530L.webp"></li></ul></li></ul></li><li><p>什么是消息队列？</p><ul><li>消息队列（MQ），指保存消息的一个容器，本质是个队列，但这个队列需要支持<strong>高吞吐、高并发、并且高可用</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/C3TFQIP0H0JIW_CM.webp"></li></ul></li></ul><h2 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h2><h3 id="消息队列发展历程"><a href="#消息队列发展历程" class="headerlink" title="消息队列发展历程"></a>消息队列发展历程</h3><p><img src="https://img.lonesome.cn/blog/bytedance/OHZDGHXJR82MSNC.webp"></p><h3 id="业内消息队列对比"><a href="#业内消息队列对比" class="headerlink" title="业内消息队列对比"></a>业内消息队列对比</h3><p><img src="https://img.lonesome.cn/blog/bytedance/R3YSMQYA6C5OLP.webp"></p><h2 id="消息队列-Kafka"><a href="#消息队列-Kafka" class="headerlink" title="消息队列-Kafka"></a>消息队列-Kafka</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><img src="https://img.lonesome.cn/blog/bytedance/H236IBJV5VLNT@VP@6WHT5.webp"></p><h3 id="如何使用-Kafka"><a href="#如何使用-Kafka" class="headerlink" title="如何使用 Kafka"></a>如何使用 Kafka</h3><p><img src="https://img.lonesome.cn/blog/bytedance/7UN0I5IT52B3E73IFST4L.webp"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img.lonesome.cn/blog/bytedance/AJ82YE_0QMJ@6MXRU.webp"></p><ul><li><p>Topic：逻辑队列，不同 Topic 可以建立不同的 Topic</p></li><li><p>Cluster：物理集群，每个集群中可以建立多个不同的 Topic</p></li><li><p>Producer：生产者，负责将业务消息发送到 Topic 中</p></li><li><p>Consumer：消费者，负责消费 Topic 中的消息</p></li><li><p>ConsumerGroup：消费者组，不同组 Consumer 消费进度互不干涉</p></li><li><p>Offset：消息在 partition 内的相对位置信息，可以理解为唯一 ID，在 partition 内部严格递增</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/286K1OY8M3SLGDY7BCP4G.webp"></li></ul></li><li><p>Replica：每个分片有多个 Replica，Leader Replica 将会从 ISR 中选出</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/VEJW8PF@2QN2M6CIOU7.webp"></li></ul></li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p><img src="https://img.lonesome.cn/blog/bytedance/D8HND8S@QPRK2VLHQ2EPX3.webp"></p><h3 id="Kafka-架构"><a href="#Kafka-架构" class="headerlink" title="Kafka 架构"></a>Kafka 架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/FKJ81SZTZPAQJR376.webp"></p><h3 id="一条消息的自述"><a href="#一条消息的自述" class="headerlink" title="一条消息的自述"></a>一条消息的自述</h3><ul><li><img src="https://img.lonesome.cn/blog/bytedance/3XM6AAEWBXLAJ8PF.webp"><ul><li>从一条消息的视角，看看为什么 Kafka 能支撑这么高的吞吐？</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/NXTS0QLQVHPOWV8@MQ9Q.webp"><ul><li>如果发送一条消息，等到其成功后再发一条会有什么问题？</li></ul></li></ul><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><ul><li>批量发送<ul><li><img src="https://img.lonesome.cn/blog/bytedance/4YD6JMHGCZFAI_NS2.webp"></li><li>如果消息量很大，网络宽带不够用，如何解决？</li></ul></li><li>数据压缩<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OP507PS2_YM@MV57XY1.webp"></li></ul></li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><ul><li>数据的存储<ul><li><img src="https://img.lonesome.cn/blog/bytedance/USQOFQGQ4PGJ6W.webp"></li><li>如何存储到磁盘？</li><li>消息文件结构<ul><li><img src="https://img.lonesome.cn/blog/bytedance/6QZ60UO5Z0C00B8M@UC86.webp"></li><li>数据路径：&#x2F;Topic&#x2F;Partition&#x2F;Segment&#x2F;(log | index |timeindex | …)</li></ul></li></ul></li><li>磁盘结构<ul><li>移动磁头找到对应磁道，磁盘转动。找到对应扇区，最后写入，寻道成本比较高，因此顺序可以减少寻道所带来的时间成本</li><li><img src="https://img.lonesome.cn/blog/bytedance/D8HND8S@QPRK2VLHQ2EPX3.webp"></li></ul></li><li>顺序写<ul><li><img src="https://img.lonesome.cn/blog/bytedance/7AD4YU@XHHCUJDD9X80@OG.webp"></li><li>采用顺序写的方式进行写入，以提高写入效率</li></ul></li><li>如何找到消息<ul><li>Consumer 通过发送 FetchRequest 请求消息数据，Broker 会将指定 Offset 处的消息，按照时间窗口和消息大小窗口发送给 Consumer，<strong>寻找数据这个细节是如何做到的呢？</strong></li><li><img src="https://img.lonesome.cn/blog/bytedance/4XV_1C0X_5@HMRYXR6O.webp"></li><li>偏移量索引数据<ul><li>目标：寻找 offset &#x3D; 28</li><li><img src="https://img.lonesome.cn/blog/bytedance/4G5SK7ZFRPNYRMZFXE.webp"></li><li>二分找到小于目标 offset 的最大文件</li><li><img src="https://img.lonesome.cn/blog/bytedance/W_CRVSDH_1XJ03Y2EQ7V.webp"></li></ul></li><li>时间戳索引文件<ul><li>二分找到小于目标时间戳最大的索引位置，在通过寻找 offset 的方式找到最终数据</li><li><img src="https://img.lonesome.cn/blog/bytedance/W7E2YS7VCNJKE2WN0OM.webp"></li></ul></li></ul></li><li>传统数据拷贝<ul><li><img src="https://img.lonesome.cn/blog/bytedance/057TA64BORKKJH23OQ4J5.webp"></li></ul></li><li>零拷贝<ul><li><img src="https://img.lonesome.cn/blog/bytedance/6CCGG60GGVYWECA74X09.webp"></li></ul></li></ul><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><ul><li>消息的接收端<ul><li><img src="https://img.lonesome.cn/blog/bytedance/093Q7M1S9EQED@9.webp"></li><li>如何解决 Partition 在 Consumer Group 中的分配问题？</li></ul></li><li>Low Level<ul><li>通过手动进行分配，哪一个 Consumer 消费哪一个 Partition 完全由业务来决定</li><li><img src="https://img.lonesome.cn/blog/bytedance/S8HHQZL3C7UV8IR4I63L6.webp"></li><li>这种方式的缺点是什么？<ul><li>如果 Consumer3 挂掉了，7，8 分片就停止消费了</li><li>如果新增了一台 Consumer4 ，需要重新停掉整个集群，重新修改配置再上线，保证 Consumer4 也可以消费数据</li></ul></li></ul></li><li>High Level<ul><li><img src="https://img.lonesome.cn/blog/bytedance/D_@6EYBYRJNWATDUQNR4Q.webp"></li><li>Rebalance<ul><li><img src="https://img.lonesome.cn/blog/bytedance/3O5HWNT_WN_JILBC6I.webp"></li></ul></li></ul></li></ul><h4 id="一些可以帮-Kafka-提高吞吐或者稳定性的功能"><a href="#一些可以帮-Kafka-提高吞吐或者稳定性的功能" class="headerlink" title="一些可以帮 Kafka 提高吞吐或者稳定性的功能"></a>一些可以帮 Kafka 提高吞吐或者稳定性的功能</h4><ul><li>Producer：批量发送、数据压缩</li><li>Broker：顺序写，消息索引，零拷贝</li><li>Consumer：Reblance</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>数据复制问题<ul><li><img src="https://img.lonesome.cn/blog/bytedance/OVSR_5K56PP9IK2@8GN2.webp"></li></ul></li><li>重启操作<ul><li><img src="https://img.lonesome.cn/blog/bytedance/A3GG44EYVLU61CKC.webp"></li></ul></li><li>替换、扩容、缩容<ul><li><img src="https://img.lonesome.cn/blog/bytedance/R14137A9ZNX_31W.webp"></li></ul></li><li>负载不均衡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WCFDEY@ZHG2DFJAYK@S.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/ZMIGNAO2@KRIJKZB.webp"></li></ul></li><li>问题总结<ul><li>运维成本高</li><li>对于负载不均衡的场景，解决方案复杂</li><li>没有自己的缓存，完全依赖 Page cache</li><li>Controller 和 Coordinator 和 Broker 在同一进程中，大量 IO 会造成其性能下降</li></ul></li></ul><h2 id="消息队列-BMQ"><a href="#消息队列-BMQ" class="headerlink" title="消息队列-BMQ"></a>消息队列-BMQ</h2><h3 id="BMQ-简介"><a href="#BMQ-简介" class="headerlink" title="BMQ 简介"></a>BMQ 简介</h3><p>兼容 Kafka 协议，存算分离，云原生消息队列</p><h3 id="BMQ-介绍"><a href="#BMQ-介绍" class="headerlink" title="BMQ 介绍"></a>BMQ 介绍</h3><p><img src="https://img.lonesome.cn/blog/bytedance/CHJ3VZQO_FHB30A.webp"></p><h3 id="运维操作对比"><a href="#运维操作对比" class="headerlink" title="运维操作对比"></a>运维操作对比</h3><p><img src="https://img.lonesome.cn/blog/bytedance/UHWJ6@VNJYLSSRP3.webp"></p><h3 id="HDFS-写文件流程"><a href="#HDFS-写文件流程" class="headerlink" title="HDFS 写文件流程"></a>HDFS 写文件流程</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ZFPGPGXJE42J64@STF4.webp"></p><h3 id="BMQ-文件结构"><a href="#BMQ-文件结构" class="headerlink" title="BMQ 文件结构"></a>BMQ 文件结构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/HW_U7ZWQRBE@C_SINGUF.webp"></p><h3 id="Broker-1"><a href="#Broker-1" class="headerlink" title="Broker"></a>Broker</h3><ul><li>Partition 状态机<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@8T1TWUKNN@IUYD90D@S8R.webp"></li><li>保证对于任意分片在同一时刻只能在一个 Broker 上存活</li></ul></li><li>写文件流程<ul><li><img src="https://img.lonesome.cn/blog/bytedance/W7HZJG5W7M3DZKY_M.webp"></li></ul></li><li>写文件 Failover<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@8IVRUSE9R8XTBVB9A.webp"></li><li>如果 DataNode 节点挂了或者是其他原因导致我们写文件失败，应该如何处理？</li></ul></li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p><img src="https://img.lonesome.cn/blog/bytedance/9KPFX3ETDHRXMJY96.webp"></p><h3 id="多机房部署"><a href="#多机房部署" class="headerlink" title="多机房部署"></a>多机房部署</h3><p><img src="https://img.lonesome.cn/blog/bytedance/VA6D5LMEPCUY7PI9_Y1.webp"></p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><p><img src="https://img.lonesome.cn/blog/bytedance/@1NWYXAVF4H0S40S.webp"></p><h4 id="泳道消息"><a href="#泳道消息" class="headerlink" title="泳道消息"></a>泳道消息</h4><p><img src="https://img.lonesome.cn/blog/bytedance/JLXG@FNFN56X3P4WJ.webp"></p><ul><li>BOE：Bytedance Offline Environment，是一套完全独立的线下机房环境</li><li>PPE：Product Preview Environment，即产品预览环境</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/LASOSIY_2R0015B.webp"></p><p>多个人同时测试，需要等待上一个人测试完成</p><p><img src="https://img.lonesome.cn/blog/bytedance/Z@XGRL4Y0C93HO7LV.webp"></p><p>每多一个测试人员，都需要重新搭建一个相同配置的 Topic，造成人力和资源的浪费</p><p><img src="https://img.lonesome.cn/blog/bytedance/M37CES6P069SSVQ2S49.webp"></p><p>对于 PPE 的消费者来说，资源没有生产环境多，所以无法承受生产环境的流量</p><p><img src="https://img.lonesome.cn/blog/bytedance/2VNPY@_Z413FP_28VGZ9.webp"></p><p>解决主干泳道流量隔间问题以及泳道资源重复创建问题</p><h4 id="Databus"><a href="#Databus" class="headerlink" title="Databus"></a>Databus</h4><ul><li><img src="https://img.lonesome.cn/blog/bytedance/7R74X6ZCCAU@11RR76.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/I55_JIW_LGGLT3QHAG0.webp"></li><li>直接使用原生 SDK 会有什么问题？<ul><li>客户端配置较为复杂</li><li>不支持动态配置</li><li>对于 latency 不是很敏感的业务，batch 效率不佳</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/ABASXFFIB3RCQHA8B_D.webp"><ul><li>简化消息队列客户端复杂配置</li><li>解耦业务与 Topic</li><li>缓解集群压力，提高吞吐</li></ul></li></ul><h4 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h4><p><img src="https://img.lonesome.cn/blog/bytedance/J_JD10LJ1FC4MRDRDJ.webp"></p><p>是否可以通过多机房部署的方式，解决跨 Region 读写的问题？</p><p><img src="https://img.lonesome.cn/blog/bytedance/XWO3_2YP755F1CJ.webp"></p><p>使用 Mirror 通过最终一致的方式，解决跨 Region 读写问题</p><h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><p><img src="https://img.lonesome.cn/blog/bytedance/@DWWONC1L_QQNA77ZR8D.webp"></p><p>如果希望通过写入的 LogId、UserId 或者其他的业务字段进行消费的查询，应该怎么做？</p><p><img src="https://img.lonesome.cn/blog/bytedance/LJJ59FDWF379YIIXOK7.webp"></p><p>直接在 BMQ 中将数据结构化，配置索引 DDL，异步构建索引后，通过 Index Query 服务读出数据</p><h4 id="Parquet"><a href="#Parquet" class="headerlink" title="Parquet"></a>Parquet</h4><p>Apache Parquet 是 Hadoop 生态圈中一钟<strong>新型列式存储格式</strong>，它可以兼容 Hadoop 生态圈中大多数计算框架（Hadoop、Spark 等），被多种查询引擎支持（Hive、Impala、Drill 等）</p><p><img src="https://img.lonesome.cn/blog/bytedance/OUULDVHM2Z1FWC5ZGPI.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/CK4@N2YJIFBZ2MPGM.webp"></p><p>直接在 BMQ 中将数据结构化，通过 Parquet Engine，可以使用不同的方式构建 Parquet 格式文件</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>BMQ 的架构模型（解决 Kafka 存在的问题）</li><li>BMQ 读写流程（Failover 机制，写入状态机）</li><li>BMQ 高级特性（泳道、Databus、Mirror、Index、Parquet）</li></ul><h2 id="消息队列-RocketMQ"><a href="#消息队列-RocketMQ" class="headerlink" title="消息队列-RocketMQ"></a>消息队列-RocketMQ</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>例如，针对电商业务线，其业务涉及广泛，如注册、订单、库存、物流等；同时，也会涉及许多业务峰值时刻，如秒杀活动、周年庆、定期特惠等</p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ZHWCSJUGX9XVS2@WAOE.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/8P8TRU0I9XVJCZMAYA52E.webp"></p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://img.lonesome.cn/blog/bytedance/KPRO441WIKN160T0D.webp"></p><h3 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h3><p><img src="https://img.lonesome.cn/blog/bytedance/0E2QDIH1YRNIR@UYR2JX.webp"></p><h3 id="高级特性-1"><a href="#高级特性-1" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="事务场景"><a href="#事务场景" class="headerlink" title="事务场景"></a>事务场景</h4><p><img src="https://img.lonesome.cn/blog/bytedance/5U2YX97HQZ2XH_0J4.webp"></p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p><img src="https://img.lonesome.cn/blog/bytedance/3W_1D3JCQ9GWE6_26X.webp"></p><h4 id="延迟发送"><a href="#延迟发送" class="headerlink" title="延迟发送"></a>延迟发送</h4><p><img src="https://img.lonesome.cn/blog/bytedance/B51TNYQNU6DU77DGS.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/@DZB8W8FMY3SHQH4G6.webp"></p><h4 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h4><p><img src="https://img.lonesome.cn/blog/bytedance/HNYRRDHCLDM9_XUX4.webp"></p><h4 id="处理失败"><a href="#处理失败" class="headerlink" title="处理失败"></a>处理失败</h4><p><img src="https://img.lonesome.cn/blog/bytedance/7BWP4NK3CRUU51HX3.webp"></p><p>该如何处理失败的消息呢？</p><h4 id="消费重试和死信队列"><a href="#消费重试和死信队列" class="headerlink" title="消费重试和死信队列"></a>消费重试和死信队列</h4><p><img src="https://img.lonesome.cn/blog/bytedance/MKD1TP@4NWNWDQCKTBK.webp"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>RocketMQ 的基本概念（Queue、Tag）</li><li>RocketMQ 的底层原理（架构模型、存储模型）</li><li>RocketMQ 的高级特性（事务消息、重试和死信队列、延迟队列）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;案例一：系统崩溃&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="消息队列" scheme="https://lonesome.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式定时任务</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/distributed-scheduled-tasks/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/distributed-scheduled-tasks/</id>
    <published>2023-02-08T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:20.452Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.lonesome.cn/blog/bytedance/TA47SKRT9ATJC9J.webp"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="春节集卡瓜分-20-亿"><a href="#春节集卡瓜分-20-亿" class="headerlink" title="春节集卡瓜分 20 亿"></a>春节集卡瓜分 20 亿</h3><p>作为后端开发同学，怎样设计最终开奖环节技术方案？</p><ul><li>业务流程<ul><li>定时扫描抖音用户集卡状态</li><li>汇总计算用户的瓜分金额</li><li>定时开奖</li><li><img src="https://img.lonesome.cn/blog/bytedance/MGBJSUYLQLJYPH9E.webp"></li></ul></li><li>技术体量<ul><li>亿级用户规模</li><li>十亿级资金规模</li><li>百万级读写 QPS</li></ul></li><li>方案引出<ul><li>自动化 + 定时执行 + 海量数据 + 高效稳定 &#x3D; 分布式定时任务</li></ul></li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><h4 id="Windows-批处理"><a href="#Windows-批处理" class="headerlink" title="Windows 批处理"></a>Windows 批处理</h4><ul><li>Case 1：10 分钟后 Windows 电脑自动关机<ul><li>Step1：桌面空白处右键单机-新建-文本文档</li><li>Step2：更改文件名和后缀为”自动关机.bat“</li><li>Step3：修改文件内容为”Shutdown -s -t 600“，代表 10 分钟后关机</li><li>Step4：双击运行该批处理文件，电脑将会在 10 分钟之后自动关机</li></ul></li></ul><h4 id="Windows-任务计划程序"><a href="#Windows-任务计划程序" class="headerlink" title="Windows 任务计划程序"></a>Windows 任务计划程序</h4><ul><li>Case 2：每天 12:00 自动疫情打卡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/SZ5YULJLKZ7E64FK2F.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/X3HAUS8LIBA8OISZTNBIBG.webp"></li></ul></li></ul><h4 id="Linux-命令-CronJob"><a href="#Linux-命令-CronJob" class="headerlink" title="Linux 命令-CronJob"></a>Linux 命令-CronJob</h4><ul><li>Case 3：每天 02:30 定时清理机器日志<ul><li><img src="https://img.lonesome.cn/blog/bytedance/JT2_IQ36M2M@ZHX69L0.webp"></li></ul></li><li>Linux 系统命令，使用简单，稳定可靠</li><li>只能控制单台机器，且无法适用于其他操作系统</li></ul><h4 id="单机定时任务-Timer、Ticker"><a href="#单机定时任务-Timer、Ticker" class="headerlink" title="单机定时任务-Timer、Ticker"></a>单机定时任务-Timer、Ticker</h4><ul><li>Case 4：每隔 5 分钟定时刷新本地缓存数据<ul><li><img src="https://img.lonesome.cn/blog/bytedance/ED3OX5C4ON7U617DKN.webp"></li></ul></li><li>跨平台</li><li>仅单机可用</li></ul><h4 id="单机定时任务-ScheduledExecutorService"><a href="#单机定时任务-ScheduledExecutorService" class="headerlink" title="单机定时任务-ScheduledExecutorService"></a>单机定时任务-ScheduledExecutorService</h4><ul><li>case 5：每隔 5 分钟定时执行多个任务<ul><li><img src="https://img.lonesome.cn/blog/bytedance/WQ7PHSVWBK6KJ60.webp"></li></ul></li><li>拥有线程池功能</li><li>仅单机可用</li></ul><h4 id="任务调度-Quartz"><a href="#任务调度-Quartz" class="headerlink" title="任务调度-Quartz"></a>任务调度-Quartz</h4><ul><li><img src="https://img.lonesome.cn/blog/bytedance/R8GZNHFKH2NHC52O.webp"></li><li>单任务极致控制</li><li>没有负载均衡机制</li></ul><h4 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h4><ul><li><img src="https://img.lonesome.cn/blog/bytedance/QP9PWR4XGECU4HVOX9UTT.webp"></li><li>平台化管理</li><li>分布式部署</li><li>支持海量数据</li></ul><h3 id="分布式定时任务-1"><a href="#分布式定时任务-1" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h3><ul><li>定义<ul><li>定时任务是指系统为了<strong>自动</strong>完成特定任务，<strong>实时、延时、周期</strong>性完成任务调度的过程</li><li>分布式定时任务是把分散的、可靠性差的定时任务纳入统一的<strong>平台</strong>，并实现集群管理调度和<strong>分布式部署</strong>的一种定时任务的管理方式</li></ul></li><li>按触发时机分类<ul><li>定时任务：特定时间触发，比如今天 15:06 执行</li><li>延时任务：延时触发，比如 10s 后执行</li><li>周期任务：固定周期时间，或固定频率周期调度触发，比如每天 12 点或者每隔 5 秒执行</li></ul></li><li>特点<ul><li>自动化：全自动完成定时任务的调度和执行</li><li>平台化：基于平台化的思维管控一系列的分布式定时任务</li><li>分布式：在分布式系统环境下运行任务调度，突破单机定时任务的性能瓶颈</li><li>伸缩性：采用集群方式部署，可以随时按需扩容</li><li>高可用：单点故障不影响最终任务结果，可以做到故障转移</li></ul></li><li>执行方式<ul><li>单机任务：随机触发一台机器执行任务，适用于计算量小，并发度低的任务</li><li>广播任务：广播到所有机器上执行同一个任务，比如所有机器一起清理日志</li><li>Map 任务：一个任务可以分出多个子任务，每个子任务负责一部分的计算，适用于计算量大，单机无法满足要求的任务</li><li>MapReduce 任务：在 Map 任务的基础上，还可以对所有子任务的结果做汇总计算，适用于计算量大，并且需要对子任务结果做汇总的任务</li></ul></li><li>执行方式 vs 春节集卡<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5R5MFKYTZ@K8ANYH59X.webp"></li><li>发奖金额计算：MapReduce 任务</li><li>定时开奖：Map 任务</li></ul></li></ul><h3 id="业内定时任务框架"><a href="#业内定时任务框架" class="headerlink" title="业内定时任务框架"></a>业内定时任务框架</h3><p><img src="https://img.lonesome.cn/blog/bytedance/64QFGN7MCCMJ1O1TOM.webp"></p><h3 id="知识面扩充"><a href="#知识面扩充" class="headerlink" title="知识面扩充"></a>知识面扩充</h3><ul><li>分布式定时任务 VS 单机定时任务<ul><li>关系：<ul><li>都可以实现自动化的定时、延时、周期任务调度</li></ul></li><li>差异：<ul><li>分布式定时任务可支撑更大的业务体量</li><li>分布式定时任务的性能、伸缩性、稳定性更高</li></ul></li></ul></li><li>分布式定时任务 VS 大数据处理引擎<ul><li>关系：<ul><li>都可以对海量数据做处理</li><li>性能、伸缩性、稳定性都很高</li></ul></li><li>差异：<ul><li>定时并不是大数据处理引擎要解决的核心问题</li><li>大数据引擎往往致力于将源数据处理成结果数据，分布式定时任务除了能做这个之外，还可以调用 HTTP 和 RPC 服务</li></ul></li></ul></li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h3><ul><li>分布式定时任务核心要解决<strong>触发、调度、执行</strong>三个关键问题<ul><li>触发器：Trigger，解析任务，生成触发事件</li><li>调度器：Scheduler，分配任务，管理任务生命周期</li><li>执行器：Executor，获取执行任务单元，执行任务逻辑</li></ul></li><li>除此之外，还需要提供一个控制台（Admin），提供任务管理和干预的功能</li><li><img src="https://img.lonesome.cn/blog/bytedance/OLPVDY8PGYWJCCGKNJV.webp"></li></ul><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><img src="https://img.lonesome.cn/blog/bytedance/EX6TV723_J6_FPT6.webp"></p><h4 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h4><p><img src="https://img.lonesome.cn/blog/bytedance/6_VS9ICP60G339TSQ9A.webp"></p><h3 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://img.lonesome.cn/blog/bytedance/LGVA7U787LTEVLN54.webp"></p><ul><li>任务：Job，任务元数据</li><li>任务实例：JobInstance，任务运行的实例</li><li>任务结果：JobResult，任务实例运行的结果</li><li>任务历史：JobHistory，用户可以修改任务信息，任务实例对应的任务元数据可以不同，因而使用任务历史存储</li></ul><h4 id="任务元数据"><a href="#任务元数据" class="headerlink" title="任务元数据"></a>任务元数据</h4><p>任务元数据（Job）是用户对任务属性定义，包括任务类型调度时机、执行行为等</p><p><img src="https://img.lonesome.cn/blog/bytedance/CVDXZGXR3E3W3YGAJZ4C.webp"></p><h4 id="任务实例"><a href="#任务实例" class="headerlink" title="任务实例"></a>任务实例</h4><p>任务实例（JobInstance）是一个确定的 Job 的一次运行实例</p><p><img src="https://img.lonesome.cn/blog/bytedance/KF1BI338ET_EB@FN5.webp"></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="核心职责"><a href="#核心职责" class="headerlink" title="核心职责"></a>核心职责</h4><ul><li>核心职责<ul><li>给定一系列任务，解析他们的触发规则，在规定的时间点触发任务的调度</li></ul></li><li>设计约束<ul><li>需支持大量任务</li><li>需支持秒级的调度</li><li>周期任务需要多次执行</li><li>需保证秒级扫描的高性能，并避免资源浪费</li></ul></li></ul><h4 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h4><p>定期扫描+延时消息（腾讯、字节方案）</p><p><img src="https://img.lonesome.cn/blog/bytedance/D11EH7LT2CTL8F3Y3M.webp"></p><h4 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 2"></a>方案 2</h4><ul><li>时间轮（Quartz 所用方案）<ul><li>时间轮是一种高效利用线程资源进行批量化调度的一种调度模型，时间轮是一个存储环形队列，底层采用数组实现，数组中的每个元素可以存放一个定时任务列表</li><li><img src="https://img.lonesome.cn/blog/bytedance/A7@LBZU6LPHTC_T.webp"></li></ul></li><li>目标：遍历任务列表，从中找出当前时间点需触发的任务列表<ul><li><img src="https://img.lonesome.cn/blog/bytedance/9K64MWXYGAO3840A28.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/S1SBMGXBJ@RWMBB@GU.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/8GCFM9_WGQA7KA6Z9ZCYP.webp"></li><li><img src="https://img.lonesome.cn/blog/bytedance/34O3J5MAAFV8UINROQ33.webp"></li></ul></li></ul><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul><li>核心问题<ul><li>不同业务之间，任务的调度相互影响怎么办</li><li>负责扫描和触发的机器挂了怎么办</li></ul></li><li>解法思路<ul><li>存储上，不同国别、业务做资源隔离</li><li>运行时，不同国别、业务分开执行</li><li>部署时，采用多机房集群化部署，避免单点故障，通过数据库锁或分布式锁保证任务只被触发一次</li></ul></li></ul><h5 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h5><ul><li>单 Trigger 模式：<ul><li>会有单点故障</li><li>机器故障时平台崩溃</li></ul></li><li>Trigger 集群模式<ul><li>可避免单点故障</li><li>需要避免同一任务被多次触发，导致业务紊乱</li></ul></li></ul><h5 id="数据库行锁模式"><a href="#数据库行锁模式" class="headerlink" title="数据库行锁模式"></a>数据库行锁模式</h5><p>在触发调度之前，更新数据库中 JobInstance 的状态，成功枪锁才会触发调度</p><p><img src="https://img.lonesome.cn/blog/bytedance/7VTLV50RVFNX0CJ5W.webp"></p><h5 id="分布式锁模式"><a href="#分布式锁模式" class="headerlink" title="分布式锁模式"></a>分布式锁模式</h5><p>在触发调度之前，尝试抢占分布式锁，可使用 Redis 锁或 Zookeeper 锁</p><p><img src="https://img.lonesome.cn/blog/bytedance/R4CR9NPF34OBG2I@5O.webp"></p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><h4 id="资源来源"><a href="#资源来源" class="headerlink" title="资源来源"></a>资源来源</h4><ul><li>业务系统提供机器资源<ul><li>使用该方案的公司：<ul><li>阿里、美团、字节等</li></ul></li><li>优点：<ul><li>任务执行逻辑与业务系统共用同一份资源，利用率更高</li></ul></li><li>缺点：<ul><li>更容易发生定时任务脚本影响在线服务的事故</li><li>不能由定时任务平台控制扩缩容</li></ul></li></ul></li><li>定时任务平台提供机器资源<ul><li>使用该方案的公司：<ul><li>字节等</li></ul></li><li>优点：<ul><li>任务执行逻辑与业务系统提供的在线服务隔离，避免相互影响</li><li>可以支持优雅的扩缩容</li></ul></li><li>缺点：<ul><li>消耗更多机器资源</li><li>需要额外为定时任务平台申请接口调用权限，而不能直接继承业务系统的权限</li></ul></li></ul></li></ul><h4 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h4><h5 id="节点选择"><a href="#节点选择" class="headerlink" title="节点选择"></a>节点选择</h5><ul><li>随机节点执行：选择集群中一个可用的执行节点执行调度任务，使用场景：定时对账</li><li>广播执行：在集群中所有的执行节点发布调度任务并执行，使用场景：批量运维</li><li>分片执行：按照用户自定义分片逻辑进行拆分，分发到集群中不同节点并行执行，提升资源利用效率，使用场景：海量日志统计</li><li><img src="https://img.lonesome.cn/blog/bytedance/RSVLTIXK7ZX6I0TJ.webp"></li></ul><h5 id="任务分片"><a href="#任务分片" class="headerlink" title="任务分片"></a>任务分片</h5><p>通过任务分片来提高任务执行的效率和资源的利用率</p><p><img src="https://img.lonesome.cn/blog/bytedance/GCLAZMMRO9SNLP6HD.webp"></p><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="任务编排"><a href="#任务编排" class="headerlink" title="任务编排"></a>任务编排</h5><p>使用有向无环图 DAG（Directed Acyclic Graph）进行可视化任务编排</p><p><img src="https://img.lonesome.cn/blog/bytedance/FV@XQFCN@SGRI3BFN87.webp"></p><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>确保部分执行单元任务失败时，任务最终成功</p><p><img src="https://img.lonesome.cn/blog/bytedance/1AVE3LTALJUEW72LV.webp"></p><h4 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h4><p>调度器可以集群部署，做到完全的无状态，靠消息队列的重试机制保障任务一定会被调度</p><p><img src="https://img.lonesome.cn/blog/bytedance/RAA8KQGL2H6WOTDSF8D.webp"></p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p><img src="https://img.lonesome.cn/blog/bytedance/AVT7EV6H0HM2WCWMVUF.webp"></p><h2 id="业务应用"><a href="#业务应用" class="headerlink" title="业务应用"></a>业务应用</h2><p>所有需要定时、延时、周期性执行任务的业务场景，都可以考虑使用分布式定时任务</p><p><img src="https://img.lonesome.cn/blog/bytedance/QFXRMYKHS1K7MBBC2.webp"></p><ul><li>其他解决方案<ul><li>发货后超过 10 天未收货时系统自动确认收货<ul><li>使用分布式定时任务的延时任务</li><li>使用消息队列的延时消息或者定时消息</li></ul></li><li>春节集卡活动统计完成集卡的用户个数和总翻倍数<ul><li>使用分布式定时任务的 MapReduce 任务</li><li>使用大数据离线处理引擎 Hive 离线做统计</li><li>使用大数据实时处理引擎 Fink 实时做累计</li></ul></li></ul></li><li>其他解决方案对比<ul><li><img src="https://img.lonesome.cn/blog/bytedance/32P8O53OK29@RWQF.webp"></li></ul></li></ul><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><p><img src="https://img.lonesome.cn/blog/bytedance/XX1QFS7QKKZKVDAAB62.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/bytedance/TA47SKRT9ATJC9J.webp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="分布式" scheme="https://lonesome.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>黑灰产监控与防御</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/black-and-gray-production-monitoring-and-defense/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/black-and-gray-production-monitoring-and-defense/</id>
    <published>2023-02-06T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:20.782Z</updated>
    
    <content type="html"><![CDATA[<p>了解一些国内黑灰产的调研报告，推荐<a href="https://search.freebuf.com/search/?search=%E9%BB%91%E9%95%9C%E8%B0%83%E6%9F%A5#article">Freebuf 黑镜调查系列</a></p><h2 id="国内黑产介绍"><a href="#国内黑产介绍" class="headerlink" title="国内黑产介绍"></a>国内黑产介绍</h2><ul><li>一些常见的黑产<ul><li><img src="https://img.lonesome.cn/blog/bytedance/PQF0UCBE4NHSZZSNUK.webp"></li></ul></li><li>黑色产业链规模<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0EHS05Q6BNFI1ADBPICW.webp"></li></ul></li><li>黑色产业链结构（部分）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/72BU@KJAZ76K6W2JD.webp"></li></ul></li><li>黑产团伙的发展趋势<ul><li>规模化<ul><li>借助脚本、软件来实现攻击的批量化</li><li>上游各类资源丰富，大大降低攻击成本，同时攻击成功率也比较高</li></ul></li><li>组织化<ul><li>多数以工作室的形式运作</li><li>团伙内多人分工明确，合作紧密</li><li>某些黑产甚至成立了公司</li></ul></li><li>平台化<ul><li>今年来出现了很多平台级的爬虫、群控、钓鱼、木马、网络攻击、DDOS 攻击工具，攻击成本大大降低，且难以追查</li><li>各类平台将黑产手中零散的资源进行整合</li></ul></li></ul></li></ul><h2 id="常见的黑产技术分析"><a href="#常见的黑产技术分析" class="headerlink" title="常见的黑产技术分析"></a>常见的黑产技术分析</h2><ul><li>2018 年某银行业务逻辑漏洞（已修复）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/8SWPQDLIM1BBQ8@E9.webp"></li></ul></li><li>人脸识别对抗<ul><li>从照片到 3D 人脸模型</li></ul></li><li>地理位置对抗<ul><li>定位打卡</li><li>摇一摇附近的人</li><li>出租车抢单</li><li>某些线下使用的优惠</li><li>……</li></ul></li></ul><h2 id="安全防护体系的建设"><a href="#安全防护体系的建设" class="headerlink" title="安全防护体系的建设"></a>安全防护体系的建设</h2><ul><li>事前<ul><li>情报监控<ul><li>暗网</li><li>贴吧</li><li>TG</li><li>破解论坛</li></ul></li><li>SDLC</li><li>漏洞扫描</li></ul></li><li>事中<ul><li>渗透测试</li><li>威胁感知<ul><li>用户行为异常</li><li>接口数据异常</li><li>恶意流量检测</li></ul></li><li>风控&#x2F;安全策略</li></ul></li><li>事后<ul><li>威胁建模</li><li>攻击溯源</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/W7RVP3SLEJH4Y7FKG.webp"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解一些国内黑灰产的调研报告，推荐&lt;a href=&quot;https://search.freebuf.com/search/?search=%E9%BB%91%E9%95%9C%E8%B0%83%E6%9F%A5#article&quot;&gt;Freebuf 黑镜调查系列&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="黑灰产" scheme="https://lonesome.cn/tags/%E9%BB%91%E7%81%B0%E4%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你做系统设计</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/teach-you-step-by-step-how-to-do-system-design/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/teach-you-step-by-step-how-to-do-system-design/</id>
    <published>2023-02-05T06:45:00.000Z</published>
    <updated>2024-08-09T17:53:18.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统设计方法论"><a href="#系统设计方法论" class="headerlink" title="系统设计方法论"></a>系统设计方法论</h2><ul><li>为什么要做系统设计<ul><li>个人<ul><li>For 面试</li><li>个人能力提升</li><li>拓展技术视野</li></ul></li><li>工作<ul><li>业务驱动</li><li>系统重构</li><li>突破和创新</li></ul></li></ul></li><li>如何评估一个系统<ul><li>可用性</li><li>安全性</li><li>扩展性</li><li>易用性</li><li>性能</li><li>耦合性</li><li>可维护性</li><li>伸缩性</li></ul></li><li>系统设计的定义：为了达成某种目的，通过个体组成整体的过程<ul><li>系统<ul><li>关联的个体</li><li>规则运作</li><li>组成工作的整体</li></ul></li><li>设计<ul><li>设想和计划</li><li>目的</li><li>过程安排</li></ul></li></ul></li><li>如何做系统设计：4S 分析法<ul><li>场景分析（Scenario）<ul><li>什么系统，需要哪些功能，多大的并发量</li></ul></li><li>存储设计（Storage）<ul><li>数据如何组织，Sql 存储，NoSql 存储</li></ul></li><li>服务设计（Service）<ul><li>业务功能实现和逻辑整合</li></ul></li><li>可扩展性（Scale）<ul><li>解决设计缺陷，提高鲁棒性、扩展性</li></ul></li></ul></li><li>如何发现系统的瓶颈<ul><li>火焰图分析</li><li>链路分析</li><li>性能测试</li></ul></li><li>如何保证可用性和稳定性<ul><li>链路梳理<ul><li>核心链路</li><li>流量漏斗</li><li>强弱依赖</li></ul></li><li>可观测性<ul><li>链路追踪</li><li>核心监控</li><li>业务报警</li></ul></li><li>全链路测试<ul><li>压力测试</li><li>负载测试</li><li>容量测试</li></ul></li><li>稳定性控制<ul><li>系统限流</li><li>业务兜底</li><li>熔断降级</li></ul></li><li>容灾演练<ul><li>混沌工程</li><li>应急手册</li><li>容灾预案</li></ul></li></ul></li></ul><h2 id="电商秒杀业务介绍"><a href="#电商秒杀业务介绍" class="headerlink" title="电商秒杀业务介绍"></a>电商秒杀业务介绍</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="电商介绍"><a href="#电商介绍" class="headerlink" title="电商介绍"></a>电商介绍</h4><p><img src="https://img.lonesome.cn/blog/bytedance/XKGUUOTKT8NA4A06N.webp"></p><ul><li>商品：具有交易价值和属性的信息载体<ul><li>SPU：Standard Product Unit</li><li>SKU：Stock Keeping Unit</li></ul></li></ul><h4 id="秒杀业务的特点"><a href="#秒杀业务的特点" class="headerlink" title="秒杀业务的特点"></a>秒杀业务的特点</h4><ul><li>瞬时流量高</li><li>读多写少</li><li>实时性要求高</li></ul><h4 id="秒杀的挑战"><a href="#秒杀的挑战" class="headerlink" title="秒杀的挑战"></a>秒杀的挑战</h4><ul><li>资源成本</li><li>反欺诈</li><li>高性能</li><li>防止超卖</li><li>流量管控</li><li>扩展性</li><li>鲁棒性</li></ul><h3 id="设计秒杀系统"><a href="#设计秒杀系统" class="headerlink" title="设计秒杀系统"></a>设计秒杀系统</h3><h4 id="场景（Scenario）"><a href="#场景（Scenario）" class="headerlink" title="场景（Scenario）"></a>场景（Scenario）</h4><ul><li>功能：<ul><li>秒杀活动发布</li><li>秒杀商品详情</li><li>秒杀下单</li></ul></li><li>并发：<ul><li>万人参与秒杀</li><li>QPS 1w+</li><li>TPS 1k+</li></ul></li></ul><h4 id="存储（Storage）"><a href="#存储（Storage）" class="headerlink" title="存储（Storage）"></a>存储（Storage）</h4><p><img src="https://img.lonesome.cn/blog/bytedance/0QX@JTYT8E5Z9TN5HN9.webp"></p><p><img src="https://img.lonesome.cn/blog/bytedance/TKWSFL80BPXDG4_Y3.webp"></p><h4 id="服务（Service）"><a href="#服务（Service）" class="headerlink" title="服务（Service）"></a>服务（Service）</h4><ul><li>子服务：<ul><li>用户服务</li><li>风控服务</li><li>活动服务</li><li>订单服务</li></ul></li><li>基础组件：<ul><li>ID 生成器</li><li>缓存组件</li><li>MQ 组件</li><li>限流组件</li></ul></li></ul><h4 id="扩展（Scale）"><a href="#扩展（Scale）" class="headerlink" title="扩展（Scale）"></a>扩展（Scale）</h4><ul><li><p>流量隔离</p></li><li><p>CDN</p></li><li><p>缓存优化</p></li><li><p>流量管控</p></li><li><p>数据库扩展</p></li><li><p>MQ 扩展</p></li><li><p>Redis 扩展</p></li><li><p>服务水平扩展</p></li><li><p>服务垂直扩展</p></li></ul><h3 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h3><p><img src="https://img.lonesome.cn/blog/bytedance/37HT__8L5KBK0QNKM.webp"></p><h2 id="课程实践"><a href="#课程实践" class="headerlink" title="课程实践"></a>课程实践</h2><h3 id="秒杀流程图"><a href="#秒杀流程图" class="headerlink" title="秒杀流程图"></a>秒杀流程图</h3><p><img src="https://img.lonesome.cn/blog/bytedance/2HMS_D0G7GDQ4VMY1XY2L.webp"></p><h3 id="代码链接"><a href="#代码链接" class="headerlink" title="代码链接"></a><a href="https://internal-api-lark-file.feishu.cn/download/messages/7196503700680114177/keys/file_v2_99ca82a6-d1fa-43e6-b932-4cd24725a6fg?chat_id=7184255753627238404">代码链接</a></h3><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p><img src="https://img.lonesome.cn/blog/bytedance/1ORP2EYUSZ5@SW0B2BT.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统设计方法论&quot;&gt;&lt;a href=&quot;#系统设计方法论&quot; class=&quot;headerlink&quot; title=&quot;系统设计方法论&quot;&gt;&lt;/a&gt;系统设计方法论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么要做系统设计&lt;ul&gt;
&lt;li&gt;个人&lt;ul&gt;
&lt;li&gt;For 面试&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="系统设计" scheme="https://lonesome.cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>微服务框架——不变的基建</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/microservice-framework--immutable-infrastructure/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/microservice-framework--immutable-infrastructure/</id>
    <published>2023-02-04T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:19.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务架构介绍"><a href="#微服务架构介绍" class="headerlink" title="微服务架构介绍"></a>微服务架构介绍</h2><h3 id="系统架构演变历史"><a href="#系统架构演变历史" class="headerlink" title="系统架构演变历史"></a>系统架构演变历史</h3><ul><li>为什么系统架构需要演进？<ul><li>互联网的爆炸性发展</li><li>硬件设施的快速发展</li><li>需求复杂性的多样化</li><li>开发人员的急剧增加</li><li>计算机理论及技术的发展</li></ul></li><li>单体架构——all in one process<ul><li>优势：<ul><li>性能最高</li><li>冗余小</li></ul></li><li>劣势：<ul><li>debug 困难</li><li>模块相互影响</li><li>模块分工、开发流程</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/R6@2CVRSZT59ALDCOU.webp"></li></ul></li><li>垂直应用架构——按照业务线垂直划分<ul><li>优势：<ul><li>业务独立开发维护</li></ul></li><li>劣势：<ul><li>不同业务存在冗余</li><li>每个业务还是单体</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/U1RDLA5T2E_IRJ3O8F.webp"></li></ul></li><li>分布式架构——抽出与业务无关的公共模块<ul><li>优势：<ul><li>业务无关的独立服务</li></ul></li><li>劣势：<ul><li>服务模块 bug 可导致全站瘫痪</li><li>调用关系复杂</li><li>不同服务冗余</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/062KVW78B_VU5TLH6IRB.webp"></li></ul></li><li>SOA 架构——面向服务<ul><li>优势：<ul><li>服务注册</li></ul></li><li>劣势：<ul><li>整个系统设计是中心化的</li><li>需要从上至下设计</li><li>重构困难</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/3K0@80O6G4HN74D6P5QN.webp"></li></ul></li><li>微服务架构——彻底的服务化<ul><li>优势：<ul><li>开发效率</li><li>业务独立设计</li><li>自上而下</li><li>故障隔离</li></ul></li><li>劣势：<ul><li>治理、运维难度</li><li>观测挑战</li><li>安全性</li><li>分布式系统</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/FXDG@AA_N5XX1LC3AZPY.webp"></li></ul></li></ul><h3 id="微服务架构概览"><a href="#微服务架构概览" class="headerlink" title="微服务架构概览"></a>微服务架构概览</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ENRZA6M65BMDKURKZ9G.webp"></p><h3 id="微服务架构核心要素"><a href="#微服务架构核心要素" class="headerlink" title="微服务架构核心要素"></a>微服务架构核心要素</h3><ul><li>服务治理<ul><li>服务注册</li><li>服务发现</li><li>负载均衡</li><li>扩缩容</li><li>流量治理</li><li>稳定性治理</li></ul></li><li>可观测性<ul><li>日志采集</li><li>日志分析</li><li>监控打点</li><li>监控大盘</li><li>异常报警</li><li>链路追踪</li></ul></li><li>安全<ul><li>身份验证</li><li>认证授权</li><li>访问令牌</li><li>审计</li><li>传输加密</li><li>黑产攻击</li></ul></li></ul><h2 id="微服务架构原理及特征"><a href="#微服务架构原理及特征" class="headerlink" title="微服务架构原理及特征"></a>微服务架构原理及特征</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://img.lonesome.cn/blog/bytedance/FR73N095CQK69CUP2KI2.webp"></p><ul><li><p>服务（service）</p><ul><li>一组具有相同逻辑的运行实体</li></ul></li><li><p>实例（instance）</p><ul><li>一个服务中，每个运行实体即为一个实例</li></ul></li><li><p>实例与进程的关系</p><ul><li>实例与进程之间没有必然对应关系，一个实例可以对应一个或多个进程（反之不常见）</li></ul></li><li><p>集群（cluster）</p><ul><li>通常指服务内部的逻辑划分，包含多个实例</li></ul></li><li><p>常见的实例承载形式</p><ul><li>进程、VM、k8s pod……</li></ul></li><li><p>有状态&#x2F;无状态服务</p><ul><li>服务的实例是否存储了可持久化的数据（例如磁盘文件）</li></ul></li><li><p>服务间通信</p><ul><li><img src="https://img.lonesome.cn/blog/bytedance/MCN5BDNTUQFNGBM0NJ.webp"></li><li>对于单体服务，不同模块通信只是简单的函数调用</li><li>对于微服务，服务间通信意味着网络传输</li></ul></li></ul><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ul><li>问题：在代码层面，如何指定调用一个目标服务的地址（ip:port）？<ul><li>直接指定 ip:port？<ul><li>没有任何动态能力</li><li>有多个实例下游实例怎么办？</li><li><img src="https://img.lonesome.cn/blog/bytedance/3V8VYAV9VWNAJZ7KCHQ3K.webp"></li></ul></li><li>使用 DNS？<ul><li>本地 DNS 存在缓存，导致延迟</li><li>负载均衡问题</li><li>不支持服务探活检查</li><li>域名无法配置端口</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/0XZJ8RXGPBJUTU1.webp"></li></ul></li><li>解决思路：新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系<ul><li><img src="https://img.lonesome.cn/blog/bytedance/@SGJW22462BDA0IYR.webp"></li></ul></li><li>服务实例上线及下线过程<ul><li>旧服务实例下线前，从服务注册中心删除该实例，下线流量<ul><li><img src="https://img.lonesome.cn/blog/bytedance/UD32_66BL0QVWZ532N.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/9QMFE_AYS8IUGFD94.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/ZVJ@QNMW12CBNIS7FG0.webp"></li></ul></li><li>新服务实例上线后，在服务注册中心注册该实例，上线流量<ul><li><img src="https://img.lonesome.cn/blog/bytedance/H_ABI@U0AUVMV9RIY.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/DAY68SDJE@@5XV0Z8TV6RD.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/ONAXOM4H1ZCKLPZNRT.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/GEJ6PLBJZYB_046ZY.webp"></li></ul></li></ul></li></ul><h3 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h3><p><img src="https://img.lonesome.cn/blog/bytedance/VDCHYBB2_LXFPIKGJW.webp"></p><ul><li>统一网关入口</li><li>内网通信多数采用 RPC（Thrift, gRPC）</li><li>网状调用链路</li></ul><h2 id="核心服务治理功能"><a href="#核心服务治理功能" class="headerlink" title="核心服务治理功能"></a>核心服务治理功能</h2><h3 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h3><ul><li>服务发布（deployment）<ul><li>让一个服务升级运行新的代码的过程</li></ul></li><li>服务发布的难点<ul><li>服务不可用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/PMUO0XF3M67EMMJVS8.webp"></li></ul></li><li>服务抖动<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0MCMI_DVFP81D_BQX8K_B.webp"></li></ul></li><li>服务回滚<ul><li><img src="https://img.lonesome.cn/blog/bytedance/54_SE96I__CPON_XE018.webp"></li></ul></li></ul></li><li>蓝绿部署<ul><li>将服务分成两个部分，分别先后发布</li><li>简单、稳定</li><li>但需要两倍资源</li><li><img src="https://img.lonesome.cn/blog/bytedance/MB848D_15@LEWOZ2MD0S.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/3VGWLFTYV6J_1KHS_QNA.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/VF5SY31LX1OVD4ZMT8.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/WB8IJA@2VA99A7DIC.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/2KFOQU67PR@05NIO7MD1.webp"><br><img src="https://img.lonesome.cn/blog/bytedance/PHM6_QTXWPTRANNM.webp"></li></ul></li><li>灰度发布（金丝雀发布）<ul><li>先发布少部分实例，接着逐步增加发布比例</li><li>不需要增加资源</li><li>回滚难度大，基础设施要求高</li><li><img src="https://img.lonesome.cn/blog/bytedance/IS0E@XJR9I4C5H1YJ4W.webp"></li></ul></li></ul><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><p>在微服务架构中，可以基于地区、集群、实例、请求等维度，对端到端流量的路由路径进行精确控制</p><p><img src="https://img.lonesome.cn/blog/bytedance/SVBCLW1BA7HR_O_2QEE.webp"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>负载均衡（Load Balance）负责分配请求在每个下游实例上的分布<ul><li><img src="https://img.lonesome.cn/blog/bytedance/Q5YI_AIGKATKNAS4_BM.webp"></li></ul></li><li>常见的 LB 策略<ul><li>Round Robin</li><li>Random</li><li>Ring Hash</li><li>Least Request</li></ul></li></ul><h3 id="稳定性治理"><a href="#稳定性治理" class="headerlink" title="稳定性治理"></a>稳定性治理</h3><ul><li>线上服务总是会出问题的，这与程序的正确性无关<ul><li>网络攻击</li><li>流量突增</li><li>机房断电</li><li>光纤被挖</li><li>机器故障</li><li>网络故障</li><li>……</li></ul></li><li>微服务架构中典型的稳定性治理功能<ul><li>限流<ul><li>限制服务处理的最大 QPS，拒绝过多请求</li><li><img src="https://img.lonesome.cn/blog/bytedance/7P6U_HGS_24@5I07DDY.webp"></li></ul></li><li>熔断<ul><li>中断请求路径，增加冷却时间从而让故障实例尝试恢复</li><li><img src="https://img.lonesome.cn/blog/bytedance/EA0FK9MY6ZRY4PXP.webp"></li></ul></li><li>过载保护<ul><li>在负载高的实例中，主动拒绝一部分请求，防止实例被打挂</li><li><img src="https://img.lonesome.cn/blog/bytedance/6ANF_Z19_SQMWDZFI.webp"></li></ul></li><li>降级<ul><li>服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求</li><li><img src="https://img.lonesome.cn/blog/bytedance/SVBCLW1BA7HR_O_2QEE.webp"></li></ul></li></ul></li></ul><h2 id="字节跳动服务治理实践"><a href="#字节跳动服务治理实践" class="headerlink" title="字节跳动服务治理实践"></a>字节跳动服务治理实践</h2><h3 id="重试的意义"><a href="#重试的意义" class="headerlink" title="重试的意义"></a>重试的意义</h3><ul><li>本地函数调用——通常没有重试意义<ul><li><img src="https://img.lonesome.cn/blog/bytedance/5JJBVHO2QAXVIBQI.webp"></li><li>可能有哪些异常？<ul><li>参数非法</li><li>OOM（Out Of Memory）</li><li>NPE（Null Pointer Expection）</li><li>边界 case</li><li>系统崩溃</li><li>死循环</li><li>程序异常退出</li></ul></li></ul></li><li>远程函数调用<ul><li><img src="https://img.lonesome.cn/blog/bytedance/QCBPZYL5698S@BTMOX3.webp"></li><li>可能有哪些异常？<ul><li>网络抖动</li><li>下游负载高导致超时</li><li>下游机器宕机</li><li>本地机器负载高，调度超时</li><li>下游熔断、限流</li><li>……</li></ul></li></ul></li><li>重试的意义<ul><li>重试可以避免掉偶发的错误，提高 SLA（Service-Level Agreement）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/W_B@QGILNFUQ45CGZ4C.webp"></li></ul></li><li>降低错误率<ul><li>假设单次请求的错误概率为 0.01，那么连续两次错误概率则为 0.0001</li></ul></li><li>降低长尾延时<ul><li>对于偶尔耗时较长的请求，重试请求有机会提前返回</li></ul></li><li>容忍暂时性错误<ul><li>某些时候系统会有暂时性异常（例如网络抖动），重试可以尽量规避</li></ul></li><li>避开下游故障实例<ul><li>一个服务中可能会有少量实例故障（例如机器故障），重试其他实例可以成功</li></ul></li></ul></li></ul><h3 id="重试的难点"><a href="#重试的难点" class="headerlink" title="重试的难点"></a>重试的难点</h3><ul><li>幂等性<ul><li>多次请求可能会造成数据不一致</li></ul></li><li>重试风暴<ul><li>随着调用链路的增加，重试次数呈指数级上升</li><li><img src="https://img.lonesome.cn/blog/bytedance/5I50PCM0CUQPRH0X6V.webp"></li></ul></li><li>超时设置<ul><li>假设调用时间一共 1s，经过多少时间开始重试？</li></ul></li></ul><h3 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h3><ul><li>限制重试比例<ul><li>设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值</li><li>重试只有在大部分请求都成功，只有少量请求失败时才有必要</li><li>如果大部分请求都失败，重试只会加剧问题严重性</li><li><img src="https://img.lonesome.cn/blog/bytedance/H81CI6@B0XYDN1VB.webp"></li></ul></li><li>防止链路重试<ul><li>链路层面的防重试风暴的核心是限制每层都发生重试，理想情况下只有最下一层发生重试</li><li>可以返回特殊的 status code，表示“请求失败，但别重试”</li><li><img src="https://img.lonesome.cn/blog/bytedance/6EEG@MTM2FJGYA90YO8P1.webp"></li></ul></li><li>Hedged Requests<ul><li>对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应</li><li><img src="https://img.lonesome.cn/blog/bytedance/TF0AT16OROXQBT_7Q9.webp"></li></ul></li></ul><h3 id="重试效果验证"><a href="#重试效果验证" class="headerlink" title="重试效果验证"></a>重试效果验证</h3><p>实际验证经过上述重试策略后，在链路上发生的重试放大效应</p><p><img src="https://img.lonesome.cn/blog/bytedance/G@NPN661EEHQGO_8A7E.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微服务架构介绍&quot;&gt;&lt;a href=&quot;#微服务架构介绍&quot; class=&quot;headerlink&quot; title=&quot;微服务架构介绍&quot;&gt;&lt;/a&gt;微服务架构介绍&lt;/h2&gt;&lt;h3 id=&quot;系统架构演变历史&quot;&gt;&lt;a href=&quot;#系统架构演变历史&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="架构" scheme="https://lonesome.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="微服务" scheme="https://lonesome.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论——现代架构基石</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/distribution-theory--the-cornerstone-of-modern-architecture/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/distribution-theory--the-cornerstone-of-modern-architecture/</id>
    <published>2023-02-02T07:00:00.000Z</published>
    <updated>2024-08-09T17:53:20.377Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.lonesome.cn/blog/bytedance/5UTR0A6F9VN7IO40AV.webp"></p><h2 id="分布式概述"><a href="#分布式概述" class="headerlink" title="分布式概述"></a>分布式概述</h2><h3 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><ul><li>分布式系统是计算机程序的结合，这些程序利用跨多个独立计算节点的计算资源来实现共同的目标，可以分为分布式计算，分布式存储，分布式数据库等</li><li>优势：<ul><li>去中心化</li><li>低成本</li><li>弹性</li><li>资源共享</li><li>可靠性高</li></ul></li><li>挑战：<ul><li>普遍的节点故障</li><li>不可靠的网络</li><li>异构的机器与硬件环境</li><li>安全</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/G@BXNN2XX1LO0Q.webp"></p><h3 id="Why-How-What"><a href="#Why-How-What" class="headerlink" title="Why-How-What"></a>Why-How-What</h3><ul><li>使用者视角：<ul><li>Why：<ul><li>数据爆炸，对存储和计算有大规模运营的诉求</li><li>成本低，构建在廉价服务器之上</li></ul></li><li>How：<ul><li>分布式框架</li><li>成熟的分布式系统</li></ul></li><li>What：<ul><li>理清规模，负载，一致性要求等</li><li>明确稳定性要求，制定技术方案</li></ul></li></ul></li><li>学习者视角：<ul><li>Why：<ul><li>后端开发必备技能</li><li>帮助理解后台服务器之间协作的机理</li></ul></li><li>How：<ul><li>掌握分布式理论</li><li>了解一致性协议</li></ul></li><li>What：<ul><li>把要点深入展开，针对难点搜索互联网资料进行学习</li><li>把所学知识运用于实践</li></ul></li></ul></li></ul><h3 id="常见的分布式系统"><a href="#常见的分布式系统" class="headerlink" title="常见的分布式系统"></a>常见的分布式系统</h3><ul><li>分布式存储<ul><li>Google File System（GFS）：google 分布式文件系统</li><li>Ceph：统一的分布式存储系统</li><li>Hadoop HDFS：基于 GFS 架构的开源分布式文件系统</li><li>Zookeeper：高可用的分布式数据管理与系统协调框架</li></ul></li><li>分布式数据库<ul><li>Google Spanner：google 可扩展的、全球分布式的数据库</li><li>TiDB：开源分布式关系型数据库</li><li>HBase：开源 Nosql 数据库</li><li>MongoDB：文档数据库</li></ul></li><li>分布式计算<ul><li>Hadoop：基于 MapReduce 分布式计算框架</li><li>Spark：在 Hadoop 基础上，使用内存来存储数据</li><li>YARN：分布式资源调度</li></ul></li></ul><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><h3 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h3><ul><li>Byzantine failure：节点可以任意篡改发送给其他节点的数据，是最难处理的故障</li><li>Authentication detectable byzantine failure (ADB)：节点可以篡改数据，但不能伪造其他节点的数据</li><li>Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚</li><li>Omission failure：节点收到数据的时间无限晚，即收不到数据</li><li>Crash failure：在 Omission failure 的基础上，增加了节点停止响应的假设，也即持续性地 Omission failure</li><li>Fail-stop failure：在 Crash failure 的基础上增加了错误可检测的假设</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/1Y_DQ2MCL18CXDC41.webp"></p><h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><ul><li><p>引入：</p><ul><li>两支军队的将军只能派信使穿越敌方领土互相通信，以此约定进攻时间。该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就进攻时间达成共识</li></ul></li><li><p>结论：</p><ul><li>两将军问题是被证实无解的电脑通信问题，两支军队理论上永远无法达成共识</li></ul></li><li><p>方案：</p><ul><li>一、同时发送 N 个信使，任何一个达到对方军队，都算成功</li><li>二、设置超时时间，发送后未在一定时间返回，则加派信使</li></ul></li><li><p>共识与消息传递的不同：即使保证了消息传递成功，也不能保证达成共识</p></li><li><p>TCP 三次握手是在两个方向确认包的序列号，增加了超时重试，是两将军问题的一个工程解</p></li><li><p>三将军问题</p><ul><li>拜占庭将军考虑更加普适的场景，例如 3 个将军 ABC 互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致</li><li>如果没有”叛徒“，无论各自观察到怎样的敌情，总能达成一致的行动</li><li>由于“叛徒”C 的存在，将军 A 和将军 B 获得不同的信息。这样将军 A 获得 2 票进攻 1 票撤退的信息，将军 B 获得 1 票进攻 2 票撤退的信息，产生了不一致</li><li><img src="https://img.lonesome.cn/blog/bytedance/GE5LZ9I6EWQ3@DLY1@54G.webp"></li></ul></li><li><p>四将军问题</p><ul><li>考虑当 4 个将军，只有一个叛徒的场景，将军 D 作为消息分发中枢，约定如果没收到消息则执行撤退</li><li>步骤：<ul><li>如果 D 为“叛徒”，ABC 无论收到任何消息，总能达成一致</li><li>D 为“忠将”，ABC 有 2 人将 D 的消息进行正确的传递，同样能保证最终决策符合大多数</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/ADB4BPC6D8EQ98IT1A.webp"></li><li>进而能够证明，当有 3m+1 个将军，m 个“叛徒”时，可以进行 m 轮协商，最终达成一致</li></ul></li></ul><h3 id="共识和一致性"><a href="#共识和一致性" class="headerlink" title="共识和一致性"></a>共识和一致性</h3><ul><li>客户端 A 读到 x&#x3D;0，当客户端 C 正在写入时，客户端 A 和客户端 B 可能读到 0 或者 1。但是当 C 写入完成后，A 和 B 最终能读到一致的数据，称这样的一致性为 Eventually consistent（最终一致性）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/W39637XC7_TI0LA.webp"><br>读请求和写请求并发时可能读到旧值</li></ul></li><li>当客户端 A 读到更新的版本 x&#x3D;1 后，及时将消息同步给其他客户端，这样其他客户端立即能获取到 x&#x3D;1，称这样的一致性为 Linearizability（线程一致性）<ul><li><img src="https://img.lonesome.cn/blog/bytedance/39SHFW__V0W5CNT7B.webp"><br>一旦某个读取到新值，所有客户端都必须返回新值</li></ul></li><li>如果要保证”线程“一致性，多个节点间势必需要进行协商，以寻求一致。这样增加了延迟，系统可用性便会受损</li></ul><h3 id="时间和事件顺序"><a href="#时间和事件顺序" class="headerlink" title="时间和事件顺序"></a>时间和事件顺序</h3><ul><li>1978 年 Leslie Lamport 发表《Time, Clocks, and the Ordering of Events in a Distributed System》<ul><li>我们定义 ”happened before“ 关系，记为”-&gt;“。其满足如下三个条件：<ul><li>如果 a 和 b 是在相同节点上的两个事件，a 在 b 之前发生，则定义 a-&gt;b</li><li>如果事件 a 表示某个节点发送某条消息，b 是另一个节点接受这条消息，则有 a-&gt;b</li><li>如果有 a-&gt;b 且 b-&gt;c ，则有 a-&gt;c</li></ul></li><li>当且仅当 a -&#x2F;-&gt; b 且 b -&#x2F;-&gt; a 时，我们称两个事件为并发的（concurrent）</li></ul></li><li>Lamport 逻辑时钟<ul><li>对于每一个节点 Pi 我们定义时钟 Ci 为一个函数，它为任意的事件 a 赋值编号为 Ci(a)<ul><li>如果 a 和 b 是在相同节点 pi 上的两个事件，a 在 b 之前发生，则有 Ci(a)&lt;Ci(b)</li><li>如果事件 a 表示节点 pi 发送某条消息，b 表示节点 Pj 接受这条消息，则有 Ci(a)&lt;Cj(b)</li></ul></li><li>在同一节点内的连续两个事件之间，至少要有一条 tick line</li><li>利用逻辑时钟，我们可以对整个系统中的事件进行全序排序</li></ul></li></ul><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p><img src="https://img.lonesome.cn/blog/bytedance/SLLBOEJYM58ZOU71RG6.webp"></p><ul><li>CAP 理论往往运用于数据库领域，同样可以适用于分布式存储方向</li><li>CA：放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择</li><li>AP：放弃一致性（这里说的是一致性是强一致性），追求分区容错性和可用性，例如一些注重用户体验的系统</li><li>CP：放弃可用性，追求一致性和分区容错性，例如与钱财安全相关的系统</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/YC5TBWQZFF03E87.webp"></p><p>在网络发生分区的情况下，我们必须在可用性和一致性之间做出选择。近似解决方法：把故障节点的负载转移给备用节点负责。下图演示了如何做故障转移：</p><p><img src="https://img.lonesome.cn/blog/bytedance/9ZOF_9DF6WJU@DAL@VZPE.webp"></p><h3 id="ACID-理论"><a href="#ACID-理论" class="headerlink" title="ACID 理论"></a>ACID 理论</h3><ul><li><strong>事务</strong>是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行</li><li>数据库事务拥有四个特性<strong>ACID</strong>：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）</li><li>原子性（A）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li><li>一致性（C）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</li><li>隔离性（I）：隔离性是当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li><li>持久性（D）：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即使是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</li></ul><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><ul><li>Base 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的，其核心思想是：<ul><li>Basically Available(基本可用)：假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：响应时间上的损失，或功能上的损失</li><li>Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延迟</li><li>Eventually consistent（最终一致性）：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值</li></ul></li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><h3 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h3><ul><li>二阶段提交（Two-phase Commit）：为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法</li><li>三个假设：<ul><li>引入协调者（Coordinator）和参与者（Participants），互相进行网络通信</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li></ul></li><li><img src="https://img.lonesome.cn/blog/bytedance/ZJH0N51EY_@ZYLU.webp"></li><li>可能出现的情况：<ul><li>1、Coordinator 不宕机，Participant 宕机。需要进行回滚操作</li><li>2、Coordinator 宕机，Participant 不宕机。可以引起新的协调者，待查询状态后，重复二阶段提交</li><li>3、Coordinator 宕机，Participant 宕机。无法确定状态，需要数据库管理员的介入，防止数据库进入一个不一致的状态</li></ul></li><li>回滚：在 Prepare 阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚</li><li><img src="https://img.lonesome.cn/blog/bytedance/2OYH2PYDA10JH495G8.webp"></li><li>需注意的问题：<ul><li>性能问题<ul><li>两阶段提交需要多次节点间的网络通信，耗时过大，资源需要进行锁定，徒增资源等待时间</li></ul></li><li>协调者单点故障问题<ul><li>如果事务协调者节点宕机，需要另起新的协调者，否则参与者处于中间状态无法完成事务</li></ul></li><li>网络分区带来的数据不一致<ul><li>一部分参与者收到了 Commit 消息，另一部分参与者没收到 Commit 消息，会导致节点之间数据不一致</li></ul></li></ul></li></ul><h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><ul><li>三阶段提交 vs 两阶段提交<ul><li>将两阶段提交中的 Prepare 阶段，拆成两部分：CanCommit 和 PreCommit 机制</li></ul></li><li>解决了两个问题：<ul><li>单点故障问题</li><li>阻塞问题</li></ul></li><li>另外引入超时机制，在等待超时之后，会继续进行事务的提交</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/NGYK3IL1@I8DDHGEGGCY.webp"></p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p><img src="https://img.lonesome.cn/blog/bytedance/7J251_9H1EZCW5U.webp"></p><ul><li>MVCC 是一种并发控制的方法，维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不阻塞读。MVCC 为每个修改保存一个版本，和事务的时间戳相关联，可以提高并发性能，解决脏读的问题</li><li>版本的选取：<ul><li>物理时钟：提供 TrueTime API，有 Master 节点维持一个绝对时间，保证各个服务器之间时钟误差控制在 ϵ 内，通常 ϵ&lt;7ms</li><li>逻辑时钟：时间戳预言机（TSO），采用中心化授时的方式，所有协调者向中心化节点获取时钟，优点是算法简单，实现方便，但需要每个节点都与他进行交互，会产生一些网络通信的成本。TSo 的授时中就需要考虑低延迟、高性能以及更好的容错性</li></ul></li></ul><h2 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h2><h3 id="Quorum-NWR-模型"><a href="#Quorum-NWR-模型" class="headerlink" title="Quorum NWR 模型"></a>Quorum NWR 模型</h3><ul><li>Quorum NWR 三要素<ul><li>N：在分布式存储系统中，有多少份备份数据</li><li>W：代表一次成功的更新操作要求至少有 w 份数据写入成功</li><li>R： 代表一次成功的读数据操作要求至少有 R 份数据成功读取</li></ul></li><li>为了保证强一致性，需要保证 W+R&gt;N</li><li>Quorum NWR 模型将 CAP 的选择交给用户，是一种简化版的一致性模型</li><li><img src="https://img.lonesome.cn/blog/bytedance/FP1P6IV7S22D05BKF1GFY.webp"></li><li>引起的并发更新问题<ul><li>如果允许数据被覆盖，则并发更新容易引起一致性问题</li></ul></li></ul><h3 id="RAFT-协议"><a href="#RAFT-协议" class="headerlink" title="RAFT 协议"></a>RAFT 协议</h3><ul><li>Raft 协议是一种分布式一致性算法（共识算法），即使出现部分节点故障，网络延时等情况，也不影响各节点，进而提高系统的整体可用性。Raft 是使用较为广泛的分布式协议。一定意义上讲，RAFT 也使用了 Quorum 机制</li><li>三种角色：<ul><li>Leader - 领导者：Leader 负责处理所有的客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后，通知 Follower 提交日志</li><li>Follower - 跟随者：不会发送任何请求，接受并持久化 Leader 同步的日志，在 Leader 告知日志可以提交后，提交日志。当 Leader 出现故障时，主动推荐自己为 Candidate</li><li>Candidate - 备选者：Leader 选举过程中的临时角色，向其他节点发送请求投票信息，如果获得大多数选票，则晋升为 Leader</li><li><img src="https://img.lonesome.cn/blog/bytedance/TCDWXV9C6IG7OM6Z4DI4XS.webp"></li></ul></li><li>四种定义：<ul><li>Log（日志）：节点之间同步的信息，以只追加写的方式进行同步，解决了数据被覆盖的问题</li><li>Term（任期号）：单调递增，每个 Term 内最多只有一个 Leader</li><li>Committed：日志被复制到多数派节点，即可认为已经被提交</li><li>Applied：日志被应用到本地状态机：执行了 log 中命令，修改了内存状态</li></ul></li><li>状态转移：<ul><li><img src="https://img.lonesome.cn/blog/bytedance/0@SV6MQLDQO4_4QM4.webp"></li></ul></li><li>Leader 选举过程：<ul><li>1、初始全部为 Follower</li><li>2、Current Term + 1</li><li>3、选举自己</li><li>4、向其它参与者发起 RequestVote 请求，retry 直到<ul><li>收到多数派请求，成为 Leader，并发送心跳</li><li>收到其它 Leader 的请求，转为 Follower，更新自己的 Term</li><li>收到部分，但未达到多数派，选举超时，随机 timeout 开始下一轮</li></ul></li><li>两个规则<ul><li>在一个任期内每个参与者最多投一票（持久化）</li><li>要成为 Leader，必须拿到多数投票</li></ul></li></ul></li><li>Log Replication 过程：<ul><li>新 Leader 产生，Leader 和 Follower 不同步，Leader 强制覆盖 Followers 的不同步的日志</li><li>1、Leader 收到写请求 w</li><li>2、将 w 写入本地 log</li><li>3、向其他 Follower 发起 AppendEntries RPC</li><li>4、等待多数派回复<ul><li>更新本地状态机，返回给客户端</li><li>下一个心跳通知 Follower 上一个 Log 已经被 Commited 了</li><li>Follower 也根据命令应用本地状态机</li></ul></li><li>5、Follower 有问题，Leader 一直 retry</li></ul></li><li>问题：如果 Leader 有问题呢？</li><li>切主：<ul><li>当 Leader 出现问题时，就需要进行重新选举</li><li>1、Leader 发现失去 Follower 的响应，失去 Leader 身份</li><li>2、两个 Follower 之间一段时间未收到心跳，重新进行选举，选出新的 Leader，此时发生了切主</li><li>3、Leader 自杀重启，以 Follower 的身份加入进来</li></ul></li><li>问题：老 Leader 未失去身份，新 Leader 已经选出，产生了”双主“如何解决？</li><li>Stale 读：<ul><li>发生 Leader 切换，old leader 收到了读请求。如果直接响应，可能会有 Stale Read</li><li>解决方案：保证读的强一致</li><li>该操作在 lease timeout 内，默认自己是 Leader；不是则发起一次 heartbeat。等待 Commit Index 应用到状态机</li><li>Election timeout &gt; least timeout；新 Leader 上任，自从上次心跳之后一定超过了 Election timeout，旧 Leader 大概率能够发现自己的 Lease 过期</li></ul></li></ul><h3 id="Paxos-协议"><a href="#Paxos-协议" class="headerlink" title="Paxos 协议"></a>Paxos 协议</h3><ul><li>Paxos 算法与 RAFT 算法区别：<ul><li>Multi-Paxos 可以并发修改日志，而 Raft 写日志操作必须是连续的</li><li>Multi-Paxos 可以随机选主，不必最新最全的节点当选 Leader</li></ul></li><li>优势：写入并发性能高，所有节点都能写</li><li>劣势：没有一个节点有完整的最新的数据，恢复流程复杂，需要同步历史记录 - <img src="https://img.lonesome.cn/blog/bytedance/S_THKV05YR6EN4Y.webp"> -<br><img src="https://img.lonesome.cn/blog/bytedance/WK4H4CUIT9T2CKXEV0CODP.webp"></li></ul><h2 id="分布式实践"><a href="#分布式实践" class="headerlink" title="分布式实践"></a>分布式实践</h2><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p><img src="https://img.lonesome.cn/blog/bytedance/8Z0698S0I8E9GW2X.webp"></p><ul><li>Mapper：将输入分解为多个 Job 来并行处理，彼此间几乎没有依赖关系</li><li>Shuffler：将 maper 结果打乱，防止数据倾斜</li><li>Reducer：对 map 阶段的结果进行全局汇总</li><li>容错：<ul><li>Mapper 故障：由中心化节点重新发起调度，新起 Mapper 重跑 job</li><li>Reducer 故障：重跑 Mapper，代价大</li></ul></li></ul><h3 id="分布式-KV"><a href="#分布式-KV" class="headerlink" title="分布式 KV"></a>分布式 KV</h3><p><img src="https://img.lonesome.cn/blog/bytedance/2ZX1JU7OSX4XATU0K3A.webp"></p><ul><li>架构：<ul><li>将海量结构化数据根据 Key 分成不同的 Region，每个 Region 构建一个单机 KV 数据库，Region 之间形成 Raft Groups，做到强一致</li></ul></li><li>容错：<ul><li>当 Node 故障时，通过 Raft Learner 模式进行数据修复</li></ul></li><li>弹性：<ul><li>当出现局部 Key 热点或数据膨胀时，Region 可以进行 Split 操作，分成两个子 Region，反之收缩时进行 Merge 操作</li></ul></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><img src="https://img.lonesome.cn/blog/bytedance/H2DR0_W6ZXLICGT9Q.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img.lonesome.cn/blog/bytedance/5UTR0A6F9VN7IO40AV.webp&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式概述&quot;&gt;&lt;a href=&quot;#分布式概述&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="架构" scheme="https://lonesome.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="分布式" scheme="https://lonesome.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>架构初探——谁动了我的蛋糕</title>
    <link href="https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/a-preliminary-study-on-the-architecture--who-touched-my-cake/"/>
    <id>https://lonesome.cn/blog/bytedance-5th-youthcamp-backend/a-preliminary-study-on-the-architecture--who-touched-my-cake/</id>
    <published>2023-02-01T06:45:00.000Z</published>
    <updated>2024-08-09T17:53:21.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>架构</strong>，又称<strong>软件架构</strong><ul><li>是有关软件整体结构与组件的抽象描述</li><li>用于指导软件系统各个方面的设计</li></ul></li><li>实现一个软件有很多种方式，架构在<strong>方法选择</strong>上起着至关重要的指导作用</li><li>架构的<strong>重要性</strong><ul><li>地基没打好，大厦容易倒</li><li>地基坚实了，大厦才能盖得高</li><li>站在巨人肩膀上，才能看得远</li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>兰师傅蛋糕坊要开张了，亟须解决如下问题：<ul><li>如何做蛋糕<ul><li>独家秘方，还是亲自做比较好</li></ul></li><li>如何卖蛋糕<ul><li>刚开始客流量应该不大，边做边卖</li></ul></li></ul></li></ul><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><p><img src="https://img.lonesome.cn/blog/bytedance/ON8Q63WPGZ@JREY576QY.webp"></p><ul><li>软件系统需要具备对外提供服务，<strong>单机</strong>，就是把所有功能都实现在一个进程里，并部署在一台机器上</li><li>优点：<ul><li>简单</li></ul></li><li>问题：<ul><li><a href="http://www.kegel.com/c10k.html">C10K problem</a></li><li>运维需要停服</li></ul></li><li>演进：如何卖更多的蛋糕？<ul><li>多雇几个蛋糕师傅</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/MFGFVUFSMVI5O0ZD9W.webp"></p><ul><li><strong>单机架构</strong>：分布式部署</li><li><strong>垂直应用架构</strong>：按应用垂直切分的单体</li><li>优点：<ul><li>水平扩容</li><li>运维不需要停服</li></ul></li><li>问题：<ul><li>职责太多，开发效率不高</li><li>爆炸半径大</li></ul></li><li>演进：如何提高做蛋糕效率？<ul><li>分工协作</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/WTN1AHM_2QWHENPX4Z0.webp"></p><h3 id="SOA、微服务-水平切分"><a href="#SOA、微服务-水平切分" class="headerlink" title="SOA、微服务|水平切分"></a>SOA、微服务|水平切分</h3><p><img src="https://img.lonesome.cn/blog/bytedance/@5SFRJZORORDL2WTQRCEP.webp"></p><ul><li><strong>SOA</strong>（Service-Oriented Architecture）<ul><li>将应用的不同功能单元抽象为<strong>服务</strong></li><li>定义服务之间的<strong>通信标准</strong></li></ul></li><li><strong>微服务架构</strong>：<strong>SOA</strong>  的去中心化演进方向</li><li>问题：<ul><li>数据一致性<ul><li>装货台共交付了多少蛋糕？</li></ul></li><li>高可用<ul><li>这么多师傅，如何合作？</li></ul></li><li>治理<ul><li>烤箱坏了，怎么容灾？</li></ul></li><li>解耦 vs 过微<ul><li>运维成本高了，值当么？</li></ul></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>架构演进初衷：好比做蛋糕<ul><li>需求量越来越大，终归要增加人手</li><li>越做越复杂，终归要分工合作</li></ul></li><li>架构的演进思路：就像切蛋糕，蛋糕越来越大，一口吃不下终归要切分<ul><li>竖着切（垂直切分）</li><li>横着切（水平切分）</li></ul></li></ul><h2 id="企业级后端架构剖析"><a href="#企业级后端架构剖析" class="headerlink" title="企业级后端架构剖析"></a>企业级后端架构剖析</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>兰师傅蛋糕店经过 3 年的蓬勃发展，积累了良好的口碑和用户基础，接下来，需要扩大规模：</li><li>店面怎么盘：<ul><li>买</li><li>租</li></ul></li><li>师傅怎么招：<ul><li>兰师傅全家出马</li><li>招培训班出身的</li></ul></li><li>是否继续坚持纯手工制作？</li><li>规模大了以后，工作重心应该是？<ul><li>精进蛋糕制作收益</li><li>蛋糕店重点方向梳理 &amp; 未来规划</li></ul></li></ul><h3 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h3><ul><li><strong>云计算</strong>：是指通过软件自动化管理，提供计算资源的服务网站，是现代互联网大规模数据分析和存储的基石</li><li>基础：<ul><li>虚拟化技术 - 整租 vs 合租</li><li>编排方案 -业主 vs 租凭平台</li></ul></li><li>架构：<ul><li><strong>IaaS</strong>（Infrastructure as a Service）<ul><li>买房子 vs 房屋租聘平台</li></ul></li><li><strong>PaaS</strong>（platform as a Service）<ul><li>清包 vs 全包</li></ul></li><li><strong>Saas</strong>（Software as a Service）<ul><li>从零培训 vs 雇佣培训过的师傅</li></ul></li><li><strong>FaaS</strong>（Function as a Service）<ul><li>纯手工制作 vs 蛋糕机批量生产</li></ul></li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/TV8P9CSX9_3026S9_4FB.webp"></p><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><p>云原生技术为组织（公司）在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性扩展的应用提供了可能</p><p><img src="https://img.lonesome.cn/blog/bytedance/VP4YSXFA6PN7GM_0CT.webp"></p><h4 id="弹性资源"><a href="#弹性资源" class="headerlink" title="弹性资源"></a>弹性资源</h4><ul><li><p>弹性计算资源类型：</p><ul><li>服务资源调度<ul><li>微服务：和面、雕花</li><li>大服务：烤箱</li></ul></li><li>计算资源调度<ul><li>在线：热销榜单</li><li>离线：热销榜单更新</li></ul></li><li>消息队列<ul><li>在线：削峰、解耦</li><li>离线：大数据分析</li></ul></li></ul></li><li><p>弹性存储资源类型：</p><ul><li>经典<ul><li>对象：宣传视频</li><li>大数据：用户消费记录</li></ul></li><li>关系型数据库<ul><li>收银记录</li></ul></li><li>元数据<ul><li>服务发现：蛋糕店通讯录</li></ul></li><li>NoSQL<ul><li>KV：来个 xx 蛋糕</li></ul></li></ul></li><li><p>总结：将存储资源当成服务一样</p></li></ul><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><ul><li>DevOps 是云原生时代软件交付的利器，贯穿证个软件开发周期</li><li>结合自动化流程，提高软件开发、交付效率</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/3GXPNL483UUTV_NSTHAV.webp"></p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><ul><li><strong>通信标准</strong>：<ul><li>HTTP（RESTful API）</li><li>RPC（Thrift，gRPC）</li></ul></li><li>微服务中间件 RPC vs HTTP：<ul><li>性能</li><li>服务治理</li><li>服务可解释性</li></ul></li><li>云原生场景下，微服务大可不必在业务逻辑中实现符合通信标准的交互逻辑，而是交给框架来做</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/ETPSB8NQI6Y0D34T9L.webp"></p><h4 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h4><ul><li>服务网格（Service Mesh）：<ul><li>微服务之间通讯的中间层</li><li>高性能网格代理</li><li>业务代码与治理解耦</li></ul></li><li>相比较于 RPC&#x2F;HTTP 框架：<ul><li>异构系统治理统一化</li><li>与业务进程解耦，生命周期易管理</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/FHLXIIL4LR0X7FW4I2F2.webp"></p><h3 id="云原生蛋糕店"><a href="#云原生蛋糕店" class="headerlink" title="云原生蛋糕店"></a>云原生蛋糕店</h3><ul><li>企业级蛋糕店架构：<ul><li>售卖</li><li>蛋糕制作（肉松、慕斯）</li><li>会员激励</li><li>满意度分析</li><li>研发新品</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/N675STINYAVHZ7LB3O.webp"></p><h2 id="企业级后端架构的挑战"><a href="#企业级后端架构的挑战" class="headerlink" title="企业级后端架构的挑战"></a>企业级后端架构的挑战</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li>挑战：<ul><li>物理资源是有限的<ul><li>机器</li><li>宽带</li></ul></li><li>资源利用率受制于部署服务</li></ul></li><li>用户层面<ul><li>网络通信开销较大</li><li>网络抖动导致运维成本提高</li><li>异构环境下，不同实例资源水位不同</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/GBJ0@ROJ9SJ4T6V5G2K.webp"></p><h3 id="离在线资源并池"><a href="#离在线资源并池" class="headerlink" title="离在线资源并池"></a>离在线资源并池</h3><ul><li>核心收益：<ul><li>降低物理资源成本</li><li>提供更多的弹性资源，增加收入</li></ul></li><li>解决思路：<strong>离在线资源并池</strong></li><li>在线业务的特点<ul><li>IO 密集型为主</li><li>潮汐性、实时性</li></ul></li><li>离线业务的特点<ul><li>计算密集型占多数</li><li>非实时性</li></ul></li><li>问题：同一个机器怎么做离在线隔离？</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/DQJLX9KH06TFE4.webp"></p><h3 id="自动扩缩容"><a href="#自动扩缩容" class="headerlink" title="自动扩缩容"></a>自动扩缩容</h3><ul><li>核心收益：<ul><li>降低业务成本</li></ul></li><li>解决思路：<ul><li>自动扩缩容<ul><li>利用在线业务潮汐性自动扩缩容</li></ul></li></ul></li><li>问题：扩缩容依据什么指标？</li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/Z82SY6TTZ5VK_D5PXBOC9.webp"></p><h3 id="微服务亲和性部署"><a href="#微服务亲和性部署" class="headerlink" title="微服务亲和性部署"></a>微服务亲和性部署</h3><ul><li>核心收益<ul><li>降低业务成本</li><li>提高服务可用性</li></ul></li><li>解决思路：微服务亲和性部署<ul><li>将满足亲和性条件的容器调度到一台宿主机</li><li>微服务中间件与服务网格通过共享内存通信</li><li>服务网格控制面实施灵活、动态的流量调度</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/ZU4R0_7OGEL_3O@US.webp"></p><h3 id="流量治理"><a href="#流量治理" class="headerlink" title="流量治理"></a>流量治理</h3><ul><li>核心收益：<ul><li>提高微服务调用容错性</li><li>容灾</li><li>进一步提高开发效率，DevPos 发挥到极致</li></ul></li><li>解决思路：基于微服务中间件 &amp; 服务网格的流量治理<ul><li>熔断、重试</li><li>单元化</li><li>复杂环境（功能、预览）的流量调度</li></ul></li></ul><h3 id="CPU-水位负载均衡"><a href="#CPU-水位负载均衡" class="headerlink" title="CPU 水位负载均衡"></a>CPU 水位负载均衡</h3><ul><li>核心收益：<ul><li>打平异构环境算力差异</li><li>为自动扩缩容提供正向收入</li></ul></li><li>解决思路：CPU 水位负载均衡<ul><li>IaaS<ul><li>提供服务探针</li></ul></li><li>服务网格<ul><li>动态负载均衡</li></ul></li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/WI2Q3HTSRSB2NC5RJ.webp"></p><h2 id="后端架构实战"><a href="#后端架构实战" class="headerlink" title="后端架构实战"></a>后端架构实战</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><ul><li>兰师傅蛋糕店也碰到了类似的问题：<ul><li>不同师傅干活的效率差距较大</li><li>有些师傅希望能者多劳多挣</li></ul></li><li>在这个背景下，继续像之前一样为每个师傅分配完全相同的工作，会引起他们的不满</li><li>回到 CPU 水位负载均衡，应该如何设计？<ul><li>需要哪些输入？</li><li>设计师需要考虑哪些关键点？</li></ul></li></ul><h3 id="问题提炼"><a href="#问题提炼" class="headerlink" title="问题提炼"></a>问题提炼</h3><ul><li>输入：<ul><li>服务网格数据面<ul><li>支持带权重的负载均衡策略</li></ul></li><li>注册中心存储了所有容器的权重信息</li><li>宿主机能提供<ul><li>容器的资源使用情况</li><li>物理资源信息（如 CPU 型号）</li></ul></li></ul></li><li>关键点：<ul><li>紧急回滚能力</li><li>大规模</li><li>极端情况</li></ul></li></ul><h3 id="自适应静态权重"><a href="#自适应静态权重" class="headerlink" title="自适应静态权重"></a>自适应静态权重</h3><ul><li>方案：<ul><li>采集宿主机物理资源信息</li><li>调整容器注册的权重</li></ul></li><li>优势：<ul><li>复杂度低</li><li>完全分布式，可用性高</li><li>微服务中间件无适配成本</li></ul></li><li>缺点：<ul><li>无紧急回滚能力</li><li>缺乏运行时自适应能力</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/KOCWM2CWZEL_4@_Q3G0@A.webp"></p><h3 id="自适应动态权重-Alpha"><a href="#自适应动态权重-Alpha" class="headerlink" title="自适应动态权重 Alpha"></a>自适应动态权重 Alpha</h3><ul><li>方案：<ul><li>容器动态权重的自适应调整</li><li>服务网格的服务发现 &amp; 流量调度能力</li></ul></li><li>演进方向：<ul><li>解决无法紧急回滚的问题</li><li>运行时权重自适应</li></ul></li><li>缺点：<ul><li>过度流量倾斜可能会有异常情况</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/NP3SEYT0L3M3RCD7KFBDL.webp"></p><h3 id="自适应动态权重-Beta"><a href="#自适应动态权重-Beta" class="headerlink" title="自适应动态权重 Beta"></a>自适应动态权重 Beta</h3><ul><li>方案：<ul><li>服务网格上报 RPC 指标</li></ul></li><li>演进方向：<ul><li>极端场景的处理成为可能</li></ul></li><li>缺点：<ul><li>时序数据库压力较大</li><li>动态权重决策中心职责越来越多，迭代-&gt;变更-&gt;风险</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/7YFFJLQ1MD@09JS.webp"></p><h3 id="自适应动态权重-Release"><a href="#自适应动态权重-Release" class="headerlink" title="自适应动态权重 Release"></a>自适应动态权重 Release</h3><ul><li>演进方向：<ul><li>微服务化</li><li>引入消息队列削峰、解耦</li><li>离在线链路切分</li><li>梳理强弱依赖</li></ul></li></ul><p><img src="https://img.lonesome.cn/blog/bytedance/XV7QE6UM5ZG6R5TNVO1.webp"></p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><ul><li>没有最好的架构，只有最合适的架构</li><li>如何做架构设计<ul><li>需求先行：弄清楚要解决什么问题</li><li>业界调研：业界都有哪些解决方案可供参考</li><li>技术选型：内部&#x2F;社区都有哪些基础组件</li><li>异常情况：考虑清楚 xxx 不行了怎么办</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是架构&quot;&gt;&lt;a href=&quot;#什么是架构&quot; class=&quot;headerlink&quot; title=&quot;什么是架构&quot;&gt;&lt;/a&gt;什么是架构&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定</summary>
      
    
    
    
    <category term="字节青训营" scheme="https://lonesome.cn/categories/bytedance/"/>
    
    
    <category term="架构" scheme="https://lonesome.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
